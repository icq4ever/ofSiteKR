<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<meta content="text/css" http-equiv="Content-Style-Type"/>
<meta content="pandoc" name="generator"/>
<title>ofBook - threads</title>
<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
  </style>
<link href="../style/bootstrap.min.css" rel="stylesheet">
<link href="../style/style.css" rel="stylesheet" type="text/css"/>
<link href="http://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic,700italic|Merriweather:400,300,300italic,400italic,700,900,700italic,900italic" rel="stylesheet" type="text/css">
<script src="../javascript/jquery-1.8.3.min.js"></script>
<script src="../javascript/bootstrap.min.js"></script>
<script src="../javascript/navbar.js"></script>
</link></link></head>
<body>
<div class="banner">
<div class="content-wrapper">
<b>현재 작업중인 내용이므로 완성본이 아닙니다!</b>
        보고 계신 내용은 오픈프레임웍스에 관해 여러사람들이 협업하여 작업/번역중인 임시적인 버전의 ofBook입니다. 이슈, 제안, 코멘트등은 <a href="https://github.com/openframeworks/ofBook/" target="_blank">repo</a>로 알려주시고, 번역에 관련된 경우 <a href="http://forum.openframeworks.kr/" target="_blank">오픈프레임웍스 한글 포럼</a>에 글을 남겨주시기 바랍니다.
    </div>
</div>
<div class="content-wrapper">
<nav role="navigation">
<ul id="nav-parts"><li class="group"><div class="groupTitle">Foreword</div><ul><li class="chapter"><div class="chapterTitle"><a href="foreword.html">foreword</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#책에관하여" target="_top">책에 관하여</a></li><li class="section"><a href="#credits" target="_top">Credits</a></li></ul></div></li></ul></li><li class="group"><div class="groupTitle">Basics</div><ul><li class="chapter"><div class="chapterTitle"><a href="of_philosophy.html">Philosophy</a></div></li></ul><ul><li class="chapter"><div class="chapterTitle"><a href="cplusplus_basics.html">C++ Language Basics</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#lookalive" target="_top">Look Alive!</a></li><li class="section"><a href="#iteration" target="_top">Iteration</a></li><li class="section"><a href="#compilingmyfirstapp" target="_top">Compiling My First App</a></li><li class="section"><a href="#beyondhelloworld" target="_top">Beyond Hello World</a></li><li class="section"><a href="#functions" target="_top">Functions</a></li><li class="section"><a href="#customfunctions" target="_top">Custom Functions</a></li><li class="section"><a href="#encapsulationofcomplexity" target="_top">Encapsulation of Complexity</a></li><li class="section"><a href="#variablespart1" target="_top">Variables (part 1)</a></li><li class="section"><a href="#conclusion" target="_top">Conclusion</a></li><li class="section"><a href="#ps" target="_top">PS.</a></li></ul></div></li></ul><ul><li class="chapter"><div class="chapterTitle"><a href="setup_and_project_structure.html">oF structure</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#firstthingsfirst" target="_top">First things first</a></li><li class="section"><a href="#welcometoyournewkitchen" target="_top">Welcome to your new kitchen</a></li><li class="section"><a href="#runningexamples" target="_top">Running examples</a></li><li class="section"><a href="#offolderstructure" target="_top">oF folder structure</a></li><li class="section"><a href="#theofpantry" target="_top">The oF Pantry</a></li></ul></div></li></ul><ul><li class="chapter"><div class="chapterTitle"><a href="intro_to_graphics.html">Graphics</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#brusheswithbasicshapes" target="_top">Brushes with Basic Shapes</a></li><li class="section"><a href="#brushesfromfreeformshapes" target="_top">Brushes from Freeform Shapes</a></li><li class="section"><a href="#movingtheworld" target="_top">Moving The World</a></li><li class="section"><a href="#nextsteps" target="_top">Next Steps</a></li></ul></div></li></ul><ul><li class="chapter"><div class="chapterTitle"><a href="OOPs!.html">Ooops! = Object Oriented Programming + Classes</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#overview" target="_top">Overview</a></li><li class="section"><a href="#whatisobjectorientedprogramming" target="_top">What is Object Oriented Programming</a></li><li class="section"><a href="#howtobuildyourownclassessimpleclass" target="_top">How to build your own Classes (simple Class)</a></li><li class="section"><a href="#makeanobjectfromyourclass" target="_top">Make an Object from your Class</a></li><li class="section"><a href="#makeobjectsfromyourclass" target="_top">Make objects from your Class</a></li><li class="section"><a href="#makemoreobjectsfromyourclass" target="_top">Make more Objects from your Class</a></li><li class="section"><a href="#makeevenmoreobjectsfromyourclasspropertiesandconstructors" target="_top">Make even more Objects from your Class: properties and constructors</a></li><li class="section"><a href="#makeobjectsonthefly" target="_top">Make Objects on the fly</a></li><li class="section"><a href="#makinganddeleteasyouwishusingvectors" target="_top">Making and delete as you wish - using vectors</a></li><li class="section"><a href="#quickintrotopolymorphisminheritance" target="_top">Quick intro to polymorphism (inheritance)</a></li></ul></div></li></ul><ul><li class="chapter"><div class="chapterTitle"><a href="how_of_works.html">how OF works</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#오픈프레임웍스코드의일반적인패턴설명" target="_top">오픈프레임웍스 코드의 일반적인 패턴 설명</a></li><li class="section"><a href="#setupupdatedraw" target="_top">setup, update, draw</a></li><li class="section"><a href="#클래스" target="_top">클래스</a></li><li class="section"><a href="#함수" target="_top">함수</a></li></ul></div></li></ul></li><li class="group"><div class="groupTitle">Approaches</div><ul><li class="chapter"><div class="chapterTitle"><a href="animation.html">Animation</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#background" target="_top">Background</a></li><li class="section"><a href="#animationinofusefulconcepts" target="_top">Animation in oF / useful concepts:</a></li><li class="section"><a href="#linearmovement" target="_top">Linear movement</a></li><li class="section"><a href="#functionbasedmovement" target="_top">Function based movement</a></li><li class="section"><a href="#simulation" target="_top">Simulation</a></li><li class="section"><a href="#wheretogofurther" target="_top">Where to go further</a></li></ul></div></li></ul><ul><li class="chapter"><div class="chapterTitle"><a href="game_design.html">Experimental Game Development</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#howdogamedevelopersactuallymakegames" target="_top">How do game developers actually make games?</a></li><li class="section"><a href="#sowhatisoscanyway" target="_top">So what is OSC, anyway?</a></li><li class="section"><a href="#ourbasicgameandmakingitnotsobasic" target="_top">Our basic game–and making it not so basic</a></li></ul></div></li></ul><ul><li class="chapter"><div class="chapterTitle"><a href="image_processing_computer_vision.html">image processing and computer vision</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#maybethereisamagicbullet" target="_top">Maybe There is a Magic Bullet</a></li><li class="section"><a href="#preliminariestoimageprocessing" target="_top">Preliminaries to Image Processing</a></li><li class="section"><a href="#이미지처리를얘기하기전에알아두어야할것들" target="_top">이미지처리를 얘기하기 전에 알아두어야 할것들</a></li><li class="section"><a href="#pointprocessingoperationsonimages" target="_top">Point Processing Operations on Images</a></li><li class="section"><a href="#acompleteworkflowbackgroundsubtraction" target="_top">A Complete Workflow: Background Subtraction</a></li><li class="section"><a href="#refinements" target="_top">Refinements</a></li><li class="section"><a href="#suggestionsforfurtherexperimentation" target="_top">Suggestions for Further Experimentation</a></li></ul></div></li></ul></li><li class="group"><div class="groupTitle">I/O</div><ul><li class="chapter"><div class="chapterTitle"><a href="hardware.html">Hardware</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#introduction" target="_top">introduction</a></li><li class="section"><a href="#소개" target="_top">소개</a></li><li class="section"><a href="#gettingstartedwithserialcommunication" target="_top">getting started with serial communication</a></li><li class="section"><a href="#시리얼통신시작하기" target="_top">시리얼 통신 시작 하기</a></li><li class="section"><a href="#digitalandanalogcommunication" target="_top">digital and analog communication</a></li><li class="section"><a href="#디지털과아날로그통신" target="_top">디지털과 아날로그 통신</a></li><li class="section"><a href="#usingserialforcommunicationbetweenarduinoandopenframeworks" target="_top">using serial for communication between arduino and openframeworks</a></li><li class="section"><a href="#lightsoncontrollinghardwareviadmx" target="_top">Lights On - controlling hardware via DMX</a></li></ul></div></li></ul><ul><li class="chapter"><div class="chapterTitle"><a href="sound.html">Sound</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#gettingstartedwithsoundfiles" target="_top">Getting Started With Sound Files</a></li><li class="section"><a href="#gettingstartedwiththesoundstream" target="_top">Getting Started With the Sound Stream</a></li><li class="section"><a href="#why1to1" target="_top">Why -1 to 1?</a></li><li class="section"><a href="#timedomainvsfrequencydomain" target="_top">Time Domain vs Frequency Domain</a></li><li class="section"><a href="#reactingtoliveaudio" target="_top">Reacting to Live Audio</a></li><li class="section"><a href="#synthesizingaudio" target="_top">Synthesizing Audio</a></li><li class="section"><a href="#audiogotchas" target="_top">Audio Gotchas</a></li></ul></div></li></ul><ul><li class="chapter"><div class="chapterTitle"><a href="network.html">Network</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#tcpvsudp" target="_top">TCP vs UDP</a></li><li class="section"><a href="#osc" target="_top">OSC</a></li></ul></div></li></ul></li><li class="group"><div class="groupTitle">Graphics</div><ul><li class="chapter"><div class="chapterTitle"><a href="openGL.html">Introducing OpenGL for OF</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#introducing" target="_top">Introducing</a></li><li class="section"><a href="#vertices" target="_top">Vertices</a></li><li class="section"><a href="#meshes" target="_top">Meshes</a></li><li class="section"><a href="#vbos" target="_top">VBOs</a></li><li class="section"><a href="#abasic3dscene" target="_top">A Basic 3D Scene</a></li><li class="section"><a href="#matrices" target="_top">Matrices</a></li><li class="section"><a href="#textures" target="_top">Textures</a></li><li class="section"><a href="#cameras" target="_top">Cameras</a></li></ul></div></li></ul><ul><li class="chapter"><div class="chapterTitle"><a href="lines.html">drawing lines</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#소개" target="_top">소개 ...</a></li><li class="section"><a href="#선그리기" target="_top">선 그리기</a></li><li class="section"><a href="#약간의노이즈abitofnoise" target="_top">약간의 노이즈A bit of noise</a></li><li class="section"><a href="#aweboflines" target="_top">A web of lines</a></li><li class="section"><a href="#makeasmoothlineinmovementina3dspace" target="_top">Make a smooth line in movement in a 3D space</a></li></ul></div></li></ul><ul><li class="chapter"><div class="chapterTitle"><a href="generativemesh.html">Basics of Generating Meshes from an Image</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#basicsofgeneratingmeshesfromanimage1" target="_top">Basics of Generating Meshes from an Image</a></li><li class="section"><a href="#basicsworkingwithofmesh" target="_top">Basics: Working with ofMesh</a></li><li class="section"><a href="#generativemeshusinganimagetodrivethecreationofamesh" target="_top">Generative Mesh: Using an image to drive the creation of a mesh</a></li><li class="section"><a href="#manipulationsaddingeffectsthatmodifythemesh" target="_top">Manipulations: Adding effects that modify the mesh</a></li><li class="section"><a href="#nextsteps" target="_top">Next Steps</a></li></ul></div></li></ul><ul><li class="chapter"><div class="chapterTitle"><a href="advanced_graphics.html">Advanced graphics</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#dimmediatemodevsofpolylineofpath" target="_top">2D, immediate mode vs ofPolyline/ofPath</a></li><li class="section"><a href="#d" target="_top">3D</a></li></ul></div></li></ul><ul><li class="chapter"><div class="chapterTitle"><a href="shaders.html">Introducing Shaders</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#introducing" target="_top">introducing</a></li><li class="section"><a href="#yourfirstshader" target="_top">Your first shader!</a></li><li class="section"><a href="#addinguniforms" target="_top">Adding Uniforms</a></li><li class="section"><a href="#addingsomeinteractivity" target="_top">Adding some interactivity</a></li><li class="section"><a href="#addingtextures" target="_top">Adding Textures</a></li><li class="section"><a href="#alphamasking" target="_top">Alpha Masking</a></li><li class="section"><a href="#multipletextures" target="_top">Multiple Textures</a></li><li class="section"><a href="#offbo" target="_top">ofFbo</a></li><li class="section"><a href="#texturesasdataegdisplacement" target="_top">Textures as Data (e.g. Displacement)</a></li><li class="section"><a href="#theendcongrats" target="_top">The End, Congrats!</a></li></ul></div></li></ul></li><li class="group selected"><div class="groupTitle">C++</div><ul><li class="chapter selected"><div class="chapterTitle selected"><a href="threads.html">threads</a></div><div class="chapterContents selected"><ul><li class="section selected"><a href="#쓰레드란무엇이고언제사용해야하는가" target="_top">쓰레드란 무엇이고 언제 사용해야 하는가</a></li><li class="section"><a href="#ofthread" target="_top">ofThread</a></li><li class="section"><a href="#스레드와opengl" target="_top">스레드와 openGL</a></li><li class="section"><a href="#ofmutex" target="_top">ofMutex</a></li><li class="section"><a href="#externalthreadsanddoublebuffering" target="_top">External threads and double buffering</a></li><li class="section"><a href="#ofscopedlock" target="_top">ofScopedLock</a></li><li class="section"><a href="#pococondition" target="_top">Poco::Condition</a></li><li class="section"><a href="#conclusion" target="_top">Conclusion</a></li></ul></div></li></ul><ul><li class="chapter"><div class="chapterTitle"><a href="memory.html">memory of C++</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#컴퓨터메모리와변수" target="_top">컴퓨터 메모리와 변수</a></li><li class="section"><a href="#스택변수함수내의변수vs오브젝트내의변수" target="_top">스택 변수, 함수내의 변수 vs 오브젝트내의 변수</a></li><li class="section"><a href="#포인터와레퍼런스" target="_top">포인터와 레퍼런스</a></li><li class="section"><a href="#힙heap영역에서의변수들" target="_top">힙(heap) 영역에서의 변수들</a></li><li class="section"><a href="#메모리구조배열과vector" target="_top">메모리 구조, 배열과 vector</a></li><li class="section"><a href="#다른메모리구조리스트와맵" target="_top">다른 메모리 구조, 리스트와 맵</a></li><li class="section"><a href="#스마트포인터" target="_top">스마트 포인터</a></li></ul></div></li></ul><ul><li class="chapter"><div class="chapterTitle"><a href="stl_vector.html">Introduction to vectors</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#quickreview" target="_top">Quick Review:</a></li><li class="section"><a href="#declaringavector" target="_top">Declaring a vector</a></li><li class="section"><a href="#addingelementstoavector" target="_top">Adding elements to a vector</a></li><li class="section"><a href="#resize" target="_top">resize</a></li><li class="section"><a href="#assign" target="_top">assign</a></li><li class="section"><a href="#accessingelementsofavector" target="_top">Accessing elements of a vector</a></li><li class="section"><a href="#erasingelementsofavector" target="_top">Erasing elements of a vector</a></li><li class="section"><a href="#iterators" target="_top">Iterators</a></li><li class="section"><a href="#sortingandshufflingavector" target="_top">Sorting and shuffling a vector</a></li><li class="section"><a href="#vectorsofobjects" target="_top">Vectors of objects</a></li></ul></div></li></ul><ul><li class="chapter"><div class="chapterTitle"><a href="stl_map.html">let's play with Map, std::map</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#소개map이무엇인가요" target="_top">소개 : map이 무엇인가요?</a></li><li class="section"><a href="#map에값삽입하기" target="_top">map에 값 삽입하기</a></li><li class="section"><a href="#map에서요소삭제하기" target="_top">map에서 요소 삭제하기</a></li><li class="section"><a href="#map을훑기" target="_top">map을 훑기</a></li><li class="section"><a href="#map에서요소찾기" target="_top">map에서 요소 찾기</a></li><li class="section"><a href="#map에오브젝트저장하기" target="_top">map에 오브젝트 저장하기</a></li><li class="section"><a href="#multimap이란무엇인가요" target="_top">multimap이란 무엇인가요?</a></li><li class="section"><a href="#다른유용한메소드들" target="_top">다른 유용한 메소드들</a></li><li class="section"><a href="#추가참고자료역자에의해추가됨" target="_top">추가 참고 자료 (역자에 의해 추가됨)</a></li></ul></div></li></ul><ul><li class="chapter"><div class="chapterTitle"><a href="c++11.html">C++ 11</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#introduction" target="_top">Introduction</a></li><li class="section"><a href="#auto" target="_top">auto</a></li><li class="section"><a href="#forthingthings" target="_top">for (thing : things)</a></li><li class="section"><a href="#override" target="_top">override</a></li><li class="section"><a href="#lambdafunctions" target="_top">Lambda functions</a></li></ul></div></li></ul></li><li class="group"><div class="groupTitle">Advanced topics</div><ul><li class="chapter"><div class="chapterTitle"><a href="math.html">Math: From 1D to 4D</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#onedimensionusingchange" target="_top">One Dimension: Using Change</a></li><li class="section"><a href="#moredimensionssomelinearalgebra" target="_top">More Dimensions: Some Linear Algebra</a></li></ul></div></li></ul></li><li class="group"><div class="groupTitle">Platforms</div><ul><li class="chapter"><div class="chapterTitle"><a href="ios.html">ofxiOS</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#openframeworksoniosdevices" target="_top">OpenFrameworks on iOS devices.</a></li><li class="section"><a href="#intro" target="_top">Intro</a></li><li class="section"><a href="#introtoobjectivec" target="_top">Intro to Objective-C</a></li><li class="section"><a href="#underthehood" target="_top">Under the Hood</a></li><li class="section"><a href="#ofuikit" target="_top">OF &amp; UIKit</a></li><li class="section"><a href="#mediaplaybackandcapture" target="_top">Media Playback and Capture</a></li><li class="section"><a href="#lifehacks" target="_top">Life Hacks</a></li><li class="section"><a href="#appstore" target="_top">App Store</a></li><li class="section"><a href="#casestudies" target="_top">Case Studies</a></li></ul></div></li></ul></li><li class="group"><div class="groupTitle">Tools</div><ul><li class="chapter"><div class="chapterTitle"><a href="version_control_with_git.html">Version control with Git</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#whatisversioncontrolandwhyshouldyouuseit" target="_top">What is version control, and why should you use it?</a></li><li class="section"><a href="#differentversioncontrolsystems" target="_top">Different version control systems</a></li><li class="section"><a href="#introductiontogit" target="_top">Introduction to Git</a></li><li class="section"><a href="#popularguiclients" target="_top">Popular GUI clients</a></li><li class="section"><a href="#conclusion" target="_top">Conclusion</a></li></ul></div></li></ul><ul><li class="chapter"><div class="chapterTitle"><a href="ofSketch.html">ofSketch</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#whatisofsketch" target="_top">What is ofSketch?</a></li><li class="section"><a href="#download" target="_top">Download</a></li><li class="section"><a href="#sketchformat" target="_top">Sketch Format</a></li><li class="section"><a href="#remotecoding" target="_top">Remote Coding</a></li><li class="section"><a href="#future" target="_top">Future</a></li></ul></div></li></ul><ul><li class="chapter"><div class="chapterTitle"><a href="installation_up_4evr_macosx.html">Installation up 4evr</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#step1prepyoursoftwareandthecomputer" target="_top">Step 1: Prep your software and the computer</a></li><li class="section"><a href="#step2bootintoyoursoftware" target="_top">Step 2: Boot into your software</a></li><li class="section"><a href="#step3keepitupchamp" target="_top">Step 3: Keep it up (champ!)</a></li><li class="section"><a href="#step4rebootperiodically" target="_top">Step 4: Reboot periodically</a></li><li class="section"><a href="#step5checkinonitfromafar" target="_top">Step 5: Check in on it from afar.</a></li><li class="section"><a href="#step6testtesttest" target="_top">Step 6: Test, test, test.</a></li><li class="section"><a href="#additionaltipslogging" target="_top">Additional Tips: Logging</a></li><li class="section"><a href="#memoryleakmurderer" target="_top">Memory leak murderer</a></li><li class="section"><a href="#alternateresources" target="_top">Alternate resources:</a></li></ul></div></li></ul><ul><li class="chapter"><div class="chapterTitle"><a href="installation_up_4evr_linux.html">installation up4ever - linux</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#몇가지추가적인팁" target="_top">몇가지 추가적인 팁:</a></li></ul></div></li></ul></li><li class="group"><div class="groupTitle">Case studies</div><ul><li class="chapter"><div class="chapterTitle"><a href="project_eva.html">Choreographies for Humans and Stars</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#projectoverview" target="_top">Project Overview</a></li><li class="section"><a href="#ideationandprototyping" target="_top">Ideation and Prototyping</a></li><li class="section"><a href="#findingthetechnicalsolutions" target="_top">Finding the Technical Solutions</a></li><li class="section"><a href="#developingthevisualizationsoftware" target="_top">Developing the Visualization Software</a></li><li class="section"><a href="#failsafesanddirtyfixes" target="_top">Fail-safes and dirty fixes</a></li><li class="section"><a href="#resultsandreception" target="_top">Results and Reception</a></li></ul></div></li></ul><ul><li class="chapter"><div class="chapterTitle"><a href="project_joel.html">Anthropocene</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#theproject" target="_top">The Project</a></li><li class="section"><a href="#development" target="_top">Development</a></li><li class="section"><a href="#showtime" target="_top">Show time</a></li><li class="section"><a href="#postevent" target="_top">Post Event</a></li><li class="section"><a href="#teamandcredits" target="_top">Team and Credits</a></li><li class="section"><a href="#hardwareselection" target="_top">Hardware selection</a></li></ul></div></li></ul></li></ul>
</nav>
<div class="chapter-content">
<h1 id="threads">threads</h1>
<p><em><a href="http://arturocastro.net" target="_blank">Arturo Castro</a> 작성</em></p>
<p><em>Brannon Dorsey에 의해 수정됨</em></p>
<h2 id="쓰레드란무엇이고언제사용해야하는가">쓰레드란 무엇이고 언제 사용해야 하는가</h2>
<p>Sometimes in an application we need to execute tasks that will take a while to finish. The perfect example is reading something from disk. In the computer the CPU is way faster than accessing the memory which is way faster than accessing the hard disk. So accessing, for example, an image from the HD can take a while compared to the normal flow of the application.</p>
<p>가끔 어플리케이션 내에서는 특정한 작업을 실행하면 끝날떄까지 시간이 걸립니다. 적절한 예를 들자면 디스크에서 뭔가를 읽는 것입니다. 컴퓨터에서는 하드디스크에 접근하는것보다 메모리에 접근하는것이 빠르며, CPU는 훠얼씬 빠릅니다. 접근하는데 있어서 예를들면 하드디스크에서 이미지를 불러오는것은 다른 일반적인 작업에 비교했을때 시간이 훨씬 오래 걸립니다.</p>
<p>In openFrameworks, and in general, usually when working with openGL, our application will run in an infinite loop calling update/draw every cycle of the loop. If we have vertical sync enabled, and our screens works at 60Hz, each of those cycles will last around 16ms (1s/(60frames/s))*1000(ms/s). Loading an image from disk can take way more than those 16ms, so if we try to load an image from our update method, for example, we'll notice a pause in our animation.</p>
<p>일반적으로 오픈프레임웍스에서는, openGL로 작업할 때 대체로 어플리케이션은 update/draw를 반복문의 매 사이클마다 무한대로 호출합니다. 만약 수직동기화를 활성화하면, 화면은 60Hz로 동작하게 되며, 각 사이클은 대략 16ms(1초/(60프레임/초))*1000(ms/s)정도 간격이 됩니다. 이미지를 디스크에서 불러오는것은 16ms보다 더 오래걸리죠, 따라서 한 예로 이미지를 불러오는것을 update메소드에서 시도하게 된다면, 애니메이션이 버벅이는 것을 볼 수 있습니다.</p>
<p>To solve this we usually use threads. Threads are a way of executing certain tasks inside an application outside of the main flow. That way we can run more than one task at once so things that are slow don't stop the main flow of the application. We can also use threads to accelerate tasks by dividing them in several smaller tasks and running each of those at the same time. You can think of a thread as a subprogram inside your program. 이 문제를 해결하기 위해서는 일반적으로 스레드를 사용합니다. 스레드는 어플리케이션 내의 특정한 작업을 main flow의 바깥에서 실행하는 방법입니다. 이 방법을 사용하면 한번에 하나 이상의 작업을 수행하므로 어플리케이션의 main flow를 멈추지 않아 느려지는것을 방지할 수 있습니다. 또한 스레드를 사용하면 작은 작업들로 쪼갠 뒤 동시에 구동시켜 작업을 가속시킬수도 있습니다. 간단히 말해 스레드란 프로그램 하나를 내부의 서브-브로그램으로 생각하시면 됩니다.</p>
<p>Every application has at least 1 thread. In openFrameworks, that thread is where the setup/update/draw loop happens. We'll call this the main (or openGL) thread. But we can create more threads and each of them will run separately from the others.</p>
<p>모든 어플리케이션은 최소 하나의 스레드를 갖습니다. 오픈프레임웍스에서는, 이 스레드에서 setup/update/drar 루프가 발생합니다. 이것을 main(또는 openGL) 스레드라고 합니다. 하지만 더 많은 스레드를 만들고, 각 스레드를 다른 스레드와 별도로 구동시킬 수도 있습니다.</p>
<p>So if we want to load an image in the middle of our application, instead of loading our image in update, we can create a thread that loads the image for us. The problem with this is that once we create a thread, the main thread doesn't know when it has finished, so we need to be able to communicate the results from our auxiliary thread to the main one. There's also problems that might arrise from different threads accessing the same areas in memory. We'll need some mechanisms to synchronize the access to shared memory between 2 or more threads.</p>
<p>따라서 만약 update내에서 이미지를 불러오는 대신, 어플리케이션의 중간에서 이미지를 불러오고 싶다면, 이미지를 불러오는 스레드를하나 만들면 됩니다. 여기서 발생하는 문제는 스레드를 한번 만들면, 메인 스레드는 우리가 만든 스레드가 언제 끝날지 모른다는 점에 있습니다. 따라서 우리의 보조 스레드의 결과가 메인 스레드와 통신할 필요가 있는것이죠. 또다른 문제는 서로 다른 스레드들이 메모리 내의 같은 공간을 접근할 수도 있다는 것입니다. 이를 위해 2개 이상의 스레드들이 공용 메모리에 접근하기 위해 일종의 동기화 매커니즘이 필요합니다.</p>
<p>우선 오픈프레임웍스에서 스레드를 어떻게 만드는지 살펴봅시다.</p>
<h2 id="ofthread">ofThread</h2>
<p>모든 어플리케이션은 최소 하나의 스레드를 갖고 있으며, 이것을 메인 스레드라고 합니다. (openGL를 사용한다면, GL 스레드라고도 불립니다)</p>
<p>하지만 앞서 언급했듯이, 어떤 작업의 경우 메인스레드 내에서 동작할 때 오랜 시간이 걸리는 경우가 있으므로 이를 위해 보조 스레드를 생성할 수 있습니다. 오픈프레임웍스에서는 ofThread 클래스를 사용하여 스레드를 생성할 수 있습니다. ofThread는 직접 사용되는것이 아니고, 이 클래스를 상속받아 보조스레드로부터 호출되어 사용할 <code>threadedFunction</code>를 구현합니다:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> ImageLoader: <span class="kw">public</span> ofThread{
    <span class="dt">void</span> setup(string imagePath){
        <span class="kw">this</span>-&gt;path = imagePath;
    }

    <span class="dt">void</span> threadedFunction(){
        ofLoadImage(image, path);
    }

    ofPixels image;
    string path;
}

<span class="co">//ofApp.h</span>

ImageLoader imgLoader;


<span class="co">// ofApp.cpp</span>
<span class="dt">void</span> ofApp::keyPressed(<span class="dt">int</span> key){
    imgLoader.setup(<span class="st">"someimage.png"</span>);
    imgLoader.startThread();
}</code></pre>
<p>When we call <code>startThread()</code>, <code>ofThread</code> starts a new thread and returns immediately, that thread will call our <code>threadedFunction</code> and will finish when the function ends. <code>startThread()</code>를 호출하면, <code>ofThread</code>는 새 스레드를 시작시켜 즉시 이것을 리턴합니다. 리턴된 스레드는 <code>threadedFucntion</code>을 호출하며, 이 함수가 끝나면 종료됩니다.</p>
<p>This way the loading of the image happens simultaneously to our update/draw loop and our application doesn't stop while waiting till the image is loaded from disk. 이방법으로 이미지를 불러오면 update/draw 루프와 동시에 동작하며 어플리케이션은 이미지를 디스크로부터 불러올떄까지 기다리지 않으므로 멈추지 않습니다.</p>
<p>Now, how do we know when our image is loaded? The thread will run separately from the main thread of our application: 자 여기서, 이미지가 불러와졌는지 어떻게 알수 있을까요? 스레드는 어플리케이션의 메인 스레드와 별도로 분리되어 동작할 것입니다:</p>
<div class="figure"><div class="inner">
<div style="image"><a href="../images/threads/images/simple_thread.png" target="_blank"><img alt="Simple Thread" src="../images/threads/images/simple_thread.png" title="Simple Thread"/></a></div><div class="caption">Simple Thread</div>
</div></div>
<p>As we see in the image the duration of loading of the image and thus the duration of the call to threadedFunction is not automatically known to the main thread. Since all our thread does is load the image, we can check if the thread has finished running which will tell us that the image has loaded. For that ofThread has a method: <code>isThreadRunning()</code>: 위 이미지를 불러오는 동안을 나타내는 그림에서 보시다시피, threadedFunction을 호출하는 것은 메인 스레드에 자동으로 알려지지 않습니다. 우리가 만든 스레드는 이미지를 불러오기만 하므로, 이미지가 불려왔는지를 알려면, 스레드가 작업을 끝냈는지의 여부로 확인할 수 있을것입니다. 이를 위해 ofThread 메소드는 <code>isThreadRunning()</code>메소드를 갖고 있습니다:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> ImageLoader: <span class="kw">public</span> ofThread{
    <span class="dt">void</span> setup(string imagePath){
        <span class="kw">this</span>-&gt;path = imagePath;
    }

    <span class="dt">void</span> threadedFunction(){
        ofLoadImage(image, path);
    }

    ofPixels image;
    string path;
}

<span class="co">//ofApp.h</span>
<span class="dt">bool</span> loading;
ImageLoader imgLoader;
ofImage img;

<span class="co">// ofApp.cpp</span>
<span class="dt">void</span> ofApp::setup(){
    loading = <span class="kw">false</span>;
}

<span class="dt">void</span> ofApp::update(){
    <span class="kw">if</span>(loading==<span class="kw">true</span> &amp;&amp; !imgLoader.isThreadRunning()){
        img.getPixelsRef() = imgLoader.image;
        img.update();
        loading = <span class="kw">false</span>;
    }
}

<span class="dt">void</span> ofApp::draw(){
    <span class="kw">if</span> (img.isAllocated()) {
        img.draw(<span class="dv">0</span>, <span class="dv">0</span>);
    }
}

<span class="dt">void</span> ofApp::keyPressed(<span class="dt">int</span> key){
    <span class="kw">if</span>(!loading){
        imgLoader.setup(<span class="st">"someimage.png"</span>);
        loading = <span class="kw">true</span>;
        imgLoader.startThread();
    }
}</code></pre>
<p>Now as you can see we can only load a new image when the first one has finished loading. What if we want to load more than one? A possible solution would be to start a new thread and ask it if it's been loaded already:</p>
<p>자 보시다시피 첫 스레드의 로드가 끝나면 새 이미지를 불러오는것이 전부입니다. 만약 하나 이상을 불러오고 싶다면? 가능한 방법은 새 스레드를 시작하고 이미 로드가 되었는지를 물어보는 것입니다:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> ImageLoader: <span class="kw">public</span> ofThread{
    ImageLoader(){
        loading = <span class="kw">false</span>;
    }

    <span class="dt">void</span> load(string imagePath){
        <span class="kw">this</span>-&gt;path = imagePath;
        loading = <span class="kw">true</span>;
        startThread();
    }

    <span class="dt">void</span> threadedFunction(){
        ofLoadImage(path,image);
        loaded = <span class="kw">true</span>;
    }

    ofPixels image;
    string path;
    <span class="dt">bool</span> loading;
    <span class="dt">bool</span> loaded;
}

<span class="co">//ofApp.h</span>
vector&lt;unique_ptr&lt;ImageLoader&gt;&gt; imgLoaders;
vector&lt;ofImage&gt; imgs;

<span class="co">// ofApp.cpp</span>
<span class="dt">void</span> ofApp::setup(){
    loading = <span class="kw">false</span>;
}

<span class="dt">void</span> ofApp::update(){
    <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;imgLoaders.size();i++){
        <span class="kw">if</span>(imgLoaders[i]-&gt;loaded){
            <span class="kw">if</span>(imgs.size()&lt;=i) imgs.resize(i<span class="dv">+1</span>);

            imgs[i].getPixelsRef() = imgLoaders[i].image;
            imgs[i].update();
            imgLoaders[i].loaded = <span class="kw">false</span>;
        }
    }
}

<span class="dt">void</span> ofApp::draw(){
    <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;imgLoaders.size();i++){
        imgs[i].draw(x,y);
    }
}

<span class="dt">void</span> ofApp::keyPressed(<span class="dt">int</span> key){
    imgLoaders.push_back(move(unique_ptr&lt;ImageLoader&gt;(<span class="kw">new</span> ImageLoader)));
    imgLoaders.back().load(<span class="st">"someimage.png"</span>);
}</code></pre>
<p>Another possibility would be to use 1 thread only. To do that a possible solution would be to use a queue in our loading thread whenever we want to load a new image. To do this we insert it's path in the queue and when the threadedFunction finishes loading one image it checks the queue. If there's a new image it loads it and it is removed from the queue. 다른 방법은 하나의 스레드만 사용하는 것입니다. 이를 위해 가능한 구현방법이라면 이미지를 불러오는 스레드에 큐를 사용하는 것입니다. 불러올 이미지의 경로를 유ㅔ 삽입하고 threadedFunction 함수가 이미지를 불러오는것을 마치면 큐에 체크하는 것이죠. 만약 불러온 새 이미지가 있다면 큐에서 제거하면 됩니다.</p>
<p>The problem with this is that we will be trying to access the queue from 2 different threads, and as we've mentioned in the memory chapter, when we add or remove elements to a memory structure there's the possibility that the memory will be moved somewhere else. If that happens while one thread is trying to access it we can easily end up with a dangling pointer that will cause the application to crash. Imagine the next sequence of instruction calls from the 2 different threads:</p>
<p>이방법의 문제는 두개의 다른 스레드가 하나의 큐에 접근하려 한다는 것입니다, 그리고 우리가 아미ㅣ 메모리 챕터에서 언급했듯이, 메모리 구조에 추가, 삭제를 할경우 접근할려고 하는 메모리 영역이 다른 곳으로 이동되었을 가능성이 있다는 것입니다. 만일 하나의 스레드가 한 영역에 접근할려고 할 때, 널포인터를 가리키게 되어 어플리케이션이 죽게 됩니다. 아래의 예제에서 두개의 다른 스레드가 다음 수행을 호출하는것을 상상해봅시다:</p>
<pre><code>    loader thread: finished loading an image
    loader thread: pos = get memory address of next element to load
    main thread:   add new element in the queue
    main thread:   queue moves in memory to an area with enough space to allocate it
    loader thread: try to read element in pos  &lt;- crash pos is no longer a valid memory address

    로더 스레드 : 이미지 로드를 마침
    로더 스레드 : pos = 불러올 다음 요소의 주소를 얻음
    메인 스레드 : 새 요소를 큐에 추가
    메인 스레드 : 큐는 새 요소를 위한 공간을 할당하기 위해 메모리 내의 다른 영역으로 이동
    로더 스레드 : pos에서 요소를 읽으려고 시도 &lt;- 유효한 메모리 주소가 아니므로 pos가 죽음(crash)</code></pre>
<p>At this point we might be accessing a memory address that doesn't contain a string anymore, or even trying to access a memory address that is outside of the memory assigned to our application. In this case the OS will kill it sending a segmentation fault signal as we've seen in the memory chapter. 여기서 접근한 메모리 주소에는 문자열값이 더이상 존재하지 않거나, 심지어 어플리케이션에서 할당한 메모리의 바깥영역의 메모리주소를 접근하려 할 수도 있습니다. 이러한 경우 메모리챕터에서 살펴봤듯 운영체제는 segmentation fault 신호를 보내 프로세스를 죽입니다.</p>
<p>The reason this happens is that since thread 1 and 2 run simultaneously we don't know in which order their instructions area going to get executed. We need a way to ensure that thread 1 cannot access the queue while thread 2 is modifying it and viceversa. For that we'll use some kind of lock: In C++ usually a mutex, in openFrameworks an ofMutex. 이러한 상황이 발생하는 이유는 스레드 1과 2가 동시에 실행되어 어떤 순서로 실행이 되는지 알 수 없다는 것입니다. 스레드 2가 큐를 수정하는동안 스레드 1이 큐에 접근할 수 없도록(반대의 경우도 마찬가지) 해야할 필요가 있습니다. 이를 위해 lock이라는 방법을 사용할 것입니다: C++에서는 흔히 mutex라고 하며, 오픈프레임웍스에서는 ofMutex라고 합니다.</p>
<p>But before seeing mutexes, let's see briefly some particulars of using thread while using openGL. mutex에 대해 살펴보기 전에, openGL에서의 일반적인 스레드 사용법에 대해서 간략히 살펴보도록 합시다.</p>
<h2 id="스레드와opengl">스레드와 openGL</h2>
<p>You might have noticed in the previous examples: 앞의 예제에서 이부분을 보셨을 겁니다:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> ImageLoader: <span class="kw">public</span> ofThread{
    ImageLoader(){
        loaded = <span class="kw">false</span>;
    }
    <span class="dt">void</span> setup(string imagePath){
        <span class="kw">this</span>-&gt;path = imagePath;
    }

    <span class="dt">void</span> threadedFunction(){
        ofLoadImage(image, path);
        loaded = <span class="kw">true</span>;
    }

    ofPixels image;
    string path;
    <span class="dt">bool</span> loaded;
}

<span class="co">//ofApp.h</span>
ImageLoader imgLoader;
ofImage img;

<span class="co">// ofApp.cpp</span>
<span class="dt">void</span> ofApp::setup(){
    loading = <span class="kw">false</span>;
}

<span class="dt">void</span> ofApp::update(){
    <span class="kw">if</span>(imgLoader.loaded){
        img.getPixelsRef() = imgLoader.image;
        img.update();
        imgLoader.loaded = <span class="kw">false</span>;
    }
}

<span class="dt">void</span> ofApp::draw(){
    <span class="kw">if</span> (img.isAllocated()) {
        img.draw(<span class="dv">0</span>, <span class="dv">0</span>);
    }
}

<span class="dt">void</span> ofApp::keyPressed(<span class="dt">int</span> key){
    <span class="kw">if</span>(!loading){
        imgLoader.setup(<span class="st">"someimage.png"</span>);
        imgLoader.startThread();
    }
}</code></pre>
<p>Instead of using an ofImage to load images, we are using an ofPixels and then in the main thread we use an ofImage to put the contents of ofPixels into it. This is done because openGL, in principle, can only work with 1 thread. That's why we call our main thread the GL thread. 이미지를 불러오기 위해 ofImage 대신, ofPixels를 사용했고, 그리고 나서 메인 스레드에서 ofImage를 사용해 ofPixels의 콘텐츠를 넣었습니다. 이는 openGL때문에 가능한 것인데요, 이론적으로, 하나의 스레드로만 가능한 작업입니다. 이것이 바로 메인 스레드를 GL 스레드라고 부르는 이유이지요.</p>
<p>As we mentioned in the advanced graphics chapter and other parts of this book, openGL works asynchronously in some kind of client/server model. Our application is the client sending data and drawing instructions to the openGL server which will send them to the graphics card in it's own times. 고급 그래픽스 챕터와 이 책의 다른 파트에서 에서 언급했듯, openGL은 클라이언트/서버 모델과 같이 비동기적으로 동작합니다.어플리케이션은 자신만의 시간내에서 클라이언트로써 데이터와 그리는 방법을 openGL서버에 전송하죠. 즉 그래픽카드로 보내는 것입니다.</p>
<p>Because of that, openGL knows how to work with one thread, the main thread from which the openGL context was created. But if we try to do openGL calls from a different thread we will most surely crash the application, or at least not get the desired results. 이렇기 떄문에, openGL은 하나의 스레드로 작업하는 방법을 압니다. openGL 콘텍스트가 생성했던 메인 스레드 말이죠. 하지만 만일 다른 스레드에서 openGL을 호출하려고 한다면 분명히 어플리케이션이 죽거나, 적어도 원하는 결과를 볼 수 없을것입니다.</p>
<p>When we call <code>img.loadImage(path)</code> on an ofImage, it'll actually do some openGL calls, mainly create a texture and upload to it the contents of the image. If we did that from a thread that isn't the GL thread, our application will probably crash or just don't load the texture properly.</p>
<p>우리가 ofImage에서 <code>img.loadImage(path)</code>를 호출할 때, 이는 사실 openGL호출을 하는것입니다. 텍스쳐를 생성하고 이미지의 콘텐츠를 그곳에 업로드 하는 것이죠. 만일 우리가 GL 스레드가 아닌 스레드로 호출하면, 어플리케이션이 죽거나 혹은 텍스쳐를 올바르게 로드하지 못할것입니다.</p>
<p>There's a way to tell ofImage, and most other objects that contain pixels and textures in openFrameworks, to not use those textures and instead work only with pixels. That way we could use an ofImage to load the images to pixels and later in the main thread activate the textures to be able to draw the images: 오픈프레임웍스의 다른 대부분의 오브젝트들은 픽셀과 텍스쳐를 포함하고 있으므로, 이러한 텍스쳐를 사용하지 못하게 하고 대신에 픽셀과만 작업하도록 ofImage에게 시킬 수 있습니다. 이 방법으로 ofImage에게 pixels</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> ImageLoader: <span class="kw">public</span> ofThread{
    ImageLoader(){
        loaded = <span class="kw">false</span>;
    }
    <span class="dt">void</span> setup(string imagePath){
        image.setUseTexture(<span class="kw">false</span>);
        <span class="kw">this</span>-&gt;path = imagePath;
    }

    <span class="dt">void</span> threadedFunction(){
        image.loadImage(path);
        loaded = <span class="kw">true</span>;
    }

    ofImage image;
    string path;
    <span class="dt">bool</span> loaded;
}

<span class="co">//ofApp.h</span>
ImageLoader imgLoader;

<span class="co">// ofApp.cpp</span>
<span class="dt">void</span> ofApp::setup(){
    loading = <span class="kw">false</span>;
}

<span class="dt">void</span> ofApp::update(){
    <span class="kw">if</span>(imgLoader.loaded){
        imgLoader.image.setUseTexture(<span class="kw">true</span>);
        imgLoader.image.update();
        imgLoader.loaded = <span class="kw">false</span>;
    }
}

<span class="dt">void</span> ofApp::draw(){
    <span class="kw">if</span> (imgLoader.image.isAllocated()){
        imgLoader.image.draw(<span class="dv">0</span>,<span class="dv">0</span>);
    }
}

<span class="dt">void</span> ofApp::keyPressed(<span class="dt">int</span> key){
    <span class="kw">if</span>(!loading){
        imgLoader.setup(<span class="st">"someimage.png"</span>);
        imgLoader.startThread();
    }
}</code></pre>
<p>There are ways to use openGL from different threads, for example creating a shared context to upload textures in a different thread or using PBO's to map a memory area and later upload to that memory area from a different thread but that's out of the scope of this chapter. In general remember that accessing openGL outside of the GL thread is not safe. In openFrameworks you should only do operations that involve openGL calls from the main thread, that is, from the calls that happen in the setup/update/draw loop, the key and mouse events, and the related ofEvents. If you start a thread and call a function or notify an ofEvent from it, that call will also happen in the auxiliary thread, so be careful to not do any GL calls from there.</p>
<p>A very specific case is sound, sound APIs in openFrameworks, in particular ofSoundStream, create their own threads since sound's timing needs to be super precise. So when working with ofSoundStream be careful not to use any openGL calls and in general apply the same logic as if you where inside the threadedFunction of an ofThread. We'll see more about this in the next sections.</p>
<h2 id="ofmutex">ofMutex</h2>
<p>Before we started the openGL and threads section we were talking about how accessing the same memory area from 2 different threads can cause problems. This mostly occurs if we write from one of the threads causing the data structure to move in memory or make a location invalid. "스레드와 openGL" 전의 섹션에서 서로다른 두 스레드가 같은 메모리영역에 접근했을 때 발생하는 문제에 대해서 살펴봤습니다. 이는 대부분 둘중 한 스레드가 메모리영역을 이동시켜 다른 스레드가 비유효 영역을 접근하기 떄문입니다.</p>
<p>To avoid that we need something that allows to access that data to only one thread simultaneously. For that we use something called mutex. When one thread want's to access the shared data, it locks the mutex and when a mutex is locked any other thread trying to lock it will get blocked there until the mutex is unlocked again. You can think of this as some kind of token that each thread needs to have to be able to access the shared memory.</p>
<p>이를 피하기 위해 스레드가 동시에 동작할 떄 단 하나의 스레드만 데이터에 접근할 수 있도록 해야합니다. 이를 위해 mutex라 불리우는 것을 사용할 것입니다. 한 스레드가 공용 데이터에 접근하지 않을 때, mutex를 clock</p>
<p>Imagine you are with a group of people building a tower of cards, if more than one at the same time tries to put cards on it it's very possible that it'll collapse so to avoid that, anyone who wants to put a card on the tower, needs to have a small stone, that stone gives them permission to add cards to the tower and there's only one, so if someone wants to add cards they need to get the stone but if someone else has the stone then they have to wait till the stone is freed. If more than one wants to add cards and the stone is not free they queue, the first one in the queue gets the stone when it's finally freed.</p>
<p>A mutex is something like that, to <em>get the stone</em> you call lock on the mutex, once you are done, you call unlock. If some other thread calls lock while another thread is holding it, they are put in to a queue, the first thread that called lock will get the mutex when it's finally unlocked:</p>
<pre><code>    thread 1: lock mutex
    thread 1: pos = access memory to get position to write
    thread 2: lock mutex &lt;- now thread 2 will stop it's execution till thread 1 unlocks it so better be quick
    thread 1: write to pos
    thread 1: unlock mutex
    thread 2: read memory
    thread 2: unlock mutex</code></pre>
<p>When we lock a mutex from one thread and another thread tries to lock it, that stops it's execution. For this reason we should try to do only fast operations while we have the mutex locked in order to not lock the execution of the main thread for too long.</p>
<p>In openFrameworks, the ofMutex class allows us to do this kind of locking. The syntax for the previous sequence would be something like:</p>
<pre><code>    thread 1: mutex.lock();
    thread 1: vec.push_back(something);
    thread 2: mutex.lock(); // now thread 2 will stop it's execution until thread 1 unlocks it so better be quick
    thread 1: // end of push_back()
    thread 1: mutex.unlock();
    thread 2: somevariable = vec[i];
    thread 2: mutex.unlock();</code></pre>
<p>We just need to call <code>lock()</code> and <code>unlock()</code> on our ofMutex from the different threads, from <code>threadedFunction</code> and from the update/draw loop when we want to access a piece of shared memory. ofThread actually contains an ofMutex that can be locked using lock()/unlock(), we can use it like:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> NumberGenerator{
<span class="kw">public</span>:
    <span class="dt">void</span> threadedFunction(){
        <span class="kw">while</span> (isThreadRunning()){
            lock();
            numbers.push_back(ofRandom(<span class="dv">0</span>,<span class="dv">1000</span>));
            unlock();
            ofSleepMillis(<span class="dv">1000</span>);
        }
    }

    vector&lt;<span class="dt">int</span>&gt; numbers;
}

<span class="co">// ofApp.h</span>

NumberGenerator numberGenerator;

<span class="co">// ofApp.cpp</span>

<span class="dt">void</span> ofApp::setup(){
    numberGenerator.startThread();
}

<span class="dt">void</span> ofApp::update(){
    numberGenerator.lock();
    <span class="kw">while</span>(!numberGenerator.numbers.empty()){
        cout &lt;&lt; numberGenerator.numbers.front() &lt;&lt; endl;
        numberGenerator.numbers.pop_front();
    }
    numberGenerator.unlock();
}</code></pre>
<p>As we've said before, when we lock a mutex we stop other threads from accessing it. It is important that we try to keep the lock time as small as possible or else we'll end up stopping the main thread anyway making the use of threads pointless.</p>
<h2 id="externalthreadsanddoublebuffering">External threads and double buffering</h2>
<p>Sometimes we don't have a thread that we've created ourselves, but instead we are using a library that creates it's own thread and calls our application on a callback. Let's see an example with an imaginary video library that calls some function whenever there's a new frame from the camera, that kind of function is called a callback because some library <em>calls us back</em> when something happens, the key and mouse events functions in OF are examples of callbacks.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> VideoRenderer{
<span class="kw">public</span>:
    <span class="dt">void</span> setup(){
        pixels.allocate(<span class="dv">640</span>,<span class="dv">480</span>,<span class="dv">3</span>);
        texture.allocate(<span class="dv">640</span>,<span class="dv">480</span>,GL_RGB);
        videoLibrary::setCallback(<span class="kw">this</span>, &amp;VideoRenderer::frameCB);
        videoLibrary::startCapture(<span class="dv">640</span>,<span class="dv">480</span>,<span class="st">"RGB"</span>);
    }

    <span class="dt">void</span> update(){
        <span class="kw">if</span>(newFrame){
            texture.loadData(pixels);
            newFrame = <span class="kw">false</span>;
        }
    }

    <span class="dt">void</span> draw(<span class="dt">float</span> x, <span class="dt">float</span> y){
        texture.draw(x,y);
    }

    <span class="dt">void</span> frameCB(<span class="dt">unsigned</span> <span class="dt">char</span> * frame, <span class="dt">int</span> w, <span class="dt">int</span> h){
        pixels.setFromPixels(frame,w,h,<span class="dv">3</span>);
        newFrame = <span class="kw">true</span>;
    }

    ofPixels pixels;
    <span class="dt">bool</span> newFrame;
    ofTexture texture;
}</code></pre>
<p>Here, even if we don't use a mutex, our application won't crash. That is because the memory in pixels is preallocated in setup and it's size never changes. For this reason the memory won't move from it's original location. The problem is that both the update and frame_cb functions might be running at the same time so we will probably end up seeing <a href="http://en.wikipedia.org/wiki/Screen_tearing" target="_blank">tearing</a>. Tearing is the same kind of effect we can see when we draw to the screen without activating the vertical sync.</p>
<p>To avoid tearing we might want to use a mutex:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> VideoRenderer{
<span class="kw">public</span>:
    <span class="dt">void</span> setup(){
        pixels.allocate(<span class="dv">640</span>,<span class="dv">480</span>,<span class="dv">3</span>);
        texture.allocate(<span class="dv">640</span>,<span class="dv">480</span>,GL_RGB);
        videoLibrary::setCallback(<span class="kw">this</span>, &amp;VideoRenderer::frameCB);
        videoLibrary::startCapture(<span class="dv">640</span>,<span class="dv">480</span>,<span class="st">"RGB"</span>);
    }

    <span class="dt">void</span> update(){
        mutex.lock();
        <span class="kw">if</span>(newFrame){
            texture.loadData(pixels);
            newFrame = <span class="kw">false</span>;
        }
        mutex.unlock();
    }

    <span class="dt">void</span> draw(<span class="dt">float</span> x, <span class="dt">float</span> y){
        texture.draw(x,y);
    }

    <span class="dt">void</span> frameCB(<span class="dt">unsigned</span> <span class="dt">char</span> * frame, <span class="dt">int</span> w, <span class="dt">int</span> h){
        mutex.lock();
        pixels.setFromPixels(frame,w,h,<span class="dv">3</span>);
        newFrame = <span class="kw">true</span>;
        mutex.unlock();
    }

    ofPixels pixels;
    <span class="dt">bool</span> newFrame;
    ofTexture texture;
    ofMutex mutex;
}</code></pre>
<p>That will solve the tearing, but we are stopping the main thread while the <code>frameCB</code> is updating the pixels and stopping the camera thread while the main one is uploading the texture. For small images this is usually ok, but for bigger images we could loose some frames. A possible solution is to use a technique called double or even triple buffering:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> VideoRenderer{
<span class="kw">public</span>:
    <span class="dt">void</span> setup(){
        pixelsBack.allocate(<span class="dv">640</span>,<span class="dv">480</span>,<span class="dv">3</span>);
        pixelsFront.allocate(<span class="dv">640</span>,<span class="dv">480</span>,<span class="dv">3</span>);
        texture.allocate(<span class="dv">640</span>,<span class="dv">480</span>,GL_RGB);
        videoLibrary::setCallback(<span class="kw">this</span>, &amp;VideoRenderer::frameCB);
        videoLibrary::startCapture(<span class="dv">640</span>,<span class="dv">480</span>,<span class="st">"RGB"</span>);
    }

    <span class="dt">void</span> update(){
        <span class="dt">bool</span> wasNewFrame = <span class="kw">false</span>;
        mutex.lock();
        <span class="kw">if</span>(newFrame){
            swap(pixelsFront,pixelsBack);
            newFrame = <span class="kw">false</span>;
            wasNewFrame = <span class="kw">true</span>;
        }
        mutex.unlock();

        <span class="kw">if</span>(wasNewFrame) texture.loadData(pixelsFront);
    }

    <span class="dt">void</span> draw(<span class="dt">float</span> x, <span class="dt">float</span> y){
        texture.draw(x,y);
    }

    <span class="dt">void</span> frameCB(<span class="dt">unsigned</span> <span class="dt">char</span> * frame, <span class="dt">int</span> w, <span class="dt">int</span> h){
        pixelsBack.setFromPixels(frame,w,h,<span class="dv">3</span>);
        mutex.lock();
        newFrame = <span class="kw">true</span>;
        mutex.unlock();
    }

    ofPixels pixelsFront, pixelsBack;
    <span class="dt">bool</span> newFrame;
    ofTexture texture;
    ofMutex mutex;
}</code></pre>
<p>With this we are locking the mutex for a very short time in the frame callback to set <code>newFrame = true</code> in the main thread. We do this to check if there's a new frame and then to swap the front and back buffers. <code>swap</code> is a c++ standard library function that swaps 2 memory areas so if we swap 2 ints <code>a</code> and <code>b</code>, <code>a</code> will end up having the value of <code>b</code> and viceversa, usually this happens by copying the variables but <code>swap</code> is overridden for ofPixels and swaps the internal pointers to memory inside <code>frontPixels</code> and <code>backPixels</code> to point to one another. After calling <code>swap</code>, <code>frontPixels</code> will be pointing to what <code>backPixels</code> was pointing to before, and viceversa. This operation only involves copying the values of a couple of memory addresses plus the size and number of channels. For this reason it's way faster than copying the whole image or uploading to a texture.</p>
<p>Triple buffering is a similar technique that involves using 3 buffers instead of 2 and is useful in some cases. We won't see it in this chapter.</p>
<h2 id="ofscopedlock">ofScopedLock</h2>
<p>Sometimes we need to lock a function until it returns, or lock for the duration of a full block. That is exactly what a scoped lock does. If you've read the memory chapter you probably remember about what we called initially, <em>stack semantics</em>, or RAII <a href="http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization" target="_blank">Resource Adquisition Is Initialization</a>. A scoped lock makes use of that technique to lock a mutex for the whole duration of the block, even any copy that might happen in the same <code>return</code> call if there's one.</p>
<p>For example, the previous example could be turned into:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> VideoRenderer{
<span class="kw">public</span>:
    <span class="dt">void</span> setup(){
        pixelsBack.allocate(<span class="dv">640</span>,<span class="dv">480</span>,<span class="dv">3</span>);
        pixelsFront.allocate(<span class="dv">640</span>,<span class="dv">480</span>,<span class="dv">3</span>);
        texture.allocate(<span class="dv">640</span>,<span class="dv">480</span>,GL_RGB);
        videoLibrary::setCallback(&amp;frame_cb);
        videoLibrary::startCapture(<span class="dv">640</span>,<span class="dv">480</span>,<span class="st">"RGB"</span>);
    }

    <span class="dt">void</span> update(){
        <span class="dt">bool</span> wasNewFrame = <span class="kw">false</span>;

        {
        ofScopedLock lock(mutex);
            <span class="kw">if</span>(newFrame){
                swap(fontPixels,backPixels);
                newFrame = <span class="kw">false</span>;
                wasNewFrame = <span class="kw">true</span>;
            }
        }

        <span class="kw">if</span>(wasNewFrame) texture.loadData(pixels);
    }

    <span class="dt">void</span> draw(<span class="dt">float</span> x, <span class="dt">float</span> y){
        texture.draw(x,y);
    }

    <span class="dt">static</span> <span class="dt">void</span> frame_cb(<span class="dt">unsigned</span> <span class="dt">char</span> * frame, <span class="dt">int</span> w, <span class="dt">int</span> h){
        pixelsBack.setFromPixels(frame,w,h,<span class="dv">3</span>);
        ofScopedLock lock(mutex);
        newFrame = <span class="kw">true</span>;
    }

    ofPixels pixels;
    <span class="dt">bool</span> newFrame;
    ofTexture texture;
    ofMutex mutex;
}</code></pre>
<p>A ScopedLock is a good way of avoiding problems because we forgot to unlock a mutex and allows us to use the <code>{}</code> to define the duration of the lock which is more natural to C++.</p>
<p>There's one particular case when the only way to properly lock is by using a scoped lock. That's when we want to return a value and keep the function locked until after the value was returned. In that case we can't use a normal lock:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">
ofPixels accessSomeSharedData(){
    ofScopedLock lock(mutex);
    <span class="kw">return</span> modifiedPixels(pixels);
}</code></pre>
<p>We could make a copy internally and return that later, but with this pattern we avoid a copy and the syntax is shorter.</p>
<h2 id="pococondition">Poco::Condition</h2>
<p>A condition, in threads terminology, is an object that allows to synchronize 2 threads. The pattern is something like this: one thread waits for something to happen before starting it's processing. When it finishes, instead of finishing the thread, it locks in the condition and waits till there's new data to process. An example of this could be the image loader class we were working with earlier. Instead of starting one thread for every image, we might have a queue of images to load. The main thread adds image paths to that queue and the auxiliary thread loads the images from that queue until it is empty. The auxiliary thread then locks on a condition until there's more images to load.</p>
<p>Such an example would be too long to write in this section, but if you are interested in how something like that might work, take a look at ofxThreadedImageLoaded (which does just that).</p>
<p>Instead let's see a simple example. Imagine a class where we can push urls to pings addresses in a different thread. Something like:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> ThreadedHTTPPing: <span class="kw">public</span> ofThread{
<span class="kw">public</span>:
    <span class="dt">void</span> pingServer(string url){
        mutex.lock();
        queueUrls.push(url);
        mutex.unlock();
    }

    <span class="dt">void</span> threadedFunction(){
        <span class="kw">while</span>(isThreadRunning()){
            mutex.lock();
            string url;
            <span class="kw">if</span>(queueUrls.empty()){
                url = queueUrls.front();
                queueUrls.pop();
            }
            mutex.unlock();
            <span class="kw">if</span>(url != <span class="st">""</span>){
                ofHttpUrlLoad(url);
            }
        }
    }

<span class="kw">private</span>:
    queue&lt;string&gt; queueUrls;
}</code></pre>
<p>The problem with that example is that the auxiliary thread keeps running as fast as possible in a loop, consuming a whole CPU core from our computer which is not a very good idea.</p>
<p>A typical solution to this problem is to sleep for a while at the end of each cycle like:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> ThreadedHTTPPing: <span class="kw">public</span> ofThread{
<span class="kw">public</span>:
    <span class="dt">void</span> pingServer(string url){
        mutex.lock();
        queueUrls.push(url);
        mutex.unlock();
    }

    <span class="dt">void</span> threadedFunction(){
        <span class="kw">while</span>(isThreadRunning()){
            mutex.lock();
            string url;
            <span class="kw">if</span>(queueUrls.empty()){
                url = queueUrls.front();
                queueUrls.pop();
            }
            mutex.unlock();
            <span class="kw">if</span>(url != <span class="st">""</span>){
                ofHttpUrlLoad(url);
            }
            ofSleepMillis(<span class="dv">100</span>);
        }
    }

<span class="kw">private</span>:
    queue&lt;string&gt; queueUrls;
};</code></pre>
<p>That alleviates the problem slightly but not completely. The thread won't consume as much CPU now, but it sleeps for an unnecesarily while when there's still urls to load. It also continues to run in the background even when there's no more urls to ping. Specially in small devices powered by batteries, like a phone, this pattern would drain the battery in a few hours.</p>
<p>The best solution to this problem is to use a condition:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> ThreadedHTTPPing: <span class="kw">public</span> ofThread{
    <span class="dt">void</span> pingServer(string url){
        mutex.lock();
        queueUrls.push(url);
        condition.signal();
        mutex.unlock();
    }

    <span class="dt">void</span> threadedFunction(){
        <span class="kw">while</span>(isThreadRunning()){
            mutex.lock();
            <span class="kw">if</span> (queueUrls.empty()){
                condition.wait(mutex);
            }
            string url = queueUrls.front();
            queueUrls.pop();
            mutex.unlock();

            ofHttpUrlLoad(url);
        }
    }

<span class="kw">private</span>:
    Poco::Condition condition;
    queue&lt;string&gt; queueUrls;
};</code></pre>
<p>Before we call <code>condition.wait(mutex)</code> the mutex needs to be locked, then the condition unlocks the mutex and blocks the execution of that thread until <code>condition.signal()</code> is called. When the condition awakens the thread because it's been signaled, it locks the mutex again and continues the execution. We can read the queue without problem because we know that the other thread won't be able to access it. We copy the next url to ping and unlock the mutex to keep the lock time to a minimum. Then outside the lock we ping the server and start the process again.</p>
<p>Whenever the queue gets emptied the condition will block the execution of the thread to avoid it from running in the background.</p>
<h2 id="conclusion">Conclusion</h2>
<p>As we've seen threads are a powerfull tool to allow for several tasks to happen simultaneously in the same application. They are also hard to use, the main problem is usually accessing shared resouces, usually shared memory. We've only seen one specific case, how to use threads to do background tasks that will pause the execution of the main task, there's other cases where we can parallelize 1 task by dividing it in small subtasks like for example doing some image operation by dividing the image in for subregions and assigning a thread to each. For those cases there's special libraries that make the syntax easier, OpenCv for example can do some operations using more than one core through <a href="https://www.threadingbuildingblocks.org/" target="_blank">TBB</a> and there's libraries like the same TBB or <a href="http://openmp.org/wp/" target="_blank">OpenMP</a> that allow to specify that a loop should be divided and run simultaneol¡usly in more than one core</p>
<div class="footer">
<div id="prev_chapter"><a href="shaders.html">&lt; Introducing Shaders</a></div>
<div id="next_chapter"><a href="memory.html">memory of C++ &gt;</a></div>
</div>
<div id="help"><i>이 책은 현재 번역작업중이므로, 오탈자나 여러 오류가 있을 수 있습니다. 원본 영문의 내용도 활발히 수정중임 또한 감안해주시기 바랍니다. 오류 발견시 <a href="https://github.com/openframeworks/ofbook" target="_blank">이곳</a>에 글을 남겨주시기 바라며, 한글 번역에 관한 내용은 <a href="http://forum.openframeworks.kr/" target="_blank">오픈프레임웍스한글포럼</a>에의견을 남겨주시기 바랍니다.</i></div>
</div>
</div>
</body>
</html>
