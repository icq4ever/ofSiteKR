<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<meta content="text/css" http-equiv="Content-Style-Type"/>
<meta content="pandoc" name="generator"/>
<title>ofBook - Basics of Generating Meshes from an Image</title>
<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
  </style>
<link href="../style/bootstrap.min.css" rel="stylesheet">
<link href="../style/style.css" rel="stylesheet" type="text/css"/>
<link href="http://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic,700italic|Merriweather:400,300,300italic,400italic,700,900,700italic,900italic" rel="stylesheet" type="text/css">
<script src="../javascript/jquery-1.8.3.min.js"></script>
<script src="../javascript/bootstrap.min.js"></script>
<script src="../javascript/navbar.js"></script>
</link></link></head>
<body>
<div class="banner">
<div class="content-wrapper">
<b>현재 작업중인 내용이므로 완성본이 아닙니다!</b>
        보고 계신 내용은 오픈프레임웍스에 관해 여러사람들이 협업하여 작업/번역중인 임시적인 버전의 ofBook입니다. 이슈, 제안, 코멘트등은 <a href="https://github.com/openframeworks/ofBook/" target="_blank">repo</a>로 알려주시고, 번역에 관련된 경우 <a href="http://forum.openframeworks.kr/" target="_blank">오픈프레임웍스 한글 포럼</a>에 글을 남겨주시기 바랍니다.
    </div>
</div>
<div class="content-wrapper">
<nav role="navigation">
<ul id="nav-parts"><li class="group"><div class="groupTitle">Foreword</div><ul><li class="chapter"><div class="chapterTitle"><a href="foreword.html">foreword</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#책에관하여" target="_top">책에 관하여</a></li><li class="section"><a href="#credits" target="_top">Credits</a></li></ul></div></li></ul></li><li class="group"><div class="groupTitle">Basics</div><ul><li class="chapter"><div class="chapterTitle"><a href="of_philosophy.html">Philosophy</a></div></li></ul><ul><li class="chapter"><div class="chapterTitle"><a href="cplusplus_basics.html">C++ Language Basics</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#lookalive" target="_top">Look Alive!</a></li><li class="section"><a href="#iteration" target="_top">Iteration</a></li><li class="section"><a href="#compilingmyfirstapp" target="_top">Compiling My First App</a></li><li class="section"><a href="#beyondhelloworld" target="_top">Beyond Hello World</a></li><li class="section"><a href="#functions" target="_top">Functions</a></li><li class="section"><a href="#customfunctions" target="_top">Custom Functions</a></li><li class="section"><a href="#encapsulationofcomplexity" target="_top">Encapsulation of Complexity</a></li><li class="section"><a href="#variablespart1" target="_top">Variables (part 1)</a></li><li class="section"><a href="#conclusion" target="_top">Conclusion</a></li><li class="section"><a href="#ps" target="_top">PS.</a></li></ul></div></li></ul><ul><li class="chapter"><div class="chapterTitle"><a href="setup_and_project_structure.html">oF structure</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#firstthingsfirst" target="_top">First things first</a></li><li class="section"><a href="#welcometoyournewkitchen" target="_top">Welcome to your new kitchen</a></li><li class="section"><a href="#runningexamples" target="_top">Running examples</a></li><li class="section"><a href="#offolderstructure" target="_top">oF folder structure</a></li><li class="section"><a href="#theofpantry" target="_top">The oF Pantry</a></li></ul></div></li></ul><ul><li class="chapter"><div class="chapterTitle"><a href="intro_to_graphics.html">Graphics</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#brusheswithbasicshapes" target="_top">Brushes with Basic Shapes</a></li><li class="section"><a href="#brushesfromfreeformshapes" target="_top">Brushes from Freeform Shapes</a></li><li class="section"><a href="#movingtheworld" target="_top">Moving The World</a></li><li class="section"><a href="#nextsteps" target="_top">Next Steps</a></li></ul></div></li></ul><ul><li class="chapter"><div class="chapterTitle"><a href="OOPs!.html">Ooops! = Object Oriented Programming + Classes</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#overview" target="_top">Overview</a></li><li class="section"><a href="#whatisobjectorientedprogramming" target="_top">What is Object Oriented Programming</a></li><li class="section"><a href="#howtobuildyourownclassessimpleclass" target="_top">How to build your own Classes (simple Class)</a></li><li class="section"><a href="#makeanobjectfromyourclass" target="_top">Make an Object from your Class</a></li><li class="section"><a href="#makeobjectsfromyourclass" target="_top">Make objects from your Class</a></li><li class="section"><a href="#makemoreobjectsfromyourclass" target="_top">Make more Objects from your Class</a></li><li class="section"><a href="#makeevenmoreobjectsfromyourclasspropertiesandconstructors" target="_top">Make even more Objects from your Class: properties and constructors</a></li><li class="section"><a href="#makeobjectsonthefly" target="_top">Make Objects on the fly</a></li><li class="section"><a href="#makinganddeleteasyouwishusingvectors" target="_top">Making and delete as you wish - using vectors</a></li><li class="section"><a href="#quickintrotopolymorphisminheritance" target="_top">Quick intro to polymorphism (inheritance)</a></li></ul></div></li></ul><ul><li class="chapter"><div class="chapterTitle"><a href="how_of_works.html">how OF works</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#오픈프레임웍스코드의일반적인패턴설명" target="_top">오픈프레임웍스 코드의 일반적인 패턴 설명</a></li><li class="section"><a href="#setupupdatedraw" target="_top">setup, update, draw</a></li><li class="section"><a href="#클래스" target="_top">클래스</a></li><li class="section"><a href="#함수" target="_top">함수</a></li></ul></div></li></ul></li><li class="group"><div class="groupTitle">Approaches</div><ul><li class="chapter"><div class="chapterTitle"><a href="animation.html">Animation</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#background" target="_top">Background</a></li><li class="section"><a href="#animationinofusefulconcepts" target="_top">Animation in oF / useful concepts:</a></li><li class="section"><a href="#linearmovement" target="_top">Linear movement</a></li><li class="section"><a href="#functionbasedmovement" target="_top">Function based movement</a></li><li class="section"><a href="#simulation" target="_top">Simulation</a></li><li class="section"><a href="#wheretogofurther" target="_top">Where to go further</a></li></ul></div></li></ul><ul><li class="chapter"><div class="chapterTitle"><a href="game_design.html">Experimental Game Development</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#howdogamedevelopersactuallymakegames" target="_top">How do game developers actually make games?</a></li><li class="section"><a href="#sowhatisoscanyway" target="_top">So what is OSC, anyway?</a></li><li class="section"><a href="#ourbasicgameandmakingitnotsobasic" target="_top">Our basic game–and making it not so basic</a></li></ul></div></li></ul><ul><li class="chapter"><div class="chapterTitle"><a href="image_processing_computer_vision.html">image processing and computer vision</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#maybethereisamagicbullet" target="_top">Maybe There is a Magic Bullet</a></li><li class="section"><a href="#preliminariestoimageprocessing" target="_top">Preliminaries to Image Processing</a></li><li class="section"><a href="#이미지처리를얘기하기전에알아두어야할것들" target="_top">이미지처리를 얘기하기 전에 알아두어야 할것들</a></li><li class="section"><a href="#pointprocessingoperationsonimages" target="_top">Point Processing Operations on Images</a></li><li class="section"><a href="#acompleteworkflowbackgroundsubtraction" target="_top">A Complete Workflow: Background Subtraction</a></li><li class="section"><a href="#refinements" target="_top">Refinements</a></li><li class="section"><a href="#suggestionsforfurtherexperimentation" target="_top">Suggestions for Further Experimentation</a></li></ul></div></li></ul></li><li class="group"><div class="groupTitle">I/O</div><ul><li class="chapter"><div class="chapterTitle"><a href="hardware.html">Hardware</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#introduction" target="_top">introduction</a></li><li class="section"><a href="#소개" target="_top">소개</a></li><li class="section"><a href="#gettingstartedwithserialcommunication" target="_top">getting started with serial communication</a></li><li class="section"><a href="#시리얼통신시작하기" target="_top">시리얼 통신 시작 하기</a></li><li class="section"><a href="#digitalandanalogcommunication" target="_top">digital and analog communication</a></li><li class="section"><a href="#디지털과아날로그통신" target="_top">디지털과 아날로그 통신</a></li><li class="section"><a href="#usingserialforcommunicationbetweenarduinoandopenframeworks" target="_top">using serial for communication between arduino and openframeworks</a></li><li class="section"><a href="#lightsoncontrollinghardwareviadmx" target="_top">Lights On - controlling hardware via DMX</a></li></ul></div></li></ul><ul><li class="chapter"><div class="chapterTitle"><a href="sound.html">Sound</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#gettingstartedwithsoundfiles" target="_top">Getting Started With Sound Files</a></li><li class="section"><a href="#gettingstartedwiththesoundstream" target="_top">Getting Started With the Sound Stream</a></li><li class="section"><a href="#why1to1" target="_top">Why -1 to 1?</a></li><li class="section"><a href="#timedomainvsfrequencydomain" target="_top">Time Domain vs Frequency Domain</a></li><li class="section"><a href="#reactingtoliveaudio" target="_top">Reacting to Live Audio</a></li><li class="section"><a href="#synthesizingaudio" target="_top">Synthesizing Audio</a></li><li class="section"><a href="#audiogotchas" target="_top">Audio Gotchas</a></li></ul></div></li></ul><ul><li class="chapter"><div class="chapterTitle"><a href="network.html">Network</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#tcpvsudp" target="_top">TCP vs UDP</a></li><li class="section"><a href="#osc" target="_top">OSC</a></li></ul></div></li></ul></li><li class="group selected"><div class="groupTitle">Graphics</div><ul><li class="chapter"><div class="chapterTitle"><a href="openGL.html">Introducing OpenGL for OF</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#introducing" target="_top">Introducing</a></li><li class="section"><a href="#vertices" target="_top">Vertices</a></li><li class="section"><a href="#meshes" target="_top">Meshes</a></li><li class="section"><a href="#vbos" target="_top">VBOs</a></li><li class="section"><a href="#abasic3dscene" target="_top">A Basic 3D Scene</a></li><li class="section"><a href="#matrices" target="_top">Matrices</a></li><li class="section"><a href="#textures" target="_top">Textures</a></li><li class="section"><a href="#cameras" target="_top">Cameras</a></li></ul></div></li></ul><ul><li class="chapter"><div class="chapterTitle"><a href="lines.html">drawing lines</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#소개" target="_top">소개 ...</a></li><li class="section"><a href="#선그리기" target="_top">선 그리기</a></li><li class="section"><a href="#약간의노이즈abitofnoise" target="_top">약간의 노이즈A bit of noise</a></li><li class="section"><a href="#aweboflines" target="_top">A web of lines</a></li><li class="section"><a href="#makeasmoothlineinmovementina3dspace" target="_top">Make a smooth line in movement in a 3D space</a></li></ul></div></li></ul><ul><li class="chapter selected"><div class="chapterTitle selected"><a href="generativemesh.html">Basics of Generating Meshes from an Image</a></div><div class="chapterContents selected"><ul><li class="section selected"><a href="#basicsofgeneratingmeshesfromanimage1" target="_top">Basics of Generating Meshes from an Image</a></li><li class="section"><a href="#basicsworkingwithofmesh" target="_top">Basics: Working with ofMesh</a></li><li class="section"><a href="#generativemeshusinganimagetodrivethecreationofamesh" target="_top">Generative Mesh: Using an image to drive the creation of a mesh</a></li><li class="section"><a href="#manipulationsaddingeffectsthatmodifythemesh" target="_top">Manipulations: Adding effects that modify the mesh</a></li><li class="section"><a href="#nextsteps" target="_top">Next Steps</a></li></ul></div></li></ul><ul><li class="chapter"><div class="chapterTitle"><a href="advanced_graphics.html">Advanced graphics</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#dimmediatemodevsofpolylineofpath" target="_top">2D, immediate mode vs ofPolyline/ofPath</a></li><li class="section"><a href="#d" target="_top">3D</a></li></ul></div></li></ul><ul><li class="chapter"><div class="chapterTitle"><a href="shaders.html">Introducing Shaders</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#introducing" target="_top">introducing</a></li><li class="section"><a href="#yourfirstshader" target="_top">Your first shader!</a></li><li class="section"><a href="#addinguniforms" target="_top">Adding Uniforms</a></li><li class="section"><a href="#addingsomeinteractivity" target="_top">Adding some interactivity</a></li><li class="section"><a href="#addingtextures" target="_top">Adding Textures</a></li><li class="section"><a href="#alphamasking" target="_top">Alpha Masking</a></li><li class="section"><a href="#multipletextures" target="_top">Multiple Textures</a></li><li class="section"><a href="#offbo" target="_top">ofFbo</a></li><li class="section"><a href="#texturesasdataegdisplacement" target="_top">Textures as Data (e.g. Displacement)</a></li><li class="section"><a href="#theendcongrats" target="_top">The End, Congrats!</a></li></ul></div></li></ul></li><li class="group"><div class="groupTitle">C++</div><ul><li class="chapter"><div class="chapterTitle"><a href="threads.html">threads</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#쓰레드란무엇이고언제사용해야하는가" target="_top">쓰레드란 무엇이고 언제 사용해야 하는가</a></li><li class="section"><a href="#ofthread" target="_top">ofThread</a></li><li class="section"><a href="#스레드와opengl" target="_top">스레드와 openGL</a></li><li class="section"><a href="#ofmutex" target="_top">ofMutex</a></li><li class="section"><a href="#externalthreadsanddoublebuffering" target="_top">External threads and double buffering</a></li><li class="section"><a href="#ofscopedlock" target="_top">ofScopedLock</a></li><li class="section"><a href="#pococondition" target="_top">Poco::Condition</a></li><li class="section"><a href="#conclusion" target="_top">Conclusion</a></li></ul></div></li></ul><ul><li class="chapter"><div class="chapterTitle"><a href="memory.html">memory of C++</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#컴퓨터메모리와변수" target="_top">컴퓨터 메모리와 변수</a></li><li class="section"><a href="#스택변수함수내의변수vs오브젝트내의변수" target="_top">스택 변수, 함수내의 변수 vs 오브젝트내의 변수</a></li><li class="section"><a href="#포인터와레퍼런스" target="_top">포인터와 레퍼런스</a></li><li class="section"><a href="#힙heap영역에서의변수들" target="_top">힙(heap) 영역에서의 변수들</a></li><li class="section"><a href="#메모리구조배열과vector" target="_top">메모리 구조, 배열과 vector</a></li><li class="section"><a href="#다른메모리구조리스트와맵" target="_top">다른 메모리 구조, 리스트와 맵</a></li><li class="section"><a href="#스마트포인터" target="_top">스마트 포인터</a></li></ul></div></li></ul><ul><li class="chapter"><div class="chapterTitle"><a href="stl_vector.html">Introduction to vectors</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#quickreview" target="_top">Quick Review:</a></li><li class="section"><a href="#declaringavector" target="_top">Declaring a vector</a></li><li class="section"><a href="#addingelementstoavector" target="_top">Adding elements to a vector</a></li><li class="section"><a href="#resize" target="_top">resize</a></li><li class="section"><a href="#assign" target="_top">assign</a></li><li class="section"><a href="#accessingelementsofavector" target="_top">Accessing elements of a vector</a></li><li class="section"><a href="#erasingelementsofavector" target="_top">Erasing elements of a vector</a></li><li class="section"><a href="#iterators" target="_top">Iterators</a></li><li class="section"><a href="#sortingandshufflingavector" target="_top">Sorting and shuffling a vector</a></li><li class="section"><a href="#vectorsofobjects" target="_top">Vectors of objects</a></li></ul></div></li></ul><ul><li class="chapter"><div class="chapterTitle"><a href="stl_map.html">let's play with Map, std::map</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#소개map이무엇인가요" target="_top">소개 : map이 무엇인가요?</a></li><li class="section"><a href="#map에값삽입하기" target="_top">map에 값 삽입하기</a></li><li class="section"><a href="#map에서요소삭제하기" target="_top">map에서 요소 삭제하기</a></li><li class="section"><a href="#map을훑기" target="_top">map을 훑기</a></li><li class="section"><a href="#map에서요소찾기" target="_top">map에서 요소 찾기</a></li><li class="section"><a href="#map에오브젝트저장하기" target="_top">map에 오브젝트 저장하기</a></li><li class="section"><a href="#multimap이란무엇인가요" target="_top">multimap이란 무엇인가요?</a></li><li class="section"><a href="#다른유용한메소드들" target="_top">다른 유용한 메소드들</a></li><li class="section"><a href="#추가참고자료역자에의해추가됨" target="_top">추가 참고 자료 (역자에 의해 추가됨)</a></li></ul></div></li></ul><ul><li class="chapter"><div class="chapterTitle"><a href="c++11.html">C++ 11</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#introduction" target="_top">Introduction</a></li><li class="section"><a href="#auto" target="_top">auto</a></li><li class="section"><a href="#forthingthings" target="_top">for (thing : things)</a></li><li class="section"><a href="#override" target="_top">override</a></li><li class="section"><a href="#lambdafunctions" target="_top">Lambda functions</a></li></ul></div></li></ul></li><li class="group"><div class="groupTitle">Advanced topics</div><ul><li class="chapter"><div class="chapterTitle"><a href="math.html">Math: From 1D to 4D</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#onedimensionusingchange" target="_top">One Dimension: Using Change</a></li><li class="section"><a href="#moredimensionssomelinearalgebra" target="_top">More Dimensions: Some Linear Algebra</a></li></ul></div></li></ul></li><li class="group"><div class="groupTitle">Platforms</div><ul><li class="chapter"><div class="chapterTitle"><a href="ios.html">ofxiOS</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#openframeworksoniosdevices" target="_top">OpenFrameworks on iOS devices.</a></li><li class="section"><a href="#intro" target="_top">Intro</a></li><li class="section"><a href="#introtoobjectivec" target="_top">Intro to Objective-C</a></li><li class="section"><a href="#underthehood" target="_top">Under the Hood</a></li><li class="section"><a href="#ofuikit" target="_top">OF &amp; UIKit</a></li><li class="section"><a href="#mediaplaybackandcapture" target="_top">Media Playback and Capture</a></li><li class="section"><a href="#lifehacks" target="_top">Life Hacks</a></li><li class="section"><a href="#appstore" target="_top">App Store</a></li><li class="section"><a href="#casestudies" target="_top">Case Studies</a></li></ul></div></li></ul></li><li class="group"><div class="groupTitle">Tools</div><ul><li class="chapter"><div class="chapterTitle"><a href="version_control_with_git.html">Version control with Git</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#whatisversioncontrolandwhyshouldyouuseit" target="_top">What is version control, and why should you use it?</a></li><li class="section"><a href="#differentversioncontrolsystems" target="_top">Different version control systems</a></li><li class="section"><a href="#introductiontogit" target="_top">Introduction to Git</a></li><li class="section"><a href="#popularguiclients" target="_top">Popular GUI clients</a></li><li class="section"><a href="#conclusion" target="_top">Conclusion</a></li></ul></div></li></ul><ul><li class="chapter"><div class="chapterTitle"><a href="ofSketch.html">ofSketch</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#whatisofsketch" target="_top">What is ofSketch?</a></li><li class="section"><a href="#download" target="_top">Download</a></li><li class="section"><a href="#sketchformat" target="_top">Sketch Format</a></li><li class="section"><a href="#remotecoding" target="_top">Remote Coding</a></li><li class="section"><a href="#future" target="_top">Future</a></li></ul></div></li></ul><ul><li class="chapter"><div class="chapterTitle"><a href="installation_up_4evr_macosx.html">Installation up 4evr</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#step1prepyoursoftwareandthecomputer" target="_top">Step 1: Prep your software and the computer</a></li><li class="section"><a href="#step2bootintoyoursoftware" target="_top">Step 2: Boot into your software</a></li><li class="section"><a href="#step3keepitupchamp" target="_top">Step 3: Keep it up (champ!)</a></li><li class="section"><a href="#step4rebootperiodically" target="_top">Step 4: Reboot periodically</a></li><li class="section"><a href="#step5checkinonitfromafar" target="_top">Step 5: Check in on it from afar.</a></li><li class="section"><a href="#step6testtesttest" target="_top">Step 6: Test, test, test.</a></li><li class="section"><a href="#additionaltipslogging" target="_top">Additional Tips: Logging</a></li><li class="section"><a href="#memoryleakmurderer" target="_top">Memory leak murderer</a></li><li class="section"><a href="#alternateresources" target="_top">Alternate resources:</a></li></ul></div></li></ul><ul><li class="chapter"><div class="chapterTitle"><a href="installation_up_4evr_linux.html">installation up4ever - linux</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#몇가지추가적인팁" target="_top">몇가지 추가적인 팁:</a></li></ul></div></li></ul></li><li class="group"><div class="groupTitle">Case studies</div><ul><li class="chapter"><div class="chapterTitle"><a href="project_eva.html">Choreographies for Humans and Stars</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#projectoverview" target="_top">Project Overview</a></li><li class="section"><a href="#ideationandprototyping" target="_top">Ideation and Prototyping</a></li><li class="section"><a href="#findingthetechnicalsolutions" target="_top">Finding the Technical Solutions</a></li><li class="section"><a href="#developingthevisualizationsoftware" target="_top">Developing the Visualization Software</a></li><li class="section"><a href="#failsafesanddirtyfixes" target="_top">Fail-safes and dirty fixes</a></li><li class="section"><a href="#resultsandreception" target="_top">Results and Reception</a></li></ul></div></li></ul><ul><li class="chapter"><div class="chapterTitle"><a href="project_joel.html">Anthropocene</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#theproject" target="_top">The Project</a></li><li class="section"><a href="#development" target="_top">Development</a></li><li class="section"><a href="#showtime" target="_top">Show time</a></li><li class="section"><a href="#postevent" target="_top">Post Event</a></li><li class="section"><a href="#teamandcredits" target="_top">Team and Credits</a></li><li class="section"><a href="#hardwareselection" target="_top">Hardware selection</a></li></ul></div></li></ul></li></ul>
</nav>
<div class="chapter-content">
<h1 id="basics-of-generating-meshes-from-an-image">Basics of Generating Meshes from an Image</h1>
<p><em>By: <a href="http://www.mikewesthad.com/" target="_blank">Michael Hadley</a>.</em></p>
<h2 id="basicsofgeneratingmeshesfromanimage1">Basics of Generating Meshes from an Image</h2>
<p>This chapter is aimed at anyone who feels comfortable with the basic chapters (setting up openFrameworks, using variables, creating loops, etc.) and is itching to start playing with 3D shapes. It may be pedantic at times, but it will take you through the logic and code for taking this image (from the <a href="http://hubblesite.org/gallery/album/star/" target="_blank">Hubble star gallery</a>):</p>
<div class="figure"><div class="inner">
<div style="image"><a href="../images/generativemesh/images/stars_small.png" target="_blank"><img alt="Original hubble image" src="../images/generativemesh/images/stars_small.png"/></a></div><div class="caption">Original hubble image</div>
</div></div>
<p>and making something like this:</p>
<div class="figure"><div class="inner">
<div style="image"><a href="../images/generativemesh/images/mesh_small.png" target="_blank"><img alt="Generative hubble mesh" src="../images/generativemesh/images/mesh_small.png"/></a></div><div class="caption">Generative hubble mesh</div>
</div></div>
<p>The chapter is broken into four sections:</p>
<ol style="list-style-type: decimal">
<li><a href="#basicsworkingwithofmesh" target="_blank">Basics: Working with ofMesh</a>
<ul>
<li>Points</li>
<li>Colors</li>
<li>Lines</li>
<li>Indices</li>
</ul></li>
<li><a href="#generative" target="_blank">Generative Mesh: Using an image to drive the creation of an mesh</a>
<ul>
<li>Loading an image</li>
<li>Creating a mesh from the pixels</li>
<li>Using ofEasyCam to navigate the mesh</li>
</ul></li>
<li><a href="#manipulations" target="_blank">Manipulations: Adding effects that modify the mesh</a>
<ul>
<li>Adding jitter</li>
<li>Making the vertices orbit</li>
<li>Creating an interactive magnifying effect</li>
</ul></li>
<li><a href="#nextsteps" target="_blank">Next Steps</a></li>
</ol>
<p><strong>Note:</strong> Since this chapter uses graphics commands, there is a <em>chance</em> that your graphics card won't support some of the things we will be doing. Make sure your graphics drivers are up-to-date. If you are on a laptop that uses two graphics cards - one integrated and one dedicated - you will want to make sure that you are running your applications using the dedicated graphics card.</p>
<h2 id="basicsworkingwithofmesh">Basics: Working with ofMesh</h2>
<p>A mesh is a collection of <strong>vertices</strong> - <a href="https://en.wikipedia.org/wiki/Vertex_%28computer_graphics%29" target="_blank">points in 3D space</a> - that can be connected up in different ways. The shapes that are formed by connecting these vertices are called <strong>primitives</strong>. The primitives are our smallest building blocks that we can put together to form a mesh. We can create a couple different kinds of primitives:</p>
<ul>
<li>You can choose to not connect any of your vertices and just draw points as the primitives.</li>
<li>You can choose to connect pairs of vertices and draw lines as the primitives.</li>
<li>You can connect three or four (or more) vertices and draw triangles or quads (or polygons) as the primitives.</li>
</ul>
<p>To make this a little more concrete, check out the mesh below. The vertices are orange dots. The vertices are connected up in sets of three points to form triangle primitives which were then colored in gray. For some deeper information, have a look at the <em>OpenGl</em> chapter.</p>
<div class="figure"><div class="inner">
<div style="image"><a href="../images/generativemesh/images/Keenan_Crane_Public_Domain_Cow_Small.png" target="_blank"><img alt="Keenan Crane's public domain cow shown in wireframe" src="../images/generativemesh/images/Keenan_Crane_Public_Domain_Cow_Small.png"/></a></div><div class="caption">Keenan Crane's public domain cow shown in wireframe</div>
</div></div>
<p>We are going to focus on using points and lines as our primitives. Let's get something drawn on our screen. When creating a mesh you should:</p>
<ol style="list-style-type: decimal">
<li>Define an <a href="http://openframeworks.cc/documentation/3d/ofMesh/" target="_blank"><code>ofMesh</code></a> variable. Let's call it mesh.</li>
<li>Specify what primitive mode (points, lines, etc.) the mesh should use to connect its vertices using <a href="http://openframeworks.cc/documentation/3d/ofMesh/#show_setMode" target="_blank"><code>mesh.setMode(...)</code></a>. We'll be using points as our primitive, so that means we should use <code>OF_PRIMITIVE_POINTS</code> mode.</li>
<li>Add some vertices using <a href="http://openframeworks.cc/documentation/3d/ofMesh/#show_addVertex" target="_blank"><code>mesh.addVertex(...)</code></a>. A vertex is an <a href="http://openframeworks.cc/documentation/math/ofVec3f.html" target="_blank"><code>ofVec3f</code></a>, so if you haven't used that class before, check out the example on the documentation page.</li>
<li>Draw your mesh using <a href="http://openframeworks.cc/documentation/3d/ofMesh/#show_draw" target="_blank"><code>mesh.draw()</code></a>.</li>
</ol>
<p>And onto the code!</p>
<p>Add a mesh variable to your header file (.h, e.g. ofApp.h):</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> ofApp : <span class="kw">public</span> ofBaseApp{

    <span class="kw">public</span>:
        ofMesh mesh;
    <span class="co">// ...</span>
    <span class="co">// Keep the rest of the code that is already there.</span></code></pre>
<p>Update <code>setup()</code> and <code>draw()</code> functions in your source file (.cpp) to look like this:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> ofApp::setup() {
    mesh.setMode(OF_PRIMITIVE_POINTS);

    ofVec3f top(<span class="fl">100.0</span>, <span class="fl">50.0</span>, <span class="fl">0.0</span>);
    ofVec3f left(<span class="fl">50.0</span>, <span class="fl">150.0</span>, <span class="fl">0.0</span>);
    ofVec3f right(<span class="fl">150.0</span>, <span class="fl">150.0</span>, <span class="fl">0.0</span>);

    mesh.addVertex(top);
    mesh.addVertex(left);
    mesh.addVertex(right);
}
<span class="dt">void</span> ofApp::draw() {
    ofBackground(<span class="dv">0</span>);
    mesh.draw();
}</code></pre>
<p>If you build and run your project, you should see three white dots that are placed in a triangular arrangement on top of a black background:</p>
<div class="figure"><div class="inner">
<div style="image"><a href="../images/generativemesh/images/TrianglePoints.png" target="_blank"><img alt="Triangle Points" src="../images/generativemesh/images/TrianglePoints.png"/></a></div><div class="caption">Triangle Points</div>
</div></div>
<p>White is boring? Well, you can add some color by modifying setup:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> ofApp::setup() {
    mesh.setMode(OF_PRIMITIVE_POINTS);
    mesh.enableColors();

    ofVec3f top(<span class="fl">100.0</span>, <span class="fl">50.0</span>, <span class="fl">0.0</span>);
    ofVec3f left(<span class="fl">50.0</span>, <span class="fl">150.0</span>, <span class="fl">0.0</span>);
    ofVec3f right(<span class="fl">150.0</span>, <span class="fl">150.0</span>, <span class="fl">0.0</span>);

    mesh.addVertex(top);
    mesh.addColor(ofFloatColor(<span class="fl">1.0</span>, <span class="fl">0.0</span>, <span class="fl">0.0</span>)); <span class="co">// Red</span>

    mesh.addVertex(left);
    mesh.addColor(ofFloatColor(<span class="fl">0.0</span>, <span class="fl">1.0</span>, <span class="fl">0.0</span>)); <span class="co">// Green</span>

    mesh.addVertex(right);
    mesh.addColor(ofFloatColor(<span class="fl">1.0</span>, <span class="fl">1.0</span>, <span class="fl">0.0</span>)); <span class="co">// Blue</span>
}</code></pre>
<p>We first enable colors using <a href="http://openframeworks.cc/documentation/3d/ofMesh/#show_enableColors" target="_blank"><code>mesh.enableColors()</code></a>. Colors are enabled by default, but it is good practice to include this line. Then we can add colors using <a href="http://openframeworks.cc/documentation/3d/ofMesh/#show_addColor" target="_blank"><code>mesh.addColor(...)</code></a>. Colors are specified using <code>ofFloatColor</code> which is like <a href="http://openframeworks.cc/documentation/types/ofColor.html" target="_blank"><code>ofColor</code></a> except that the red, blue, green and alpha channels are specified with a float between 0.0 and 1.0. (You <em>can</em> use an ofColor if you want to do, because the mesh will automatically convert it to a ofFloatColor.) The first color we add applies to the first vertex, the second color to the second vertex, etc.</p>
<p>You find our points boring? Time for some lines then. We need to change the primitive mode to lines, but there are three different line primitive options. Try each of them for yourself by changing the first line of your setup function to any of these:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">    mesh.setMode(OF_PRIMITIVE_LINES);
    mesh.setMode(OF_PRIMITIVE_LINE_STRIP);
    mesh.setMode(OF_PRIMITIVE_LINE_LOOP);</code></pre>
<div class="figure"><div class="inner">
<div style="image"><a href="../images/generativemesh/images/TriangleLineMode.png" target="_blank"><img alt="Triangle Points" src="../images/generativemesh/images/TriangleLineMode.png"/></a></div><div class="caption">Triangle Points</div>
</div></div>
<p>The modes for <a href="http://openframeworks.cc/documentation/3d/ofMesh/#show_setMode" target="_blank"><code>mesh.setMode(...)</code></a> each have a different way that they generate lines from the vertices:</p>
<ul>
<li><code>OF_PRIMITIVE_LINE</code> creates an <em>independent</em> line out of each pair of vertices. If you have a set of vertices - V<sub>1</sub>, V<sub>2</sub>, V<sub>3</sub>, V<sub>4</sub>, ... - then V<sub>1</sub> will connect to V<sub>2</sub> and V<sub>3</sub> will connect to V<sub>4</sub>, etc.</li>
<li><code>OF_PRIMITIVE_LINE_STRIP</code> will create a set of <em>connected</em> lines out of each pair of vertices. V<sub>1</sub> will connect with V<sub>2</sub>, V<sub>2</sub> will connect with V<sub>3</sub>, etc.</li>
<li><code>OF_PRIMITIVE_LINE_LOOP</code> does the same as <code>OF_PRIMITIVE_LINE_STRIP</code> but will also connect the last vertex to the first vertex.</li>
</ul>
<p>Only <code>OF_PRIMITIVE_LINE_LOOP</code> outlined the whole triangle. If you wanted to create that same triangle using <code>OF_PRIMITIVE_LINE</code>, you might try adding some more vertices like this:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">    mesh.addVertex(top);
    mesh.addVertex(left);
    mesh.addVertex(left);
    mesh.addVertex(right);
    mesh.addVertex(right);
    mesh.addVertex(top);</code></pre>
<p>Feels excessive to add duplicate vertices? Let's try something else:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> ofApp::setup() {
    mesh.setMode(OF_PRIMITIVE_LINES);
    mesh.enableColors();
    mesh.enableIndices();

    ofVec3f top(<span class="fl">100.0</span>, <span class="fl">50.0</span>, <span class="fl">0.0</span>);
    ofVec3f left(<span class="fl">50.0</span>, <span class="fl">150.0</span>, <span class="fl">0.0</span>);
    ofVec3f right(<span class="fl">150.0</span>, <span class="fl">150.0</span>, <span class="fl">0.0</span>);

    mesh.addVertex(top);
    mesh.addColor(ofFloatColor(<span class="fl">1.0</span>, <span class="fl">0.0</span>, <span class="fl">0.0</span>));

    mesh.addVertex(left);
    mesh.addColor(ofFloatColor(<span class="fl">0.0</span>, <span class="fl">1.0</span>, <span class="fl">0.0</span>));

    mesh.addVertex(right);
    mesh.addColor(ofFloatColor(<span class="fl">1.0</span>, <span class="fl">1.0</span>, <span class="fl">0.0</span>));

    mesh.addIndex(<span class="dv">0</span>);
    mesh.addIndex(<span class="dv">1</span>);
    mesh.addIndex(<span class="dv">1</span>);
    mesh.addIndex(<span class="dv">2</span>);
    mesh.addIndex(<span class="dv">2</span>);
    mesh.addIndex(<span class="dv">0</span>);
}</code></pre>
<p>Indices add a layer of abstraction. Each vertex that you add to a mesh is tacked on to the end of a big old array. That means that each vertex has a number that uniquely identifies its position (or index) in that array. There's the zero-th vertex in the list, the first vertex in the list, the second, etc. So, you can point to an existing vertex using its index number.</p>
<p>When you call <a href="http://openframeworks.cc/documentation/3d/ofMesh/#!show_enableIndices" target="_blank"><code>mesh.enableIndices()</code></a>, openFrameworks creates an empty array of indices. When you use <a href="http://openframeworks.cc/documentation/3d/ofMesh/#show_addIndex" target="_blank"><code>addIndex(...)</code></a>, you are adding values to the end of this array. When the mesh is about to be drawn to the screen, instead of looping through the array of vertices to create graphical primitives, openFrameworks will loop through your array of indices to determine how to create the primitives.</p>
<p>So when our mode is <code>OF_PRIMITIVE_LINE</code> and our array of indices is <code>{0, 1, 1, 2, 2, 0}</code>, then the 0th vertex and the 1st vertex are connected, the 1st vertex and the 2nd vertex are connected, and 2nd vertex and the 0th vertex are connected. Lots of work in order to create a single triangle? Yup. But, the concept of indices is powerful and useful.</p>
<p>One more thing you might have noticed - the color of the lines. This is some of the magic that is happening on your graphics card. You can tell it that point A is red, point B is blue and that point A and B are connected with a line. Then, the graphics card will (linearly) interpolate between those colors as it draws the pixels on the screen that constitute that line.</p>
<p>As a reward for reading the whole section:</p>
<div class="figure"><div class="inner">
<div style="image"><a href="../images/generativemesh/images/LineModeFace.png" target="_blank"><img alt="Line Mode Smile" src="../images/generativemesh/images/LineModeFace.png"/></a></div><div class="caption">Line Mode Smile</div>
</div></div>
<p>I know. It's not a great reward. But it does show off something you can do with <code>OF_PRIMITIVE_LINES</code> that you can't do with the two other line primitive modes - you can create separate lines. We will take advantage of this in the next section.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">    mesh.setMode(OF_PRIMITIVE_LINES);
    mesh.enableColors();
    mesh.enableIndices();

    ofVec3f eyeLeftTop(<span class="fl">50.0</span>, <span class="fl">25.0</span>, <span class="fl">0.0</span>);
    ofVec3f eyeLeftBottom(<span class="fl">50.0</span>, <span class="fl">50.0</span>, <span class="fl">0.0</span>);
    ofVec3f eyeRightTop(<span class="fl">100.0</span>, <span class="fl">25.0</span>, <span class="fl">0.0</span>);
    ofVec3f eyeRightBottom(<span class="fl">100.0</span>, <span class="fl">50.0</span>, <span class="fl">0.0</span>);
    ofVec3f mouthLeft(<span class="fl">50.0</span>, <span class="fl">75.0</span>, <span class="fl">0.0</span>);
    ofVec3f mouthMiddle(<span class="fl">75.0</span>, <span class="fl">100.0</span>, <span class="fl">0.0</span>);
    ofVec3f mouthRight(<span class="fl">100.0</span>, <span class="fl">75.0</span>, <span class="fl">0.0</span>);

    mesh.addVertex(eyeLeftTop);
    mesh.addVertex(eyeLeftBottom);
    mesh.addIndex(<span class="dv">0</span>);
    mesh.addIndex(<span class="dv">1</span>);
    mesh.addColor(ofFloatColor(<span class="fl">0.0</span>, <span class="fl">1.0</span>, <span class="fl">1.0</span>));
    mesh.addColor(ofFloatColor(<span class="fl">0.0</span>, <span class="fl">1.0</span>, <span class="fl">1.0</span>));

    mesh.addVertex(eyeRightTop);
    mesh.addVertex(eyeRightBottom);
    mesh.addIndex(<span class="dv">2</span>);
    mesh.addIndex(<span class="dv">3</span>);
    mesh.addColor(ofFloatColor(<span class="fl">0.0</span>, <span class="fl">1.0</span>, <span class="fl">1.0</span>));
    mesh.addColor(ofFloatColor(<span class="fl">0.0</span>, <span class="fl">1.0</span>, <span class="fl">1.0</span>));

    mesh.addVertex(mouthLeft);
    mesh.addVertex(mouthMiddle);
    mesh.addVertex(mouthRight);
    mesh.addIndex(<span class="dv">4</span>);
    mesh.addIndex(<span class="dv">5</span>);
    mesh.addIndex(<span class="dv">5</span>);
    mesh.addIndex(<span class="dv">6</span>);
    mesh.addColor(ofFloatColor(<span class="fl">0.0</span>, <span class="fl">1.0</span>, <span class="fl">0.0</span>));
    mesh.addColor(ofFloatColor(<span class="fl">0.0</span>, <span class="fl">1.0</span>, <span class="fl">0.0</span>));
    mesh.addColor(ofFloatColor(<span class="fl">0.0</span>, <span class="fl">1.0</span>, <span class="fl">0.0</span>));</code></pre>
<h2 id="generativemeshusinganimagetodrivethecreationofamesh">Generative Mesh: Using an image to drive the creation of a mesh</h2>
<p>Meshes! You now have the basic ingredients to start creating a "generative" mesh. This is just a type of mesh that is created from a set of <em>rules</em> that are applied to some <em>data</em>.</p>
<p>So we need some data and some rules. Let's grab some "data" in the form of an image from the Hubble Telescope:</p>
<div class="figure"><div class="inner">
<div style="image"><a href="../images/generativemesh/images/stars.png" target="_blank"><img alt="Original hubble image" src="../images/generativemesh/images/stars.png"/></a></div><div class="caption">Original hubble image</div>
</div></div>
<p>Create a new openFrameworks project called HubbleMesh. Inside that project create the bin/data directory ('bin' may already exist) and save the above image there as "stars.png". (Click <a href="https://raw.githubusercontent.com/openframeworks/ofBook/master/chapters/generativemesh/images/stars.png" target="_blank">here</a>, then right-click the image and "save as image.")</p>
<p>Now we have some colorful, pixely goodness, but what rules should we use to transform those pixels into a mesh? We can start with drawing points and work our way up to drawing lines. Our image has a ton of stars, so let's create some vertices where those stars are located. Once we do that, we can connect up neighboring vertices with lines in order to create a web of sorts.</p>
<p>First things first, let's load that image. Go into the main.cpp file and change the dimensions to match the dimensions of the image you just downloaded:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">    ofSetupOpenGL(<span class="dv">800</span>,<span class="dv">800</span>,OF_WINDOW);</code></pre>
<p>Then go into your header file (ofApp.h) and add:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">    ofImage image;</code></pre>
<p>And lastly, into your source file (ofApp.cpp):</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> ofApp::setup(){
    image.load(<span class="st">"stars.png"</span>);
}

<span class="dt">void</span> ofApp::draw(){
    image.draw(<span class="dv">0</span>,<span class="dv">0</span>);
}</code></pre>
<p>There is no dedicated <code>ofImage</code> chapter, but check out the Graphics section of the <a href="http://openframeworks.cc/learning/" target="_blank">openFrameworks learning</a> page.</p>
<p>We just need to load our image using <a href="http://openframeworks.cc/documentation/graphics/ofImage/#show_load" target="_blank"><code>load(...)</code></a> and draw it at the top left corner of the screen with <a href="http://openframeworks.cc/documentation/graphics/ofImage/#show_draw" target="_blank"><code>draw(0,0)</code></a>.</p>
<p>Great! Image loaded. Now, we want to create a mesh with some vertices. If we only want to create vertices at the location of stars, we can do that by searching through our pixels and look for "bright" colors. In order to do this, we will need to get access to the color information of the pixels using <a href="http://openframeworks.cc/documentation/graphics/ofImage/#show_getColor" target="_blank"><code>image.getColor(x, y)</code></a>. We want to loop through the pixels in the image and apply a <a href="http://en.wikipedia.org/wiki/Thresholding_%28image_processing%29" target="_blank">threshold</a> such that we only create a vertex at the pixel locations where the intensity of the color is greater than some set value that we choose.</p>
<p>Add a mesh to ofApp.h:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">    ofMesh mesh;</code></pre>
<p>And add this to ofApp.cpp:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> ofApp::setup(){
    image.load(<span class="st">"stars.png"</span>)

    mesh.setMode(OF_PRIMITIVE_POINTS);
    mesh.enableColors();

    <span class="dt">float</span> intensityThreshold = <span class="fl">150.0</span>;
    <span class="dt">int</span> w = image.getWidth();
    <span class="dt">int</span> h = image.getHeight();
    <span class="kw">for</span> (<span class="dt">int</span> x=<span class="dv">0</span>; x&lt;w; ++x) {
        <span class="kw">for</span> (<span class="dt">int</span> y=<span class="dv">0</span>; y&lt;h; ++y) {
            ofColor c = image.getColor(x, y);
            <span class="dt">float</span> intensity = c.getLightness();
            <span class="kw">if</span> (intensity &gt;= intensityThreshold) {
                ofVec3f pos(x, y, <span class="fl">0.0</span>);
                mesh.addVertex(pos);
                <span class="co">// When addColor(...), the mesh will automatically convert</span>
                <span class="co">// the ofColor to an ofFloatColor</span>
                mesh.addColor(c);
            }
        }
    }
}
<span class="dt">void</span> ofApp::draw(){
    ofBackground(<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">255</span>);
    mesh.draw(); <span class="co">// Blue background, so it's easy to see the mesh</span>
}</code></pre>
<div class="figure"><div class="inner">
<div style="image"><a href="../images/generativemesh/images/ThresholdedStarsSmall.png" target="_blank"><img alt="Thresholded Stars Point Mesh" src="../images/generativemesh/images/ThresholdedStarsSmall.png"/></a></div><div class="caption">Thresholded Stars Point Mesh</div>
</div></div>
<p>In that code, we created a mesh with points for primitives. Then we looped through each pixel in the image (using <a href="http://openframeworks.cc/documentation/graphics/ofImage/#show_getWidth" target="_blank">getWidth()</a> and <a href="http://openframeworks.cc/documentation/graphics/ofImage/#show_getHeight" target="_blank">getHeight()</a>) and checked the intensity of each pixel's color using <a href="http://openframeworks.cc/documentation/types/ofColor/#!show_getLightness" target="_blank">getLightness()</a>. If the intensity exceeded our threshold, we created a vertex at the location of the pixel and colored it with the pixel's color. Finally, we drew our mesh on a blue background so that we could see which pixels from the image were used to generate vertices. You can raise or lower the threshold value to decrease or increase (respectively) the number of vertices.</p>
<p>Let's make that background into something more fitting using <a href="http://openframeworks.cc/documentation/graphics/ofGraphics/#!show_ofBackgroundGradient" target="_blank">ofBackgroundGradient</a>...</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> ofApp::draw(){
    ofColor centerColor = ofColor(<span class="dv">85</span>, <span class="dv">78</span>, <span class="dv">68</span>);
    ofColor edgeColor(<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>);
    ofBackgroundGradient(centerColor, edgeColor, OF_GRADIENT_CIRCULAR);
    mesh.draw();
}</code></pre>
<p>Almost time for lines, lines, lines!</p>
<p>We have a lot of vertices in our mesh. You can check the number using <a href="http://openframeworks.cc/documentation/3d/ofMesh/#show_getNumVertices" target="_blank">getNumVertices()</a> if you like:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// With a threshold of 150, there will be ~64,000 vertices</span>
cout &lt;&lt; mesh.getNumVertices() &lt;&lt; endl;</code></pre>
<p>If we were to start looping through those each of those 64,000 vertices to connect them up to the other vertices that are close-by, we could end up spending a fair chunk of time in that loop. A fairly common thing to do to speed up the processing of an image is to shrink it:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">image.load(<span class="st">"stars.png"</span>);
image.resize(<span class="dv">200</span>, <span class="dv">200</span>);</code></pre>
<p>And then because our image pixel are no longer one-to-one with our openFrameworks window pixels, we need to adjust the <em>pos</em> variable inside of our loop:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">if</span> (intensity &gt;= intensityThreshold) {
    <span class="co">// We shrunk our image by a factor of 4, so we need to multiply our pixel</span>
    <span class="co">// locations by 4 in order to have our mesh cover the openFrameworks window</span>
    ofVec3f pos(x*<span class="dv">4</span>, y*<span class="dv">4</span>, <span class="fl">0.0</span>);
    mesh.addVertex(pos);
    mesh.addColor(c);
}</code></pre>
<p>Now that we have a reasonable number of vertices (~2000), we can start connecting up vertices to form lines. If we want to only connect vertices that are nearby to each other, then we need to loop through all possible pairs of vertices, check if the distance between them is less than a particular value, and if so, connect them.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// Don't forget to change to lines mode!</span>
mesh.setMode(OF_PRIMITIVE_LINES);

<span class="co">// We are going to be using indices this time</span>
mesh.enableIndices();

<span class="co">// ...</span>
<span class="co">// Omitting the code for creating vertices for clarity</span>
<span class="co">// but don't erase it from your file!</span>

<span class="co">// Let's add some lines!</span>
<span class="dt">float</span> connectionDistance = <span class="dv">30</span>;
<span class="dt">int</span> numVerts = mesh.getNumVertices();
<span class="kw">for</span> (<span class="dt">int</span> a=<span class="dv">0</span>; a&lt;numVerts; ++a) {
    ofVec3f verta = mesh.getVertex(a);
    <span class="kw">for</span> (<span class="dt">int</span> b=a<span class="dv">+1</span>; b&lt;numVerts; ++b) {
        ofVec3f vertb = mesh.getVertex(b);
        <span class="dt">float</span> distance = verta.distance(vertb);
        <span class="kw">if</span> (distance &lt;= connectionDistance) {
            <span class="co">// In OF_PRIMITIVE_LINES, every pair of vertices or indices will be</span>
            <span class="co">// connected to form a line</span>
            mesh.addIndex(a);
            mesh.addIndex(b);
        }
    }
}</code></pre>
<p>You should end up with something like this (if the code is taking too long to run on your machine, try increasing the <em>intensityThreshold</em> variable to reduce the number of vertices):</p>
<div class="figure"><div class="inner">
<div style="image"><a href="../images/generativemesh/images/StarLinesFirstMeshSmall.png" target="_blank"><img alt="First Line Mesh" src="../images/generativemesh/images/StarLinesFirstMeshSmall.png"/></a></div><div class="caption">First Line Mesh</div>
</div></div>
<p>Let's take a look at that code again:</p>
<ol style="list-style-type: decimal">
<li>We need to get all unique pairs of vertices. We can get the position of the <em>a</em>th vertex in our mesh using <a href="http://openframeworks.cc/documentation/3d/ofMesh/#show_getVertex" target="_blank"><code>mesh.getVertex(...)</code></a>. Then we can use two <code>for</code> loops to get every pair of vertices. You might be wondering why the second loop starts <code>b=a+1</code>. The order of the vertices does not matter when connecting them to form a line, so we can exclude a bunch of values for <em>b</em>.</li>
<li>Then, we need to find the distance between those vertices. <code>ofVec3f</code> has a function to do just that: <a href="http://openframeworks.cc/documentation/math/ofVec3f/#show_distance" target="_blank"><code>distance(...)</code></a>.</li>
<li>If the vertices are closer than a value set by <em>connectionDistance</em>, then we need to add a line between them. Adding a line is just a matter of adding the indices <em>a</em> and <em>b</em> to the mesh's array of indices.</li>
</ol>
<p>Boom! Generative mesh. Let's add two more tweaks to make this into proper 3D. Firstly, we can use the saturation of the color at a pixel to change the z-coordinate of its corresponding vertex.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">if</span> (intensity &gt;= intensityThreshold) {
    <span class="dt">float</span> saturation = c.getSaturation();
    <span class="dt">float</span> z = ofMap(saturation, <span class="dv">0</span>, <span class="dv">255</span>, -<span class="dv">100</span>, <span class="dv">100</span>);
    ofVec3f pos(x*<span class="dv">4</span>, y*<span class="dv">4</span>, z);
    mesh.addVertex(pos);
    mesh.addColor(c);
}</code></pre>
<p>This code will push brighter colors in the positive z-direction and whiter colors in the negative-z direction using <a href="http://openframeworks.cc/documentation/math/ofMath/#!show_ofMap" target="_blank"><code>ofMap(...)</code></a>. <code>ofMap</code> allows us to take a value that is within one range (for us, 0 to 255) and map it to a new range of values (again for us, -100 to 100).</p>
<p>Hm...that didn't change your mesh very much? Well, now it's time for the last tweak in this section: adding a camera.</p>
<p>Add this to your header:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">		ofEasyCam easyCam;</code></pre>
<p>And then modify your draw function:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> ofApp::draw(){
    ofColor centerColor = ofColor(<span class="dv">85</span>, <span class="dv">78</span>, <span class="dv">68</span>);
    ofColor edgeColor(<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>);
    ofBackgroundGradient(centerColor, edgeColor, OF_GRADIENT_CIRCULAR);

    easyCam.begin();
        ofPushMatrix();
            ofTranslate(-ofGetWidth()/<span class="dv">2</span>, -ofGetHeight()/<span class="dv">2</span>);
            mesh.draw();
        ofPopMatrix();
    easyCam.end();
}</code></pre>
<p><a href="http://openframeworks.cc/documentation/3d/ofEasyCam/" target="_blank"><code>ofEasyCam</code></a> is a quick way to get a feel for that elusive 3rd dimension in your generative mesh. The OpenGL chapter goes into cameras, <a href="http://openframeworks.cc/documentation/graphics/ofGraphics/#!show_ofPushMatrix" target="_blank"><code>ofPushMatrix()</code></a>, <a href="http://openframeworks.cc/documentation/graphics/ofGraphics/#!show_ofPopMatrix" target="_blank"><code>ofPopMatrix()</code></a> and <a href="http://openframeworks.cc/documentation/graphics/ofGraphics/#!show_ofTranslate" target="_blank"><code>ofTranslate()</code></a>. This code will center your mesh in the camera's view. Now you can left click and drag to rotate! And right click and drag to zoom!</p>
<div class="figure"><div class="inner">
<div style="image"><a href="../images/generativemesh/images/cameraSmall.gif" target="_blank"><img alt="Line Mesh with Camera" src="../images/generativemesh/images/cameraSmall.gif"/></a></div><div class="caption">Line Mesh with Camera</div>
</div></div>
<h2 id="manipulationsaddingeffectsthatmodifythemesh">Manipulations: Adding effects that modify the mesh</h2>
<p>We've got ourselves a meshy mesh now, so let's go ahead and add some more rules to give our mesh some movement.</p>
<h3 id="jitter">Jitter</h3>
<p>The mesh resembles something you might find under a microscope, so let's add some 'organic' movement to the vertices. The motion will likely be much faster on your machine than in the gif below (browsers cap the maximum framerate of gifs), but it will give you an idea of what we are going for:</p>
<div class="figure"><div class="inner">
<div style="image"><a href="../images/generativemesh/images/jitterSmall.gif" target="_blank"><img alt="Jitter" src="../images/generativemesh/images/jitterSmall.gif"/></a></div><div class="caption">Jitter</div>
</div></div>
<p>On each frame, we are going to move each vertex by a small, random amount. Instead of using <a href="http://openframeworks.cc/documentation/math/ofMath/#show_ofRandom" target="_blank"><code>ofRandom(...)</code></a> to displace our vertices, we are going to use <a href="http://openframeworks.cc/documentation/math/ofMath/#!show_ofSignedNoise" target="_blank"><code>ofSignedNoise(...)</code></a> which generates a thing called <a href="https://en.wikipedia.org/wiki/Perlin_noise" target="_blank">Perlin noise</a>. Check out Daniel Shiffman's description of Perlin noise in section <a href="http://natureofcode.com/book/introduction/#i6-perlin-noise-a-smoother-approach" target="_blank">1.6 Perlin Noise (A Smoother Approach)</a> of his online book. Perlin noise yields random values that smoothly vary over time. You can get a good idea of the difference between random values and Perlin noise by checking out <a href="http://natureofcode.com/book/imgs/intro/intro_05.png" target="_blank">figure 1.5</a> (which shows sequential values of noise) and <a href="http://natureofcode.com/book/imgs/intro/intro_06.png" target="_blank">figure 1.6</a> (which shows sequential random values) from the book.</p>
<p>With <code>ofRandom(...)</code>, you specify a range of values, and it returns a random value within that range. If you were to call it multiple times in a row, you will (very, very likely) get a new value every time you call it. Perlin noise works a bit differently. <code>ofSignedNoise(...)</code> will always return a value between -1.0 and 1.0, but you still have to pass in an input to the function. Think of <code>ofSignedNoise(...)</code> as a squiggly line drawn on graph paper. You pass in a coordinate, an x value, and it will return the corresponding y value. If you were to call <code>ofSignedNoise(3.0)</code> multiple times, you would get the same value every time.</p>
<p>When using Perlin noise to generate motion, it is common to pass in the current time as the input (the x value). So, in order to displace our vertices, we are going to pass in the time (using <a href="http://openframeworks.cc/documentation/utils/ofUtils/#!show_ofGetElapsedTimef]" target="_blank"><code>ofGetElapsedTimef()</code></a>) to <code>ofSignedNoise</code>, so that it will give us values that change smoothly over time. One caveat - we want our vertices to appear to move independently of one another. If we pass in the same time to <code>ofSignedNoise</code> for every vertex on a frame, then every vertex will move in the same direction. When we displace vertex one, we need to use a different time than when we displace vertex two (and vertex 3, vertex 4, etc.).</p>
<p>Let's jump into the code. Add this to your header:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">		vector&lt;ofVec3f&gt; offsets;</code></pre>
<p>And add the following two lines to your setup function:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// Add this line to explicitly set the framerate to 60 frames per second:</span>
ofSetFrameRate(<span class="dv">60</span>);

<span class="co">// Some lines of code omitted for clarity, you should still</span>
<span class="co">// keep them in your local version</span>

<span class="kw">for</span> (<span class="dt">int</span> x=<span class="dv">0</span>; x&lt;w; ++x) {
    <span class="kw">for</span> (<span class="dt">int</span> y=<span class="dv">0</span>; y&lt;h; ++y) {
        ofColor c = image.getColor(x, y);
        <span class="dt">float</span> intensity = c.getLightness();
        <span class="kw">if</span> (intensity &gt;= intensityThreshold) {
            <span class="dt">float</span> saturation = c.getSaturation();
            <span class="dt">float</span> z = ofMap(saturation, <span class="dv">0</span>, <span class="dv">255</span>, -<span class="dv">100</span>, <span class="dv">100</span>);
            ofVec3f pos(x*<span class="dv">4</span>, y*<span class="dv">4</span>, z);
            mesh.addVertex(pos);
            mesh.addColor(c);

            <span class="co">// And add this line to your existing for loop:</span>
            <span class="co">// It will create a ofVec3f with 3 random values, which</span>
            <span class="co">// will allow us to move the x, y and z coordinates of</span>
            <span class="co">// each vertex independently</span>
            offsets.push_back(ofVec3f(ofRandom(<span class="dv">0</span>,<span class="dv">100000</span>), ofRandom(<span class="dv">0</span>,<span class="dv">100000</span>), ofRandom(<span class="dv">0</span>,<span class="dv">100000</span>)));
        }
    }
}</code></pre>
<p>And finally, add these lines to your update function:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> numVerts = mesh.getNumVertices();
<span class="kw">for</span> (<span class="dt">int</span> i=<span class="dv">0</span>; i&lt;numVerts; ++i) {
    ofVec3f vert = mesh.getVertex(i);

    <span class="dt">float</span> time = ofGetElapsedTimef();
    <span class="dt">float</span> timeScale = <span class="fl">5.0</span>;
    <span class="dt">float</span> displacementScale = <span class="fl">0.75</span>;
    ofVec3f timeOffsets = offsets[i];

    <span class="co">// A typical design pattern for using Perlin noise uses a couple parameters:</span>
    <span class="co">// ofSignedNoise(time*timeScale+timeOffset)*displacementScale</span>
    <span class="co">//     ofSignedNoise(time) gives us noise values that change smoothly over</span>
    <span class="co">//         time</span>
    <span class="co">//     ofSignedNoise(time*timeScale) allows us to control the smoothness of</span>
    <span class="co">//         our noise (smaller timeScale, smoother values)</span>
    <span class="co">//     ofSignedNoise(time+timeOffset) allows us to use the same Perlin noise</span>
    <span class="co">//         function to control multiple things and have them look as if they</span>
    <span class="co">//         are moving independently</span>
    <span class="co">//     ofSignedNoise(time)*displacementScale allows us to change the bounds</span>
    <span class="co">//         of the noise from [-1, 1] to whatever we want</span>
    <span class="co">// Combine all of those parameters together, and you've got some nice</span>
    <span class="co">// control over your noise</span>

    vert.x += (ofSignedNoise(time*timeScale+timeOffsets.x)) * displacementScale;
    vert.y += (ofSignedNoise(time*timeScale+timeOffsets.y)) * displacementScale;
    vert.z += (ofSignedNoise(time*timeScale+timeOffsets.z)) * displacementScale;
    mesh.setVertex(i, vert);
}</code></pre>
<p>In setup, we did two new things:</p>
<ol style="list-style-type: decimal">
<li>Specified that our program will be capped at 60 frames per second using <a href="http://openframeworks.cc/documentation/application/ofAppRunner/#!show_ofSetFrameRate" target="_blank"><code>ofSetFrameRate()</code></a>. We could get by without doing this, but it is a useful thing to do when you are making things move over time.</li>
<li>We created a variable called offsets. It is <code>vector</code> of ofVec3fs that contain random values. (See the <em>Introduction to Vectors</em> chapter.) These values allow us to move each vertex in a random x, y and z direction seemingly independently of the movement of the other vertices.</li>
</ol>
<p>Then, in update:</p>
<ol style="list-style-type: decimal">
<li>We get the location of a vertex using <a href="http://openframeworks.cc/documentation/3d/ofMesh/#!show_getVertex" target="_blank"><code>mesh.getVertex(...)</code></a> and store it in a variable called <code>vert</code>.</li>
<li>We move the x, y and z values of <code>vert</code> using <code>ofSignedNoise(...)</code> with a set of a few parameters.</li>
<li>We update the position of our vertex using <a href="/documentation/3d/ofMesh/#show_setVertex" target="_blank"><code>mesh.setVertex(...)</code></a>.</li>
</ol>
<p>Great! Now we have a warbly mesh.</p>
<h3 id="orbit">Orbit</h3>
<p>Next, we can add some swirling orbital motion. These <em>were</em> originally stars after all, so it seems fitting.</p>
<div class="figure"><div class="inner">
<div style="image"><a href="../images/generativemesh/images/orbitSmall.gif" target="_blank"><img alt="Orbit" src="../images/generativemesh/images/orbitSmall.gif"/></a></div><div class="caption">Orbit</div>
</div></div>
<p>We're going to make use of trigonometric functions to make orbital motion. If you want a good primer, check out <a href="http://natureofcode.com/book/chapter-3-oscillation/" target="_blank">chapter 3</a> of The Nature of Code.</p>
<p>Let's forget about the z-dimension for now and focus in on the x- and y-dimensions. If we want to take a point and have it orbit in a circle, we can make use of angles, sine and cosine to do that. Check out the <a href="http://en.wikipedia.org/wiki/Polar_coordinate_system" target="_blank">wiki</a> on polar coordinates - specifically, have a look at the section on "Converting between polar and Cartesian coordinates."</p>
<p>If we know how far our point is from the center, we can define its location in space using a distance and an angle (polar coordinates). We can take that distance and angle and use it to convert to x and y values (Cartesian coordinates):</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">x = distance * cos(angle)
y = distance * sin(angle)</code></pre>
<p>If you want to swing that point around in a circle, then you just need to increase the angle over time, and the math will take care of the rest.</p>
<p>So for our meshy purposes, we need to:</p>
<ol style="list-style-type: decimal">
<li>Define a center point for our vertices to rotate around</li>
<li>Calculate the initial polar coordinates where are vertices are located</li>
<li>Slowly increase the angle of the polar coordinates for each vertex over time</li>
</ol>
<p>Let's get some new variables in our header file:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// We are going to use these to allow us to toggle orbiting on and off</span>
ofMesh meshCopy;
<span class="dt">bool</span> orbiting;
<span class="dt">float</span> startOrbitTime;

<span class="co">// These variables will let us store the polar coordinates of each vertex</span>
vector&lt;<span class="dt">float</span>&gt; distances;
vector&lt;<span class="dt">float</span>&gt; angles;
ofVec3f meshCentroid;</code></pre>
<p>Add this at the end of your setup function:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// We need to calculate our center point for the mesh</span>
<span class="co">// ofMesh has a method called getCentroid() that will</span>
<span class="co">// find the average location over all of our vertices</span>
<span class="co">//    http://en.wikipedia.org/wiki/Centroid</span>
meshCentroid = mesh.getCentroid();

<span class="co">// Now that we know our centroid, we need to know the polar coordinates</span>
<span class="co">// (distance and angle) of each vertex relative to that center point.</span>
<span class="co">// We've found the distance between points before, but what about the angle?</span>
<span class="co">// This is where atan2 comes in.  atan2(y, x) takes an x and y value and returns</span>
<span class="co">// the angle relative to the origin (0,0).  If we want the angle between two</span>
<span class="co">// points (x1, y1) and (x2, y2) then we just need to use atan2(y2-y1, x2-x1).</span>
<span class="kw">for</span> (<span class="dt">int</span> i=<span class="dv">0</span>; i&lt;numVerts; ++i) {
    ofVec3f vert = mesh.getVertex(i);
    <span class="dt">float</span> distance = vert.distance(meshCentroid);
    <span class="dt">float</span> angle = atan2(vert.y-meshCentroid.y, vert.x-meshCentroid.x);
    distances.push_back(distance);
    angles.push_back(angle);
}

<span class="co">// These variables will allow us to toggle orbiting on and off</span>
orbiting = <span class="kw">false</span>;
startOrbitTime = <span class="fl">0.0</span>;
meshCopy = mesh; <span class="co">// Store a copy of the mesh, so that we can reload the original state</span></code></pre>
<p>Add this into your update function:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">if</span> (orbiting) {
    <span class="dt">int</span> numVerts = mesh.getNumVertices();
    <span class="kw">for</span> (<span class="dt">int</span> i=<span class="dv">0</span>; i&lt;numVerts; ++i) {
        ofVec3f vert = mesh.getVertex(i);
        <span class="dt">float</span> distance = distances[i];
        <span class="dt">float</span> angle = angles[i];
        <span class="dt">float</span> elapsedTime = ofGetElapsedTimef() - startOrbitTime;

        <span class="co">// Lets adjust the speed of the orbits such that things that are closer to</span>
        <span class="co">// the center rotate faster than things that are more distant</span>
        <span class="dt">float</span> speed = ofMap(distance, <span class="dv">0</span>, <span class="dv">200</span>, <span class="dv">1</span>, <span class="fl">0.25</span>, <span class="kw">true</span>);

        <span class="co">// To find the angular rotation of our vertex, we use the current time and</span>
        <span class="co">// the starting angular rotation</span>
        <span class="dt">float</span> rotatedAngle = elapsedTime * speed + angle;

        <span class="co">// Remember that our distances are calculated relative to the centroid</span>
        <span class="co">// of the mesh, so we need to shift everything back to screen</span>
        <span class="co">// coordinates by adding the x and y of the centroid</span>
        vert.x = distance * cos(rotatedAngle) + meshCentroid.x;
        vert.y = distance * sin(rotatedAngle) + meshCentroid.y;

        mesh.setVertex(i, vert);
    }
}</code></pre>
<p>And then add a <code>keyPressed</code> function into your cpp file:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> ofApp::keyPressed(<span class="dt">int</span> key){
	<span class="kw">if</span> (key == 'o') {
		orbiting = !orbiting; <span class="co">// This inverts the boolean</span>
		startOrbitTime = ofGetElapsedTimef();
		mesh = meshCopy; <span class="co">// This restores the mesh to its original values</span>
	}
}</code></pre>
<p>Now you should be able to toggle orbiting on and off using the 'o' key!</p>
<p>One additional programming note: the variable <em>meshCopy</em> was used as a backup copy of the original mesh that could be reloaded when needed. In the setup function, when we used the line:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">meshCopy = mesh;</code></pre>
<p>We were creating a separate copy of the variable <em>mesh</em> and storing it in the variable <em>meshCopy</em>. The ofMesh class provides what is called a deep copy in this instance, so if we change some vertices in <em>mesh</em> nothing in <em>meshCopy</em> will be changed. Just be wary - not all objects provide deep copies by default!</p>
<h3 id="magnifying">Magnifying</h3>
<p>The last tweak we will add gives a bit of interactivity to the mesh. We will add a magnifying glass effect:</p>
<div class="figure"><div class="inner">
<div style="image"><a href="../images/generativemesh/images/magnifierSmall.gif" target="_blank"><img alt="Magnified" src="../images/generativemesh/images/magnifierSmall.gif"/></a></div><div class="caption">Magnified</div>
</div></div>
<p>It's technically a misnomer to call it a magnifying glass effect. It is really based off of a thing in optics called <a href="http://en.wikipedia.org/wiki/Distortion_(optics)" target="_blank">barrel distortion</a>. The effect looks like this when we apply it to a grid:</p>
<div class="figure"><div class="inner">
<div style="image"><a href="../images/generativemesh/images/GridSmall.png" target="_blank"><img alt="Grid" src="../images/generativemesh/images/GridSmall.png"/></a></div><div class="caption">Grid</div>
</div></div>
<div class="figure"><div class="inner">
<div style="image"><a href="../images/generativemesh/images/BarrelDistortedGridSmall.png" target="_blank"><img alt="BarrelDistortedGrid" src="../images/generativemesh/images/BarrelDistortedGridSmall.png"/></a></div><div class="caption">BarrelDistortedGrid</div>
</div></div>
<p>What we are going to do is:</p>
<ol style="list-style-type: decimal">
<li>Find where the mouse is on the screen.</li>
<li>Find the direction that points from the mouse to each vertex.</li>
<li>Push each vertex away from the mouse in that direction.
<ul>
<li>If a vertex is close to the mouse, push it a large distance.</li>
<li>If a vertex is far away from the mouse, push it a small distance.</li>
</ul></li>
</ol>
<p>This tweak will make use of some vector math, so check out the Math chapter if you are feeling lost. On to the code!</p>
<p>Add a new variable to your header:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">		<span class="co">// Like with the orbiting tweak, this gives us a way to toggle on and off our magnifying effect</span>
		<span class="dt">bool</span> mouseDisplacement;</code></pre>
<p>Add a line at the end of our setup function:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">    <span class="co">// We want to start off without the effect turned on</span>
    mouseDisplacement = <span class="kw">false</span>;</code></pre>
<p>Add this chunk of code at that start of our update function:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">if</span> (mouseDisplacement) {
    <span class="co">// Get the mouse location - it must be relative to the center of our screen</span>
    <span class="co">// because of the ofTranslate() command in draw()</span>
    ofVec3f mouse(mouseX, ofGetHeight()-mouseY, <span class="dv">0</span>);

    <span class="co">// Loop through all the vertices in the mesh and move them away from the</span>
    <span class="co">// mouse</span>
    <span class="kw">for</span> (<span class="dt">int</span> i=<span class="dv">0</span>; i&lt;mesh.getNumVertices(); ++i) {
        ofVec3f vertex = meshCopy.getVertex(i);
        <span class="dt">float</span> distanceToMouse = mouse.distance(vertex);

        <span class="co">// Scale the displacement based on the distance to the mouse</span>
        <span class="co">// A small distance to mouse should yield a small displacement</span>
        <span class="dt">float</span> displacement = ofMap(distanceToMouse, <span class="dv">0</span>, <span class="dv">400</span>, <span class="fl">300.0</span>, <span class="dv">0</span>, <span class="kw">true</span>);

        <span class="co">// Calculate the direction from the mouse to the current vertex</span>
        ofVec3f direction = vertex - mouse;

        <span class="co">// Normalize the direction so that it has a length of one</span>
        <span class="co">// This lets us easily change the length of the vector later</span>
        direction.normalize();

        <span class="co">// Push the vertex in the direction away from the mouse and push it</span>
        <span class="co">// a distance equal to the value of the variable displacement</span>
        ofVec3f displacedVertex = vertex + displacement*direction;
        mesh.setVertex(i, displacedVertex);
    }
}</code></pre>
<p>And lastly, add this chunk of code at that start of the <code>keyPressed</code> function:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">if</span> (key == 'm') {
    mouseDisplacement = !mouseDisplacement; <span class="co">// Inverts the boolean</span>
    mesh = meshCopy; <span class="co">// Restore the original mesh</span>
}</code></pre>
<p>You made it through the chapter! (Or you just scrolled all the way down, which is an awful lot of scrolling and should be an accomplishment by itself.)</p>
<h2 id="nextsteps">Next Steps</h2>
<p>Check out the OpenGL chapter, and start playing around with the other primitive modes.</p>
<p>Go get some other data. Make up some new rules. Make something weird and share it in the openFrameworks forums!</p>
<p>For ideas of the types of things you can generate, check out these projects:</p>
<p>Golan Levin used portraits to create a series of lines in <a href="http://www.flong.com/projects/zoo/" target="_blank">Segmentation and Symptom</a>:</p>
<div class="figure"><div class="inner">
<div style="image"><a href="../images/generativemesh/images/GolanSegmentationAndSymptom.jpg" target="_blank"><img alt="GolanSegmentationAndSymptom" src="../images/generativemesh/images/GolanSegmentationAndSymptom.jpg"/></a></div><div class="caption">GolanSegmentationAndSymptom</div>
</div></div>
<p>Quayola explored Flemish paintings in <a href="http://www.quayola.com/strata4/" target="_blank">Strata #4</a></p>
<div class="figure"><div class="inner">
<div style="image"><a href="../images/generativemesh/images/QuayolaStrata4.png" target="_blank"><img alt="QuayolaStrata4" src="../images/generativemesh/images/QuayolaStrata4.png"/></a></div><div class="caption">QuayolaStrata4</div>
</div></div>
<p>Marcin Ignac created some generative jellyfish creatures in <a href="http://marcinignac.com/projects/cindermedusae/" target="_blank">Cindermedusae</a>:</p>
<div class="figure"><div class="inner">
<div style="image"><a href="../images/generativemesh/images/IgnacCindermedusae.png" target="_blank"><img alt="IgnacCindermedusae" src="../images/generativemesh/images/IgnacCindermedusae.png"/></a></div><div class="caption">IgnacCindermedusae</div>
</div></div>
<p>The Rockwell group used people's movement to change their meshes in <a href="http://lab.rockwellgroup.com/work/venice-biennale.html" target="_blank">Hall of Fragments</a>:</p>
<div class="figure"><div class="inner">
<div style="image"><a href="../images/generativemesh/images/RockwellHallOfFragments.png" target="_blank"><img alt="RockwellHallOfFragments" src="../images/generativemesh/images/RockwellHallOfFragments.png"/></a></div><div class="caption">RockwellHallOfFragments</div>
</div></div>
<p>Onformative played with text in <a href="http://www.onformative.com/work/growing-data/" target="_blank">Growing Data</a>:</p>
<div class="figure"><div class="inner">
<div style="image"><a href="../images/generativemesh/images/onformativeGrowingData.png" target="_blank"><img alt="onformativeGrowingData" src="../images/generativemesh/images/onformativeGrowingData.png"/></a></div><div class="caption">onformativeGrowingData</div>
</div></div>
<div class="footer">
<div id="prev_chapter"><a href="lines.html">&lt; drawing lines</a></div>
<div id="next_chapter"><a href="advanced_graphics.html">Advanced graphics &gt;</a></div>
</div>
<div id="help"><i>이 책은 현재 번역작업중이므로, 오탈자나 여러 오류가 있을 수 있습니다. 원본 영문의 내용도 활발히 수정중임 또한 감안해주시기 바랍니다. 오류 발견시 <a href="https://github.com/openframeworks/ofbook" target="_blank">이곳</a>에 글을 남겨주시기 바라며, 한글 번역에 관한 내용은 <a href="http://forum.openframeworks.kr/" target="_blank">오픈프레임웍스한글포럼</a>에의견을 남겨주시기 바랍니다.</i></div>
</div>
</div>
</body>
</html>
