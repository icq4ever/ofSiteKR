<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<meta content="text/css" http-equiv="Content-Style-Type"/>
<meta content="pandoc" name="generator"/>
<title>ofBook - Introduction to vectors</title>
<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
  </style>
<link href="../style/bootstrap.min.css" rel="stylesheet">
<link href="../style/style.css" rel="stylesheet" type="text/css"/>
<link href="http://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic,700italic|Merriweather:400,300,300italic,400italic,700,900,700italic,900italic" rel="stylesheet" type="text/css">
<script src="../javascript/jquery-1.8.3.min.js"></script>
<script src="../javascript/bootstrap.min.js"></script>
<script src="../javascript/navbar.js"></script>
</link></link></head>
<body>
<div class="banner">
<div class="content-wrapper">
<b>Work in progress!</b>
        This is a preliminary version of ofBook, a collaboratively written book about openFrameworks.  Please post any issues, suggestions, comments on our <a href="https://github.com/openframeworks/ofBook/" target="_blank">repo</a>.
    </div>
</div>
<div class="content-wrapper">
<nav role="navigation">
<ul id="nav-parts"><li class="group"><div class="groupTitle">Foreword</div><ul><li class="chapter"><div class="chapterTitle"><a href="foreword.html">foreword</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#책에관하여" target="_top">책에 관하여</a></li><li class="section"><a href="#credits" target="_top">Credits</a></li></ul></div></li></ul></li><li class="group"><div class="groupTitle">Basics</div><ul><li class="chapter"><div class="chapterTitle"><a href="of_philosophy.html">Philosophy</a></div></li></ul><ul><li class="chapter"><div class="chapterTitle"><a href="cplusplus_basics.html">C++ Language Basics</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#lookalive" target="_top">Look Alive!</a></li><li class="section"><a href="#iteration" target="_top">Iteration</a></li><li class="section"><a href="#compilingmyfirstapp" target="_top">Compiling My First App</a></li><li class="section"><a href="#beyondhelloworld" target="_top">Beyond Hello World</a></li><li class="section"><a href="#functions" target="_top">Functions</a></li><li class="section"><a href="#customfunctions" target="_top">Custom Functions</a></li><li class="section"><a href="#encapsulationofcomplexity" target="_top">Encapsulation of Complexity</a></li><li class="section"><a href="#variablespart1" target="_top">Variables (part 1)</a></li><li class="section"><a href="#conclusion" target="_top">Conclusion</a></li><li class="section"><a href="#ps" target="_top">PS.</a></li></ul></div></li></ul><ul><li class="chapter"><div class="chapterTitle"><a href="setup_and_project_structure.html">oF structure</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#firstthingsfirst" target="_top">First things first</a></li><li class="section"><a href="#welcometoyournewkitchen" target="_top">Welcome to your new kitchen</a></li><li class="section"><a href="#runningexamples" target="_top">Running examples</a></li><li class="section"><a href="#offolderstructure" target="_top">oF folder structure</a></li><li class="section"><a href="#theofpantry" target="_top">The oF Pantry</a></li></ul></div></li></ul><ul><li class="chapter"><div class="chapterTitle"><a href="intro_to_graphics.html">Graphics</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#brusheswithbasicshapes" target="_top">Brushes with Basic Shapes</a></li><li class="section"><a href="#brushesfromfreeformshapes" target="_top">Brushes from Freeform Shapes</a></li><li class="section"><a href="#movingtheworld" target="_top">Moving The World</a></li><li class="section"><a href="#nextsteps" target="_top">Next Steps</a></li></ul></div></li></ul><ul><li class="chapter"><div class="chapterTitle"><a href="OOPs!.html">Ooops! = Object Oriented Programming + Classes</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#overview" target="_top">Overview</a></li><li class="section"><a href="#whatisobjectorientedprogramming" target="_top">What is Object Oriented Programming</a></li><li class="section"><a href="#howtobuildyourownclassessimpleclass" target="_top">How to build your own Classes (simple Class)</a></li><li class="section"><a href="#makeanobjectfromyourclass" target="_top">Make an Object from your Class</a></li><li class="section"><a href="#makeobjectsfromyourclass" target="_top">Make objects from your Class</a></li><li class="section"><a href="#makemoreobjectsfromyourclass" target="_top">Make more Objects from your Class</a></li><li class="section"><a href="#makeevenmoreobjectsfromyourclasspropertiesandconstructors" target="_top">Make even more Objects from your Class: properties and constructors</a></li><li class="section"><a href="#makeobjectsonthefly" target="_top">Make Objects on the fly</a></li><li class="section"><a href="#makinganddeleteasyouwishusingvectors" target="_top">Making and delete as you wish - using vectors</a></li><li class="section"><a href="#quickintrotopolymorphisminheritance" target="_top">Quick intro to polymorphism (inheritance)</a></li></ul></div></li></ul><ul><li class="chapter"><div class="chapterTitle"><a href="how_of_works.html">how OF works</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#오픈프레임웍스코드의일반적인패턴설명" target="_top">오픈프레임웍스 코드의 일반적인 패턴 설명</a></li><li class="section"><a href="#setupupdatedraw" target="_top">setup, update, draw</a></li><li class="section"><a href="#클래스" target="_top">클래스</a></li><li class="section"><a href="#함수" target="_top">함수</a></li></ul></div></li></ul></li><li class="group"><div class="groupTitle">Approaches</div><ul><li class="chapter"><div class="chapterTitle"><a href="animation.html">Animation</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#background" target="_top">Background</a></li><li class="section"><a href="#animationinofusefulconcepts" target="_top">Animation in oF / useful concepts:</a></li><li class="section"><a href="#linearmovement" target="_top">Linear movement</a></li><li class="section"><a href="#functionbasedmovement" target="_top">Function based movement</a></li><li class="section"><a href="#simulation" target="_top">Simulation</a></li><li class="section"><a href="#wheretogofurther" target="_top">Where to go further</a></li></ul></div></li></ul><ul><li class="chapter"><div class="chapterTitle"><a href="game_design.html">Experimental Game Development</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#howdogamedevelopersactuallymakegames" target="_top">How do game developers actually make games?</a></li><li class="section"><a href="#sowhatisoscanyway" target="_top">So what is OSC, anyway?</a></li><li class="section"><a href="#ourbasicgameandmakingitnotsobasic" target="_top">Our basic game–and making it not so basic</a></li></ul></div></li></ul><ul><li class="chapter"><div class="chapterTitle"><a href="image_processing_computer_vision.html">image processing and computer vision</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#maybethereisamagicbullet" target="_top">Maybe There is a Magic Bullet</a></li><li class="section"><a href="#preliminariestoimageprocessing" target="_top">Preliminaries to Image Processing</a></li><li class="section"><a href="#이미지처리를얘기하기전에알아두어야할것들" target="_top">이미지처리를 얘기하기 전에 알아두어야 할것들</a></li><li class="section"><a href="#pointprocessingoperationsonimages" target="_top">Point Processing Operations on Images</a></li><li class="section"><a href="#acompleteworkflowbackgroundsubtraction" target="_top">A Complete Workflow: Background Subtraction</a></li><li class="section"><a href="#refinements" target="_top">Refinements</a></li><li class="section"><a href="#suggestionsforfurtherexperimentation" target="_top">Suggestions for Further Experimentation</a></li></ul></div></li></ul></li><li class="group"><div class="groupTitle">I/O</div><ul><li class="chapter"><div class="chapterTitle"><a href="hardware.html">Hardware</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#introduction" target="_top">introduction</a></li><li class="section"><a href="#소개" target="_top">소개</a></li><li class="section"><a href="#gettingstartedwithserialcommunication" target="_top">getting started with serial communication</a></li><li class="section"><a href="#시리얼통신시작하기" target="_top">시리얼 통신 시작 하기</a></li><li class="section"><a href="#digitalandanalogcommunication" target="_top">digital and analog communication</a></li><li class="section"><a href="#디지털과아날로그통신" target="_top">디지털과 아날로그 통신</a></li><li class="section"><a href="#usingserialforcommunicationbetweenarduinoandopenframeworks" target="_top">using serial for communication between arduino and openframeworks</a></li><li class="section"><a href="#lightsoncontrollinghardwareviadmx" target="_top">Lights On - controlling hardware via DMX</a></li></ul></div></li></ul><ul><li class="chapter"><div class="chapterTitle"><a href="sound.html">Sound</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#gettingstartedwithsoundfiles" target="_top">Getting Started With Sound Files</a></li><li class="section"><a href="#gettingstartedwiththesoundstream" target="_top">Getting Started With the Sound Stream</a></li><li class="section"><a href="#why1to1" target="_top">Why -1 to 1?</a></li><li class="section"><a href="#timedomainvsfrequencydomain" target="_top">Time Domain vs Frequency Domain</a></li><li class="section"><a href="#reactingtoliveaudio" target="_top">Reacting to Live Audio</a></li><li class="section"><a href="#synthesizingaudio" target="_top">Synthesizing Audio</a></li><li class="section"><a href="#audiogotchas" target="_top">Audio Gotchas</a></li></ul></div></li></ul><ul><li class="chapter"><div class="chapterTitle"><a href="network.html">Network</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#tcpvsudp" target="_top">TCP vs UDP</a></li><li class="section"><a href="#osc" target="_top">OSC</a></li></ul></div></li></ul></li><li class="group"><div class="groupTitle">Graphics</div><ul><li class="chapter"><div class="chapterTitle"><a href="openGL.html">Introducing OpenGL for OF</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#introducing" target="_top">Introducing</a></li><li class="section"><a href="#vertices" target="_top">Vertices</a></li><li class="section"><a href="#meshes" target="_top">Meshes</a></li><li class="section"><a href="#vbos" target="_top">VBOs</a></li><li class="section"><a href="#abasic3dscene" target="_top">A Basic 3D Scene</a></li><li class="section"><a href="#matrices" target="_top">Matrices</a></li><li class="section"><a href="#textures" target="_top">Textures</a></li><li class="section"><a href="#cameras" target="_top">Cameras</a></li></ul></div></li></ul><ul><li class="chapter"><div class="chapterTitle"><a href="lines.html">drawing lines</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#소개" target="_top">소개 ...</a></li><li class="section"><a href="#선그리기" target="_top">선 그리기</a></li><li class="section"><a href="#약간의노이즈abitofnoise" target="_top">약간의 노이즈A bit of noise</a></li><li class="section"><a href="#aweboflines" target="_top">A web of lines</a></li><li class="section"><a href="#makeasmoothlineinmovementina3dspace" target="_top">Make a smooth line in movement in a 3D space</a></li></ul></div></li></ul><ul><li class="chapter"><div class="chapterTitle"><a href="generativemesh.html">Basics of Generating Meshes from an Image</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#basicsofgeneratingmeshesfromanimage1" target="_top">Basics of Generating Meshes from an Image</a></li><li class="section"><a href="#basicsworkingwithofmesh" target="_top">Basics: Working with ofMesh</a></li><li class="section"><a href="#generativemeshusinganimagetodrivethecreationofamesh" target="_top">Generative Mesh: Using an image to drive the creation of a mesh</a></li><li class="section"><a href="#manipulationsaddingeffectsthatmodifythemesh" target="_top">Manipulations: Adding effects that modify the mesh</a></li><li class="section"><a href="#nextsteps" target="_top">Next Steps</a></li></ul></div></li></ul><ul><li class="chapter"><div class="chapterTitle"><a href="advanced_graphics.html">Advanced graphics</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#dimmediatemodevsofpolylineofpath" target="_top">2D, immediate mode vs ofPolyline/ofPath</a></li><li class="section"><a href="#d" target="_top">3D</a></li></ul></div></li></ul><ul><li class="chapter"><div class="chapterTitle"><a href="shaders.html">Introducing Shaders</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#introducing" target="_top">introducing</a></li><li class="section"><a href="#yourfirstshader" target="_top">Your first shader!</a></li><li class="section"><a href="#addinguniforms" target="_top">Adding Uniforms</a></li><li class="section"><a href="#addingsomeinteractivity" target="_top">Adding some interactivity</a></li><li class="section"><a href="#addingtextures" target="_top">Adding Textures</a></li><li class="section"><a href="#alphamasking" target="_top">Alpha Masking</a></li><li class="section"><a href="#multipletextures" target="_top">Multiple Textures</a></li><li class="section"><a href="#offbo" target="_top">ofFbo</a></li><li class="section"><a href="#texturesasdataegdisplacement" target="_top">Textures as Data (e.g. Displacement)</a></li><li class="section"><a href="#theendcongrats" target="_top">The End, Congrats!</a></li></ul></div></li></ul></li><li class="group selected"><div class="groupTitle">C++</div><ul><li class="chapter"><div class="chapterTitle"><a href="threads.html">threads</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#쓰레드란무엇이고언제사용해야하는가" target="_top">쓰레드란 무엇이고 언제 사용해야 하는가</a></li><li class="section"><a href="#ofthread" target="_top">ofThread</a></li><li class="section"><a href="#스레드와opengl" target="_top">스레드와 openGL</a></li><li class="section"><a href="#ofmutex" target="_top">ofMutex</a></li><li class="section"><a href="#externalthreadsanddoublebuffering" target="_top">External threads and double buffering</a></li><li class="section"><a href="#ofscopedlock" target="_top">ofScopedLock</a></li><li class="section"><a href="#pococondition" target="_top">Poco::Condition</a></li><li class="section"><a href="#conclusion" target="_top">Conclusion</a></li></ul></div></li></ul><ul><li class="chapter"><div class="chapterTitle"><a href="memory.html">memory of C++</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#컴퓨터메모리와변수" target="_top">컴퓨터 메모리와 변수</a></li><li class="section"><a href="#스택변수함수내의변수vs오브젝트내의변수" target="_top">스택 변수, 함수내의 변수 vs 오브젝트내의 변수</a></li><li class="section"><a href="#포인터와레퍼런스" target="_top">포인터와 레퍼런스</a></li><li class="section"><a href="#힙heap영역에서의변수들" target="_top">힙(heap) 영역에서의 변수들</a></li><li class="section"><a href="#메모리구조배열과vector" target="_top">메모리 구조, 배열과 vector</a></li><li class="section"><a href="#다른메모리구조리스트와맵" target="_top">다른 메모리 구조, 리스트와 맵</a></li><li class="section"><a href="#스마트포인터" target="_top">스마트 포인터</a></li></ul></div></li></ul><ul><li class="chapter selected"><div class="chapterTitle selected"><a href="stl_vector.html">Introduction to vectors</a></div><div class="chapterContents selected"><ul><li class="section selected"><a href="#quickreview" target="_top">Quick Review:</a></li><li class="section"><a href="#declaringavector" target="_top">Declaring a vector</a></li><li class="section"><a href="#addingelementstoavector" target="_top">Adding elements to a vector</a></li><li class="section"><a href="#resize" target="_top">resize</a></li><li class="section"><a href="#assign" target="_top">assign</a></li><li class="section"><a href="#accessingelementsofavector" target="_top">Accessing elements of a vector</a></li><li class="section"><a href="#erasingelementsofavector" target="_top">Erasing elements of a vector</a></li><li class="section"><a href="#iterators" target="_top">Iterators</a></li><li class="section"><a href="#sortingandshufflingavector" target="_top">Sorting and shuffling a vector</a></li><li class="section"><a href="#vectorsofobjects" target="_top">Vectors of objects</a></li></ul></div></li></ul><ul><li class="chapter"><div class="chapterTitle"><a href="stl_map.html">let's play with Map, std::map</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#소개map이무엇인가요" target="_top">소개 : map이 무엇인가요?</a></li><li class="section"><a href="#map에값삽입하기" target="_top">map에 값 삽입하기</a></li><li class="section"><a href="#map에서요소삭제하기" target="_top">map에서 요소 삭제하기</a></li><li class="section"><a href="#map을훑기" target="_top">map을 훑기</a></li><li class="section"><a href="#map에서요소찾기" target="_top">map에서 요소 찾기</a></li><li class="section"><a href="#map에오브젝트저장하기" target="_top">map에 오브젝트 저장하기</a></li><li class="section"><a href="#multimap이란무엇인가요" target="_top">multimap이란 무엇인가요?</a></li><li class="section"><a href="#다른유용한메소드들" target="_top">다른 유용한 메소드들</a></li><li class="section"><a href="#추가참고자료역자에의해추가됨" target="_top">추가 참고 자료 (역자에 의해 추가됨)</a></li></ul></div></li></ul><ul><li class="chapter"><div class="chapterTitle"><a href="c++11.html">C++ 11</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#introduction" target="_top">Introduction</a></li><li class="section"><a href="#auto" target="_top">auto</a></li><li class="section"><a href="#forthingthings" target="_top">for (thing : things)</a></li><li class="section"><a href="#override" target="_top">override</a></li><li class="section"><a href="#lambdafunctions" target="_top">Lambda functions</a></li></ul></div></li></ul></li><li class="group"><div class="groupTitle">Advanced topics</div><ul><li class="chapter"><div class="chapterTitle"><a href="math.html">Math: From 1D to 4D</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#onedimensionusingchange" target="_top">One Dimension: Using Change</a></li><li class="section"><a href="#moredimensionssomelinearalgebra" target="_top">More Dimensions: Some Linear Algebra</a></li></ul></div></li></ul></li><li class="group"><div class="groupTitle">Platforms</div><ul><li class="chapter"><div class="chapterTitle"><a href="ios.html">ofxiOS</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#openframeworksoniosdevices" target="_top">OpenFrameworks on iOS devices.</a></li><li class="section"><a href="#intro" target="_top">Intro</a></li><li class="section"><a href="#introtoobjectivec" target="_top">Intro to Objective-C</a></li><li class="section"><a href="#underthehood" target="_top">Under the Hood</a></li><li class="section"><a href="#ofuikit" target="_top">OF &amp; UIKit</a></li><li class="section"><a href="#mediaplaybackandcapture" target="_top">Media Playback and Capture</a></li><li class="section"><a href="#lifehacks" target="_top">Life Hacks</a></li><li class="section"><a href="#appstore" target="_top">App Store</a></li><li class="section"><a href="#casestudies" target="_top">Case Studies</a></li></ul></div></li></ul></li><li class="group"><div class="groupTitle">Tools</div><ul><li class="chapter"><div class="chapterTitle"><a href="version_control_with_git.html">Version control with Git</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#whatisversioncontrolandwhyshouldyouuseit" target="_top">What is version control, and why should you use it?</a></li><li class="section"><a href="#differentversioncontrolsystems" target="_top">Different version control systems</a></li><li class="section"><a href="#introductiontogit" target="_top">Introduction to Git</a></li><li class="section"><a href="#popularguiclients" target="_top">Popular GUI clients</a></li><li class="section"><a href="#conclusion" target="_top">Conclusion</a></li></ul></div></li></ul><ul><li class="chapter"><div class="chapterTitle"><a href="ofSketch.html">ofSketch</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#whatisofsketch" target="_top">What is ofSketch?</a></li><li class="section"><a href="#download" target="_top">Download</a></li><li class="section"><a href="#sketchformat" target="_top">Sketch Format</a></li><li class="section"><a href="#remotecoding" target="_top">Remote Coding</a></li><li class="section"><a href="#future" target="_top">Future</a></li></ul></div></li></ul><ul><li class="chapter"><div class="chapterTitle"><a href="installation_up_4evr_macosx.html">Installation up 4evr</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#step1prepyoursoftwareandthecomputer" target="_top">Step 1: Prep your software and the computer</a></li><li class="section"><a href="#step2bootintoyoursoftware" target="_top">Step 2: Boot into your software</a></li><li class="section"><a href="#step3keepitupchamp" target="_top">Step 3: Keep it up (champ!)</a></li><li class="section"><a href="#step4rebootperiodically" target="_top">Step 4: Reboot periodically</a></li><li class="section"><a href="#step5checkinonitfromafar" target="_top">Step 5: Check in on it from afar.</a></li><li class="section"><a href="#step6testtesttest" target="_top">Step 6: Test, test, test.</a></li><li class="section"><a href="#additionaltipslogging" target="_top">Additional Tips: Logging</a></li><li class="section"><a href="#memoryleakmurderer" target="_top">Memory leak murderer</a></li><li class="section"><a href="#alternateresources" target="_top">Alternate resources:</a></li></ul></div></li></ul><ul><li class="chapter"><div class="chapterTitle"><a href="installation_up_4evr_linux.html">installation up4ever - linux</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#몇가지추가적인팁" target="_top">몇가지 추가적인 팁:</a></li></ul></div></li></ul></li><li class="group"><div class="groupTitle">Case studies</div><ul><li class="chapter"><div class="chapterTitle"><a href="project_eva.html">Choreographies for Humans and Stars</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#projectoverview" target="_top">Project Overview</a></li><li class="section"><a href="#ideationandprototyping" target="_top">Ideation and Prototyping</a></li><li class="section"><a href="#findingthetechnicalsolutions" target="_top">Finding the Technical Solutions</a></li><li class="section"><a href="#developingthevisualizationsoftware" target="_top">Developing the Visualization Software</a></li><li class="section"><a href="#failsafesanddirtyfixes" target="_top">Fail-safes and dirty fixes</a></li><li class="section"><a href="#resultsandreception" target="_top">Results and Reception</a></li></ul></div></li></ul><ul><li class="chapter"><div class="chapterTitle"><a href="project_joel.html">Anthropocene</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#theproject" target="_top">The Project</a></li><li class="section"><a href="#development" target="_top">Development</a></li><li class="section"><a href="#showtime" target="_top">Show time</a></li><li class="section"><a href="#postevent" target="_top">Post Event</a></li><li class="section"><a href="#teamandcredits" target="_top">Team and Credits</a></li><li class="section"><a href="#hardwareselection" target="_top">Hardware selection</a></li></ul></div></li></ul></li></ul>
</nav>
<div class="chapter-content">
<h1 id="introduction-to-vectors">Introduction to vectors</h1>
<p><em>by Chris Sugrue</em></p>
<p>A c++ vector is a type of container (like an array) that allows the storage of multiple elements (numbers, strings, objects etc.) in a format that can grow or shrink dynamically. Once a vector is created, new elements can be added, others erased and the entire vector can be sorted or shuffled. This tutorial is an overview of the basics of using vectors and is geared towards openFrameworks programmers that may be new or coming from other platforms and languages. It is not a comprehensive guide to all the functions of c++ vectors (additional resource links are provided below).</p>
<p>Additional Resources:</p>
<p><a href="http://www.cplusplus.com/reference/vector/vector/" target="_blank">C++ Vector Reference</a></p>
<h2 id="quickreview">Quick Review:</h2>
<pre class="sourceCode cpp"><code class="sourceCode cpp">vector&lt;<span class="dt">float</span>&gt; nums;  <span class="co">// create an empty vector of floats     </span></code></pre>
<pre class="sourceCode cpp"><code class="sourceCode cpp">nums.push_back(<span class="fl">10.5</span>); <span class="co">// add a float with value 10.5 to the end of vector</span></code></pre>
<pre class="sourceCode cpp"><code class="sourceCode cpp">cout &lt;&lt; nums[<span class="dv">0</span>] &lt;&lt; endl; <span class="co">// print out the value of element at position 0</span></code></pre>
<pre class="sourceCode cpp"><code class="sourceCode cpp">nums.erase( nums.begin() ); <span class="co">// erase the first element in the vector</span></code></pre>
<pre class="sourceCode cpp"><code class="sourceCode cpp">cout &lt;&lt; nums.size() &lt;&lt; endl; <span class="co">// print the number of elements in the vector</span>

vector&lt;<span class="dt">float</span>&gt;:: iterator it = nums.begin(); <span class="co">// create an iterator for vector that points to first element</span>
cout &lt;&lt; *it &lt;&lt; end; <span class="co">// print out the value of the element pointed to by the iterator</span></code></pre>
<h2 id="declaringavector">Declaring a vector</h2>
<p>vector&lt; <em>type</em> &gt; <em>name</em>;</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">vector&lt;<span class="dt">float</span>&gt; measures;       
vector&lt;string&gt; surnames;
vector&lt;Particle&gt; particles;</code></pre>
<h2 id="addingelementstoavector">Adding elements to a vector</h2>
<h3 id="push_back">push_back</h3>
<p><em>push_back</em> adds a new element to the end of the vector.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">vector&lt;string&gt; names; <span class="co">// declare an empty vector</span>

names.push_back(<span class="st">"jane"</span>); <span class="co">// add an element</span>
names.push_back(<span class="st">"joe"</span>); <span class="co">// add another - now has size of 2 with elements: "jane", "joe"</span></code></pre>
<p><em>push_back</em> is a very common way to add elements and is useful when adding elements one at a time or only a few (adding objects when an event occurs for example).</p>
<h2 id="resize">resize</h2>
<p><em>resize</em> allocates memory for the desired number of elements in the vector and adjusts its size accordingly.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">vector&lt;<span class="dt">int</span>&gt; nums; <span class="co">// declare the vector</span>

nums.resize(<span class="dv">100</span>); <span class="co">// allocate space for 100 ints in vector</span>

<span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; nums.size(); i++){
  nums[i] = i; <span class="co">// set value using index</span>
}</code></pre>
<p>When adding many elements at the same time, using <em>resize</em> may be faster than <em>push_back</em>. This is because when a new element is added to the end of a vector there might not be enough space in memory at the current location. In this case, the entire vector is moved meaning that it will be copied and new memory allocated in a different location. This can be slow and may occur multiple times when using push_back in a loop. When using <em>resize</em> the move would only need to be performed once.</p>
<p>For more details on this refer to <a href="http://arturocastro.net/blog/2011/10/28/stl::vector/" target="_blank">Arturo Castro's tutorial</a></p>
<h2 id="assign">assign</h2>
<p><em>assign</em> can be used to create a vector of a given size and populate it with uniform values, or to copy part of an existing vector. It reinitializes the vector deleting any previous elements.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">vector&lt;<span class="dt">float</span>&gt; vals; <span class="co">// declare the vector</span>
vals.assign(<span class="dv">100</span>,<span class="fl">0.</span>0f); <span class="co">// add 100 floats all with value of 0.0</span>

vector&lt;Particle&gt; particles;
particles.assign(<span class="dv">10</span>,Particle());

vector&lt;Particle&gt; copyParticles;
copyParticles.assign( particles.begin(), particles.begin()+<span class="dv">5</span> );</code></pre>
<h2 id="accessingelementsofavector">Accessing elements of a vector</h2>
<h3 id="operator">operator []</h3>
<p>Elements can be accessed using the [] operator with an index in the same style as c arrays.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">cout &lt;&lt; names[<span class="dv">0</span>] &lt;&lt; end; <span class="co">// !if there is no element 0, you have a memory access error</span>

<span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; names.size(); i++){
  cout &lt;&lt; names[i] &lt;&lt; endl;
}</code></pre>
<h3 id="at">at()</h3>
<p>Vectors have a function <em>at()</em> that will return the value in the same way as the [] operator, however it is slightly slower than []. <em>at()</em> checks if the index is in bounds and if not, throws an exception. This can make it useful for debugging, however for clarity and speed [] is usually preferred.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">cout &lt;&lt; names.at(<span class="dv">0</span>) &lt;&lt; endl;</code></pre>
<h2 id="erasingelementsofavector">Erasing elements of a vector</h2>
<h3 id="erase">erase</h3>
<p>An element can be removed from a vector using <em>erase</em>. This function takes in an iterator to the position in the vector not the index. The function <em>begin()</em> returns an iterator to the first element of the vector and can be added to to pass in subsequent positions. Note that erase does not check if the element exists or not, so be sure when erasing!</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">particles.erase( particles.begin() ); <span class="co">// erase first element</span>

particles.erase( particles.begin() + <span class="dv">3</span> ); <span class="co">// erase third element</span>

particles.erase( particles.begin(), particles.begin()+<span class="dv">2</span> ); <span class="co">// remove first 2 elements</span></code></pre>
<h3 id="clear">clear</h3>
<p><em>clear</em> removes all elements in the vector reducing its size to 0.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">particles.clear();</code></pre>
<h2 id="iterators">Iterators</h2>
<p>An iterator is a class of objects designed to help traverse through a sequence of elements (such as a vector). An iterator for a vector points to an individual element in the vector, and can be incremented to point to the next. As some vector functions take int or return iterators, it is useful to understand how they work.</p>
<p>Declaring an iterator for a vector:</p>
<p>vector&lt; <em>type</em> &gt;::iterator it; // <em>it</em> is the name of the iterator but could be called anything we want</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">vector&lt;<span class="dt">float</span>&gt;::iterator it = nums.begin();
vector&lt;Particle&gt;::iterator itp = partices.begin();</code></pre>
<p><em>begin()</em> returns an iterator to the first element of the vector and <em>end()</em> to one past the last element in the vector.</p>
<p>To access the value of an element using an iterator, we have to dereference it as if it was a pointer. The iterator is pointing to the element in the array, but we want the value of element it is pointing to instead.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">vector&lt;<span class="dt">int</span>&gt;  nums;
nums.push_back(<span class="dv">10</span>);
vector&lt;<span class="dt">int</span>&gt;::iterator it = nums.begin();
cout &lt;&lt; *it &lt;&lt; endl; <span class="co">// prints out 10</span>

vector&lt;Particle&gt;::iterator itp = particles.begin(); <span class="co">// get iterator to first element</span>
<span class="dt">float</span> xpos = (*itp).pos.x; <span class="co">// use dereference * to access the element value or properties</span>
particle.erase(itp); <span class="co">// pass the iterator to a vector function such as erase </span></code></pre>
<p>Looping through the vector using iterators:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"> 
vector&lt;<span class="dt">float</span>&gt;::iterator it = nums.begin();  <span class="co">// create an iterator that points to the first element</span>

<span class="co">// loop through, increasing to next element until the end is reached</span>

<span class="kw">for</span>(; it != nums.end(); ++it){ 
  cout &lt;&lt; *it &lt;&lt; end; <span class="co">// output value with dereference operator</span>
}


<span class="kw">for</span>(vector&lt;Particle&gt;::iterator it = particles.begin(); it != particles.end(); ++it){ 
  cout &lt;&lt; (*it).pos.x &lt;&lt; end; 
}</code></pre>
<p>Note that when using iterators we want to test that our iterator ( <em>it</em> in this case) is not equal to <em>end()</em> (it != particles.end()) rather than &gt; test. <em>end()</em> signifies one element beyond the last. This is important because an iterator cannot be incremented beyond <em>end()</em> or bad things can happen.</p>
<p>In a while loop the structure would be:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">vector&lt;Particle&gt;::iterator it = particles.begin();

<span class="kw">while</span>( it != particles.end() ){
 cout &lt;&lt; (*it).x &lt;&lt; end; 
 ++it;
}</code></pre>
<p>When erasing multiple elements with an iterator, it is important that the iterator gets a return value from the erased element so it does not become invalid.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">vector&lt;<span class="dt">float</span>&gt; iterator::it = nums.begin(); <span class="co">// iterator points to first element</span>

<span class="kw">for</span>(; it != num.end();){
	<span class="kw">if</span>( *it &gt; <span class="fl">5.2</span> ) it = nums.erase(it); <span class="co">// be sure to return the iterator when erasing so it is not invalidated</span>
	<span class="kw">else</span> ++it;
}</code></pre>
<p>With vectors there is no speed difference between iterators or array-style [] indexes.</p>
<h3 id="stdremove_if-and-ofremove">std::remove_if and ofRemove</h3>
<p><em>remove_if</em> checks conditions defined in a boolean function to determine if each element of the vector should be deleted or not. It moves any that return true to the end of the vector and then returns the iterator to the first element that should be removed. It does not remove anything, but can be used together with <em>erase</em> to actually delete the undesired elements. This is useful when all elements in the vector need to be checked to see if they should be deleted or not (for example if a particle has gone off screen or its life timer has reached zero and so on).</p>
<p>The first step is defining a function that returns a bool and takes in as a parameter a reference to an element of the type the vector contains.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">bool</span> checkDead( Particle &amp;p ){
	<span class="kw">return</span> p.isDead;
}</code></pre>
<p>Then call <em>erase</em> with the iterator returned from <em>remove_if</em>:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">vector&lt;Particle&gt;::iterator it = particles.remove_if(particles.begin(),particles.end(),checkDead);
particles.erase( it, particles.end() );

<span class="co">// or all in one line</span>
particles.erase( particles.remove_if(particles.begin(),particles.end(),checkDead), particles.end() );</code></pre>
<p>OpenFrameworks has a function called <em>ofRemove</em> that performs similarly. Create the function and pass it with the vector to perform both the <em>remove_if</em> and <em>erase</em> at the same time.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">ofRemove(particles,checkDead); <span class="co">//particles is the vector, checkDead is the boolean function</span></code></pre>
<p>Be careful that this format is not used with a vector of pointers to objects (see below).</p>
<h2 id="sortingandshufflingavector">Sorting and shuffling a vector</h2>
<p>c++ has a number of &lt; algorithm &gt; functions that work with vectors and iterators ( <em>remove_if</em> is one of these for example). Two very useful functions are <em>sort</em> and <em>random_shuffle</em>. In openFrameworks they are implemented as <em>ofSort</em> and <em>ofRandomize</em>.</p>
<p><em>sort</em> works similarly to <em>remove_if</em> in that it can take in a vector and a boolean function that determines how the elements are sorted. The boolean function has two parameter that are elements of the type of vector, and returns true or false based on a comparison of the two.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// compare for a vector of floats, sorting from lowest to highest</span>
<span class="dt">bool</span> my_compare( <span class="dt">float</span> a, <span class="dt">float</span> b){
    <span class="kw">return</span> a &lt; b;
}</code></pre>
<p>The vector range and boolean function can then be passed to <em>sort</em>:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">    vector&lt;<span class="dt">float</span>&gt;vals;
    vals.push_back(<span class="fl">3.0</span>);
    vals.push_back(.<span class="dv">1</span>);
    vals.push_back(<span class="fl">2.3</span>); <span class="co">// vector now has: 3.0,.1,2.3</span>
    
    std::sort( vals.begin(), vals.end(), my_compare); <span class="co">// after sorting: .1, 2.3, 3.0</span></code></pre>
<p><em>ofSort</em> with objects:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">    <span class="dt">bool</span> my_compare( Particle &amp;a, Particle &amp;b){
        <span class="kw">return</span> a.pos.x &lt; b.pos.x;
    }
    
    ...
    vector&lt;Particle&gt; particles;
    particles.assign(<span class="dv">10</span>,Particle());
    
    ofSort(particles,my_compare); <span class="co">// with ofSort the entire vector is passed in rather than a range</span></code></pre>
<p><em>random_shuffle</em> and <em>ofRandomize</em> simply shuffle the elements of a vector into a random order.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">    std::random_shuffle(vals.begin(),vals.end());  <span class="co">// pass in range to be shuffled</span>
     
    ofRandomize(vals); <span class="co">// pass in just the  vector (all will be shuffled)</span></code></pre>
<p>More information on <a href="http://www.cplusplus.com/reference/algorithm/" target="_blank"> algorithm </a> functions:</p>
<h2 id="vectorsofobjects">Vectors of objects</h2>
<p>As indicated in the above examples, it is quite common to create vectors of objects.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">    vector&lt;Particle&gt; particles;</code></pre>
<p>In many situations this works great and is preferred. However, problems can sometimes arise if the class has member pointers and dynamically allocated memory but not a proper copy constructor. A vector of pointers to objects can be used, although shared pointers are probably best. Shared pointers would also be needed to use polymorphism / base classes.</p>
<p>More on <a href="http://www.learncpp.com/cpp-tutorial/912-shallow-vs-deep-copying/" target="_blank">vectors and copy constructors</a>.</p>
<p><a name="vectorspointers" target="_blank"></a> ## Vectors of pointers to objects</p>
<p>When using a vector of pointers to objects, the syntax is similar:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">    vector&lt;Particle *&gt; particlePointers;</code></pre>
<p>It is very important to remember that when erasing a pointer to an object in a vector it needs to be deleted as well as erased!!</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">    <span class="co">// delete and erase a single element with index</span>
    <span class="kw">delete</span> particlePointers[<span class="dv">1</span>];
    particlePointers.erase( particlePointers.begin()+<span class="dv">1</span> );

    <span class="co">// delete and erase with a loop</span>
    vector&lt;Particle&gt;::iterator it = particlePointers.begin();
    <span class="kw">for</span>(; it != particlePointers.end();){
    	<span class="kw">if</span>( (*it)-&gt;isDead ){
    		<span class="kw">delete</span> *it;
     		it = particlePointers.erase(it);
    	}<span class="kw">else</span>
    		++it;
    }</code></pre>
<p>Note that this means erase and remove_if demonstrated above will not be sufficient. If pointers are needed, it is worthwhile to consider using shared pointers instead.</p>
<p><a name="optimizing" target="_blank"></a> ## Optimization with resize and reserve See <a href="http://arturocastro.net/blog/2011/10/28/stl::vector/" target="_blank">Arturo Castro's article.</a></p>
<p><a name="of" target="_blank"></a> ## OpenFrameworks Example</p>
<p>ofApp.h</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">    <span class="ot">#pragma once</span>

    <span class="ot">#include "ofMain.h"</span>

    <span class="co">// create the particle class in the header for brevity</span>

    <span class="kw">class</span> Particle{
    <span class="kw">public</span>:
    Particle(){
    		pos.set( <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span> );
    		vel.set( ofRandom(-<span class="dv">5</span>,<span class="dv">5</span>), ofRandom(-<span class="dv">4</span>,-<span class="dv">8</span>), <span class="dv">0</span>);
    	}
	
    	<span class="dt">void</span> update(){
    		pos += vel;
    		vel.y += .<span class="dv">1</span>;
    	}
	
    	<span class="dt">void</span> draw(){
    		ofDrawEllipse(pos.x,pos.y,<span class="dv">10</span>,<span class="dv">10</span>);
    	}
	
    	ofPoint pos;
    	ofVec3f vel;
	
    };

    <span class="kw">class</span> ofApp : <span class="kw">public</span> ofBaseApp{
    <span class="kw">public</span>:
    	<span class="dt">void</span> setup();
    	<span class="dt">void</span> update();
        <span class="dt">void</span> draw();
	    
        <span class="dt">void</span> keyPressed(<span class="dt">int</span> key);
    	<span class="dt">void</span> keyReleased(<span class="dt">int</span> key);
    	<span class="dt">void</span> mouseMoved(<span class="dt">int</span> x, <span class="dt">int</span> y);
    	<span class="dt">void</span> mouseDragged(<span class="dt">int</span> x, <span class="dt">int</span> y, <span class="dt">int</span> button);
    	<span class="dt">void</span> mousePressed(<span class="dt">int</span> x, <span class="dt">int</span> y, <span class="dt">int</span> button);
    	<span class="dt">void</span> mouseReleased(<span class="dt">int</span> x, <span class="dt">int</span> y, <span class="dt">int</span> button);
    	<span class="dt">void</span> windowResized(<span class="dt">int</span> w, <span class="dt">int</span> h);
    	<span class="dt">void</span> dragEvent(ofDragInfo dragInfo);
    	<span class="dt">void</span> gotMessage(ofMessage msg);
	
    	<span class="co">// declare the vector of particles</span>
    	vector&lt;Particle&gt; particles;
    };</code></pre>
<p>ofApp.cpp</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">    <span class="ot">#include "ofApp.h"</span>
    
    <span class="co">// write our boolean remove function</span>
    <span class="dt">bool</span> shouldRemove(Particle &amp;p){
    	<span class="kw">if</span>(p.pos.y &gt; ofGetHeight() )<span class="kw">return</span> <span class="kw">true</span>;
    	<span class="kw">else</span> <span class="kw">return</span> <span class="kw">false</span>;
    }
    
    <span class="dt">void</span> ofApp::setup(){
    	ofSetFrameRate(<span class="dv">60</span>);
    }
    
    <span class="dt">void</span> ofApp::update(){
    	<span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; particles.size(); i++){
    		particles[i].update();
    	}
    	
    	ofRemove(particles,shouldRemove);
    }
    
    <span class="dt">void</span> ofApp::draw(){
    	
        ofTranslate( ofGetWidth()/<span class="dv">2</span>, ofGetHeight()/<span class="dv">2</span>);
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; particles.size(); i++){
    		particles[i].draw();
    	}
    }
    
    <span class="dt">void</span> ofApp::keyPressed(<span class="dt">int</span> key){
    	particles.push_back( Particle() );
    }</code></pre>
<p>ofApp.cpp using iterators</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">    <span class="ot">#include "ofApp.h"</span>
    
    <span class="co">// write our boolean remove function</span>
    <span class="dt">bool</span> shouldRemove(Particle &amp;p){
    	<span class="kw">if</span>(p.pos.y &gt; ofGetHeight() )<span class="kw">return</span> <span class="kw">true</span>;
    	<span class="kw">else</span> <span class="kw">return</span> <span class="kw">false</span>;
    }
    
    <span class="dt">void</span> ofApp::setup(){
    	ofSetFrameRate(<span class="dv">60</span>);
    }
    
    <span class="dt">void</span> ofApp::update(){
    	
    	<span class="kw">for</span>(vector&lt;Particle&gt;::iterator it = particles.begin(); it != particles.end(); it++){
    		(*it).update();
    	}
    	
    	ofRemove(particles,shouldRemove);
    }
    
    <span class="dt">void</span> ofApp::draw(){
    	
        ofTranslate( ofGetWidth()/<span class="dv">2</span>, ofGetHeight()/<span class="dv">2</span>);
        <span class="kw">for</span>(vector&lt;Particle&gt;::iterator it = particles.begin(); it != particles.end(); it++){
    		(*it).draw();
    	}
    }
    
    <span class="dt">void</span> ofApp::keyPressed(<span class="dt">int</span> key){
    	particles.push_back( Particle() );
    }</code></pre>
<div class="footer">
<div id="prev_chapter"><a href="memory.html">&lt; memory of C++</a></div>
<div id="next_chapter"><a href="stl_map.html">let's play with Map, std::map &gt;</a></div>
</div>
<div id="help"><i>please note that this book / chapter is a work in progress.  Feel free to suggest edits / corrections <a href="https://github.com/openframeworks/ofbook" target="_blank">here</a></i></div>
</div>
</div>
</body>
</html>
