<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<meta content="text/css" http-equiv="Content-Style-Type"/>
<meta content="pandoc" name="generator"/>
<title>ofBook - Introducing Shaders</title>
<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
  </style>
<link href="../style/bootstrap.min.css" rel="stylesheet">
<link href="../style/style.css" rel="stylesheet" type="text/css"/>
<link href="http://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic,700italic|Merriweather:400,300,300italic,400italic,700,900,700italic,900italic" rel="stylesheet" type="text/css">
<script src="../javascript/jquery-1.8.3.min.js"></script>
<script src="../javascript/bootstrap.min.js"></script>
<script src="../javascript/navbar.js"></script>
</link></link></head>
<body>
<div class="banner">
<div class="content-wrapper">
<b>현재 작업중인 내용이므로 완성본이 아닙니다!</b>
        보고 계신 내용은 오픈프레임웍스에 관해 여러사람들이 협업하여 작업/번역중인 임시적인 버전의 ofBook입니다. 이슈, 제안, 코멘트등은 <a href="https://github.com/openframeworks/ofBook/" target="_blank">repo</a>로 알려주시고, 번역에 관련된 경우 <a href="http://forum.openframeworks.kr/" target="_blank">오픈프레임웍스 한글 포럼</a>에 글을 남겨주시기 바랍니다.
    </div>
</div>
<div class="content-wrapper">
<nav role="navigation">
<ul id="nav-parts"><li class="group"><div class="groupTitle">Foreword</div><ul><li class="chapter"><div class="chapterTitle"><a href="foreword.html">foreword</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#책에관하여" target="_top">책에 관하여</a></li><li class="section"><a href="#credits" target="_top">Credits</a></li></ul></div></li></ul></li><li class="group"><div class="groupTitle">Basics</div><ul><li class="chapter"><div class="chapterTitle"><a href="of_philosophy.html">Philosophy</a></div></li></ul><ul><li class="chapter"><div class="chapterTitle"><a href="cplusplus_basics.html">C++ Language Basics</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#lookalive" target="_top">Look Alive!</a></li><li class="section"><a href="#iteration" target="_top">Iteration</a></li><li class="section"><a href="#compilingmyfirstapp" target="_top">Compiling My First App</a></li><li class="section"><a href="#beyondhelloworld" target="_top">Beyond Hello World</a></li><li class="section"><a href="#functions" target="_top">Functions</a></li><li class="section"><a href="#customfunctions" target="_top">Custom Functions</a></li><li class="section"><a href="#encapsulationofcomplexity" target="_top">Encapsulation of Complexity</a></li><li class="section"><a href="#variablespart1" target="_top">Variables (part 1)</a></li><li class="section"><a href="#conclusion" target="_top">Conclusion</a></li><li class="section"><a href="#ps" target="_top">PS.</a></li></ul></div></li></ul><ul><li class="chapter"><div class="chapterTitle"><a href="setup_and_project_structure.html">oF structure</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#firstthingsfirst" target="_top">First things first</a></li><li class="section"><a href="#welcometoyournewkitchen" target="_top">Welcome to your new kitchen</a></li><li class="section"><a href="#runningexamples" target="_top">Running examples</a></li><li class="section"><a href="#offolderstructure" target="_top">oF folder structure</a></li><li class="section"><a href="#theofpantry" target="_top">The oF Pantry</a></li></ul></div></li></ul><ul><li class="chapter"><div class="chapterTitle"><a href="intro_to_graphics.html">Graphics</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#brusheswithbasicshapes" target="_top">Brushes with Basic Shapes</a></li><li class="section"><a href="#brushesfromfreeformshapes" target="_top">Brushes from Freeform Shapes</a></li><li class="section"><a href="#movingtheworld" target="_top">Moving The World</a></li><li class="section"><a href="#nextsteps" target="_top">Next Steps</a></li></ul></div></li></ul><ul><li class="chapter"><div class="chapterTitle"><a href="OOPs!.html">Ooops! = Object Oriented Programming + Classes</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#overview" target="_top">Overview</a></li><li class="section"><a href="#whatisobjectorientedprogramming" target="_top">What is Object Oriented Programming</a></li><li class="section"><a href="#howtobuildyourownclassessimpleclass" target="_top">How to build your own Classes (simple Class)</a></li><li class="section"><a href="#makeanobjectfromyourclass" target="_top">Make an Object from your Class</a></li><li class="section"><a href="#makeobjectsfromyourclass" target="_top">Make objects from your Class</a></li><li class="section"><a href="#makemoreobjectsfromyourclass" target="_top">Make more Objects from your Class</a></li><li class="section"><a href="#makeevenmoreobjectsfromyourclasspropertiesandconstructors" target="_top">Make even more Objects from your Class: properties and constructors</a></li><li class="section"><a href="#makeobjectsonthefly" target="_top">Make Objects on the fly</a></li><li class="section"><a href="#makinganddeleteasyouwishusingvectors" target="_top">Making and delete as you wish - using vectors</a></li><li class="section"><a href="#quickintrotopolymorphisminheritance" target="_top">Quick intro to polymorphism (inheritance)</a></li></ul></div></li></ul><ul><li class="chapter"><div class="chapterTitle"><a href="how_of_works.html">how OF works</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#오픈프레임웍스코드의일반적인패턴설명" target="_top">오픈프레임웍스 코드의 일반적인 패턴 설명</a></li><li class="section"><a href="#setupupdatedraw" target="_top">setup, update, draw</a></li><li class="section"><a href="#클래스" target="_top">클래스</a></li><li class="section"><a href="#함수" target="_top">함수</a></li></ul></div></li></ul></li><li class="group"><div class="groupTitle">Approaches</div><ul><li class="chapter"><div class="chapterTitle"><a href="animation.html">Animation</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#background" target="_top">Background</a></li><li class="section"><a href="#animationinofusefulconcepts" target="_top">Animation in oF / useful concepts:</a></li><li class="section"><a href="#linearmovement" target="_top">Linear movement</a></li><li class="section"><a href="#functionbasedmovement" target="_top">Function based movement</a></li><li class="section"><a href="#simulation" target="_top">Simulation</a></li><li class="section"><a href="#wheretogofurther" target="_top">Where to go further</a></li></ul></div></li></ul><ul><li class="chapter"><div class="chapterTitle"><a href="game_design.html">Experimental Game Development</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#howdogamedevelopersactuallymakegames" target="_top">How do game developers actually make games?</a></li><li class="section"><a href="#sowhatisoscanyway" target="_top">So what is OSC, anyway?</a></li><li class="section"><a href="#ourbasicgameandmakingitnotsobasic" target="_top">Our basic game–and making it not so basic</a></li></ul></div></li></ul><ul><li class="chapter"><div class="chapterTitle"><a href="image_processing_computer_vision.html">image processing and computer vision</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#maybethereisamagicbullet" target="_top">Maybe There is a Magic Bullet</a></li><li class="section"><a href="#preliminariestoimageprocessing" target="_top">Preliminaries to Image Processing</a></li><li class="section"><a href="#이미지처리를얘기하기전에알아두어야할것들" target="_top">이미지처리를 얘기하기 전에 알아두어야 할것들</a></li><li class="section"><a href="#pointprocessingoperationsonimages" target="_top">Point Processing Operations on Images</a></li><li class="section"><a href="#acompleteworkflowbackgroundsubtraction" target="_top">A Complete Workflow: Background Subtraction</a></li><li class="section"><a href="#refinements" target="_top">Refinements</a></li><li class="section"><a href="#suggestionsforfurtherexperimentation" target="_top">Suggestions for Further Experimentation</a></li></ul></div></li></ul></li><li class="group"><div class="groupTitle">I/O</div><ul><li class="chapter"><div class="chapterTitle"><a href="hardware.html">Hardware</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#introduction" target="_top">introduction</a></li><li class="section"><a href="#소개" target="_top">소개</a></li><li class="section"><a href="#gettingstartedwithserialcommunication" target="_top">getting started with serial communication</a></li><li class="section"><a href="#시리얼통신시작하기" target="_top">시리얼 통신 시작 하기</a></li><li class="section"><a href="#digitalandanalogcommunication" target="_top">digital and analog communication</a></li><li class="section"><a href="#디지털과아날로그통신" target="_top">디지털과 아날로그 통신</a></li><li class="section"><a href="#usingserialforcommunicationbetweenarduinoandopenframeworks" target="_top">using serial for communication between arduino and openframeworks</a></li><li class="section"><a href="#lightsoncontrollinghardwareviadmx" target="_top">Lights On - controlling hardware via DMX</a></li></ul></div></li></ul><ul><li class="chapter"><div class="chapterTitle"><a href="sound.html">Sound</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#gettingstartedwithsoundfiles" target="_top">Getting Started With Sound Files</a></li><li class="section"><a href="#gettingstartedwiththesoundstream" target="_top">Getting Started With the Sound Stream</a></li><li class="section"><a href="#why1to1" target="_top">Why -1 to 1?</a></li><li class="section"><a href="#timedomainvsfrequencydomain" target="_top">Time Domain vs Frequency Domain</a></li><li class="section"><a href="#reactingtoliveaudio" target="_top">Reacting to Live Audio</a></li><li class="section"><a href="#synthesizingaudio" target="_top">Synthesizing Audio</a></li><li class="section"><a href="#audiogotchas" target="_top">Audio Gotchas</a></li></ul></div></li></ul><ul><li class="chapter"><div class="chapterTitle"><a href="network.html">Network</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#tcpvsudp" target="_top">TCP vs UDP</a></li><li class="section"><a href="#osc" target="_top">OSC</a></li></ul></div></li></ul></li><li class="group selected"><div class="groupTitle">Graphics</div><ul><li class="chapter"><div class="chapterTitle"><a href="openGL.html">Introducing OpenGL for OF</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#introducing" target="_top">Introducing</a></li><li class="section"><a href="#vertices" target="_top">Vertices</a></li><li class="section"><a href="#meshes" target="_top">Meshes</a></li><li class="section"><a href="#vbos" target="_top">VBOs</a></li><li class="section"><a href="#abasic3dscene" target="_top">A Basic 3D Scene</a></li><li class="section"><a href="#matrices" target="_top">Matrices</a></li><li class="section"><a href="#textures" target="_top">Textures</a></li><li class="section"><a href="#cameras" target="_top">Cameras</a></li></ul></div></li></ul><ul><li class="chapter"><div class="chapterTitle"><a href="lines.html">drawing lines</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#소개" target="_top">소개 ...</a></li><li class="section"><a href="#선그리기" target="_top">선 그리기</a></li><li class="section"><a href="#약간의노이즈abitofnoise" target="_top">약간의 노이즈A bit of noise</a></li><li class="section"><a href="#aweboflines" target="_top">A web of lines</a></li><li class="section"><a href="#makeasmoothlineinmovementina3dspace" target="_top">Make a smooth line in movement in a 3D space</a></li></ul></div></li></ul><ul><li class="chapter"><div class="chapterTitle"><a href="generativemesh.html">Basics of Generating Meshes from an Image</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#basicsofgeneratingmeshesfromanimage1" target="_top">Basics of Generating Meshes from an Image</a></li><li class="section"><a href="#basicsworkingwithofmesh" target="_top">Basics: Working with ofMesh</a></li><li class="section"><a href="#generativemeshusinganimagetodrivethecreationofamesh" target="_top">Generative Mesh: Using an image to drive the creation of a mesh</a></li><li class="section"><a href="#manipulationsaddingeffectsthatmodifythemesh" target="_top">Manipulations: Adding effects that modify the mesh</a></li><li class="section"><a href="#nextsteps" target="_top">Next Steps</a></li></ul></div></li></ul><ul><li class="chapter"><div class="chapterTitle"><a href="advanced_graphics.html">Advanced graphics</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#dimmediatemodevsofpolylineofpath" target="_top">2D, immediate mode vs ofPolyline/ofPath</a></li><li class="section"><a href="#d" target="_top">3D</a></li></ul></div></li></ul><ul><li class="chapter selected"><div class="chapterTitle selected"><a href="shaders.html">Introducing Shaders</a></div><div class="chapterContents selected"><ul><li class="section selected"><a href="#introducing" target="_top">introducing</a></li><li class="section"><a href="#yourfirstshader" target="_top">Your first shader!</a></li><li class="section"><a href="#addinguniforms" target="_top">Adding Uniforms</a></li><li class="section"><a href="#addingsomeinteractivity" target="_top">Adding some interactivity</a></li><li class="section"><a href="#addingtextures" target="_top">Adding Textures</a></li><li class="section"><a href="#alphamasking" target="_top">Alpha Masking</a></li><li class="section"><a href="#multipletextures" target="_top">Multiple Textures</a></li><li class="section"><a href="#offbo" target="_top">ofFbo</a></li><li class="section"><a href="#texturesasdataegdisplacement" target="_top">Textures as Data (e.g. Displacement)</a></li><li class="section"><a href="#theendcongrats" target="_top">The End, Congrats!</a></li></ul></div></li></ul></li><li class="group"><div class="groupTitle">C++</div><ul><li class="chapter"><div class="chapterTitle"><a href="threads.html">threads</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#쓰레드란무엇이고언제사용해야하는가" target="_top">쓰레드란 무엇이고 언제 사용해야 하는가</a></li><li class="section"><a href="#ofthread" target="_top">ofThread</a></li><li class="section"><a href="#스레드와opengl" target="_top">스레드와 openGL</a></li><li class="section"><a href="#ofmutex" target="_top">ofMutex</a></li><li class="section"><a href="#externalthreadsanddoublebuffering" target="_top">External threads and double buffering</a></li><li class="section"><a href="#ofscopedlock" target="_top">ofScopedLock</a></li><li class="section"><a href="#pococondition" target="_top">Poco::Condition</a></li><li class="section"><a href="#conclusion" target="_top">Conclusion</a></li></ul></div></li></ul><ul><li class="chapter"><div class="chapterTitle"><a href="memory.html">memory of C++</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#컴퓨터메모리와변수" target="_top">컴퓨터 메모리와 변수</a></li><li class="section"><a href="#스택변수함수내의변수vs오브젝트내의변수" target="_top">스택 변수, 함수내의 변수 vs 오브젝트내의 변수</a></li><li class="section"><a href="#포인터와레퍼런스" target="_top">포인터와 레퍼런스</a></li><li class="section"><a href="#힙heap영역에서의변수들" target="_top">힙(heap) 영역에서의 변수들</a></li><li class="section"><a href="#메모리구조배열과vector" target="_top">메모리 구조, 배열과 vector</a></li><li class="section"><a href="#다른메모리구조리스트와맵" target="_top">다른 메모리 구조, 리스트와 맵</a></li><li class="section"><a href="#스마트포인터" target="_top">스마트 포인터</a></li></ul></div></li></ul><ul><li class="chapter"><div class="chapterTitle"><a href="stl_vector.html">Introduction to vectors</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#quickreview" target="_top">Quick Review:</a></li><li class="section"><a href="#declaringavector" target="_top">Declaring a vector</a></li><li class="section"><a href="#addingelementstoavector" target="_top">Adding elements to a vector</a></li><li class="section"><a href="#resize" target="_top">resize</a></li><li class="section"><a href="#assign" target="_top">assign</a></li><li class="section"><a href="#accessingelementsofavector" target="_top">Accessing elements of a vector</a></li><li class="section"><a href="#erasingelementsofavector" target="_top">Erasing elements of a vector</a></li><li class="section"><a href="#iterators" target="_top">Iterators</a></li><li class="section"><a href="#sortingandshufflingavector" target="_top">Sorting and shuffling a vector</a></li><li class="section"><a href="#vectorsofobjects" target="_top">Vectors of objects</a></li></ul></div></li></ul><ul><li class="chapter"><div class="chapterTitle"><a href="stl_map.html">let's play with Map, std::map</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#소개map이무엇인가요" target="_top">소개 : map이 무엇인가요?</a></li><li class="section"><a href="#map에값삽입하기" target="_top">map에 값 삽입하기</a></li><li class="section"><a href="#map에서요소삭제하기" target="_top">map에서 요소 삭제하기</a></li><li class="section"><a href="#map을훑기" target="_top">map을 훑기</a></li><li class="section"><a href="#map에서요소찾기" target="_top">map에서 요소 찾기</a></li><li class="section"><a href="#map에오브젝트저장하기" target="_top">map에 오브젝트 저장하기</a></li><li class="section"><a href="#multimap이란무엇인가요" target="_top">multimap이란 무엇인가요?</a></li><li class="section"><a href="#다른유용한메소드들" target="_top">다른 유용한 메소드들</a></li><li class="section"><a href="#추가참고자료역자에의해추가됨" target="_top">추가 참고 자료 (역자에 의해 추가됨)</a></li></ul></div></li></ul><ul><li class="chapter"><div class="chapterTitle"><a href="c++11.html">C++ 11</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#introduction" target="_top">Introduction</a></li><li class="section"><a href="#auto" target="_top">auto</a></li><li class="section"><a href="#forthingthings" target="_top">for (thing : things)</a></li><li class="section"><a href="#override" target="_top">override</a></li><li class="section"><a href="#lambdafunctions" target="_top">Lambda functions</a></li></ul></div></li></ul></li><li class="group"><div class="groupTitle">Advanced topics</div><ul><li class="chapter"><div class="chapterTitle"><a href="math.html">Math: From 1D to 4D</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#onedimensionusingchange" target="_top">One Dimension: Using Change</a></li><li class="section"><a href="#moredimensionssomelinearalgebra" target="_top">More Dimensions: Some Linear Algebra</a></li></ul></div></li></ul></li><li class="group"><div class="groupTitle">Platforms</div><ul><li class="chapter"><div class="chapterTitle"><a href="ios.html">ofxiOS</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#openframeworksoniosdevices" target="_top">OpenFrameworks on iOS devices.</a></li><li class="section"><a href="#intro" target="_top">Intro</a></li><li class="section"><a href="#introtoobjectivec" target="_top">Intro to Objective-C</a></li><li class="section"><a href="#underthehood" target="_top">Under the Hood</a></li><li class="section"><a href="#ofuikit" target="_top">OF &amp; UIKit</a></li><li class="section"><a href="#mediaplaybackandcapture" target="_top">Media Playback and Capture</a></li><li class="section"><a href="#lifehacks" target="_top">Life Hacks</a></li><li class="section"><a href="#appstore" target="_top">App Store</a></li><li class="section"><a href="#casestudies" target="_top">Case Studies</a></li></ul></div></li></ul></li><li class="group"><div class="groupTitle">Tools</div><ul><li class="chapter"><div class="chapterTitle"><a href="version_control_with_git.html">Version control with Git</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#whatisversioncontrolandwhyshouldyouuseit" target="_top">What is version control, and why should you use it?</a></li><li class="section"><a href="#differentversioncontrolsystems" target="_top">Different version control systems</a></li><li class="section"><a href="#introductiontogit" target="_top">Introduction to Git</a></li><li class="section"><a href="#popularguiclients" target="_top">Popular GUI clients</a></li><li class="section"><a href="#conclusion" target="_top">Conclusion</a></li></ul></div></li></ul><ul><li class="chapter"><div class="chapterTitle"><a href="ofSketch.html">ofSketch</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#whatisofsketch" target="_top">What is ofSketch?</a></li><li class="section"><a href="#download" target="_top">Download</a></li><li class="section"><a href="#sketchformat" target="_top">Sketch Format</a></li><li class="section"><a href="#remotecoding" target="_top">Remote Coding</a></li><li class="section"><a href="#future" target="_top">Future</a></li></ul></div></li></ul><ul><li class="chapter"><div class="chapterTitle"><a href="installation_up_4evr_macosx.html">Installation up 4evr</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#step1prepyoursoftwareandthecomputer" target="_top">Step 1: Prep your software and the computer</a></li><li class="section"><a href="#step2bootintoyoursoftware" target="_top">Step 2: Boot into your software</a></li><li class="section"><a href="#step3keepitupchamp" target="_top">Step 3: Keep it up (champ!)</a></li><li class="section"><a href="#step4rebootperiodically" target="_top">Step 4: Reboot periodically</a></li><li class="section"><a href="#step5checkinonitfromafar" target="_top">Step 5: Check in on it from afar.</a></li><li class="section"><a href="#step6testtesttest" target="_top">Step 6: Test, test, test.</a></li><li class="section"><a href="#additionaltipslogging" target="_top">Additional Tips: Logging</a></li><li class="section"><a href="#memoryleakmurderer" target="_top">Memory leak murderer</a></li><li class="section"><a href="#alternateresources" target="_top">Alternate resources:</a></li></ul></div></li></ul><ul><li class="chapter"><div class="chapterTitle"><a href="installation_up_4evr_linux.html">installation up4ever - linux</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#몇가지추가적인팁" target="_top">몇가지 추가적인 팁:</a></li></ul></div></li></ul></li><li class="group"><div class="groupTitle">Case studies</div><ul><li class="chapter"><div class="chapterTitle"><a href="project_eva.html">Choreographies for Humans and Stars</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#projectoverview" target="_top">Project Overview</a></li><li class="section"><a href="#ideationandprototyping" target="_top">Ideation and Prototyping</a></li><li class="section"><a href="#findingthetechnicalsolutions" target="_top">Finding the Technical Solutions</a></li><li class="section"><a href="#developingthevisualizationsoftware" target="_top">Developing the Visualization Software</a></li><li class="section"><a href="#failsafesanddirtyfixes" target="_top">Fail-safes and dirty fixes</a></li><li class="section"><a href="#resultsandreception" target="_top">Results and Reception</a></li></ul></div></li></ul><ul><li class="chapter"><div class="chapterTitle"><a href="project_joel.html">Anthropocene</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#theproject" target="_top">The Project</a></li><li class="section"><a href="#development" target="_top">Development</a></li><li class="section"><a href="#showtime" target="_top">Show time</a></li><li class="section"><a href="#postevent" target="_top">Post Event</a></li><li class="section"><a href="#teamandcredits" target="_top">Team and Credits</a></li><li class="section"><a href="#hardwareselection" target="_top">Hardware selection</a></li></ul></div></li></ul></li></ul>
</nav>
<div class="chapter-content">
<h1 id="introducing-shaders">Introducing Shaders</h1>
<p><em>by Lucasz Karluk, Joshua Noble, Jordi Puig</em></p>
<h2 id="introducing">introducing</h2>
<p>This tutorial comes in two parts: first, this thing, the HTML file and second, nine OF projects that progress along with this tutorial. You can find them in the example folder of your OF download, under <code>examples/shader</code> or <a href="https://github.com/openframeworks/openFrameworks/tree/master/examples/shader" target="_blank">on github</a>. As you read along with this, you should check the code downloads as well because a lot of the code isn't here, but rather is there. You'll notice that all of those project folders have source code and a data folder that contains 3 different kinds of shaders: GL2, GL3, and GLES2. What these are and how they're different from one another will be described below.</p>
<p>You've probably heard somewhere about "shaders", those mystical things that let you render beautiful things at blazing speed. Shaders are not actually mystical but they are a little tricky to get started with at first because they're working with a different part of the computer than you're usually working with in your openFrameworks application: you're working on the Graphics Processing Unit (as opposed to the Central Processing Unit that you're usually working on in OF). To really get the hang of working with shaders, we need to get you a little background on what the GPU is first. So, without further ado, let's go:</p>
<h3 id="the-graphics-pipeline">The graphics pipeline</h3>
<p>The triangle is the root of making 3d or even 2d scenes. We spend a lot of time trying to hide this or make them fancier, flashing, sparklier, etc, but the truth is: pretty much everything is a triangle. The OpenGL pipeline is pretty oriented towards the following workpath: your OF app fills OpenGL-managed memory buffers with arrays of points in 3d space (we're going to call these "vertices") and these "vertices" are projected into screen space, put together into triangles, and finally turned into pixel-sized fragments in a process called "rasterization". Finally, every fragment (read: pixel) is assigned a color value and drawn to the framebuffer so that you can actually see it. When we're talking about shaders, the whole "figuring out where vertices go in screen space" is a Vertex Shader and the whole "assign a color value to each pixel" is a Fragment Shader. The flow looks more or less like this (excuse the over-simplification)</p>
<div class="figure"><div class="inner">
<div style="image"><a href="../images/shaders/images/shaders_pipeline.png" target="_blank"><img alt="The pipeline" src="../images/shaders/images/shaders_pipeline.png"/></a></div><div class="caption">The pipeline</div>
</div></div>
<p>Walking from the upper left to the lower right we have:</p>
<ul>
<li><ol style="list-style-type: decimal">
<li>Our OF application passing some vertex positions and texture coordinates to the graphics card</li>
</ol></li>
<li><ol start="2" style="list-style-type: decimal">
<li>Our Vertex Shader.</li>
</ol></li>
<li><ol start="3" style="list-style-type: decimal">
<li>Primitive Assembly setup of primitives, e.g. triangles, lines, and points</li>
</ol></li>
<li><ol start="4" style="list-style-type: decimal">
<li>Rasterization: interpolation of data (colors, texture coordinates, other varying values) for all pixels</li>
</ol></li>
<li><ol start="5" style="list-style-type: decimal">
<li>Our Fragment Shader</li>
</ol></li>
<li><ol start="6" style="list-style-type: decimal">
<li>Per-pixel ops like discarding pixels for alpha, depth, and other reasons that would cause a pixel to not be drawn</li>
</ol></li>
<li><ol start="7" style="list-style-type: decimal">
<li>Off to the framebuffer</li>
</ol></li>
<li><ol start="8" style="list-style-type: decimal">
<li>Onto your screen</li>
</ol></li>
</ul>
<p>Let's get more specific.</p>
<h3 id="vertices">Vertices</h3>
<p>Rendering an ofMesh start out as some vertex buffers on the CPU side that get filled with arrays of vertex attributes like colors or positions or texture coordinates. These attributes are used as the inputs into the vertex shader, this is what you're working with in your vertex shader. When you call draw() on an ofMesh the indexes control how the vertices get assembled into triangles later on.</p>
<h3 id="the-vertex-shader">The vertex shader</h3>
<p>The GPU begins by reading each selected vertex out of the vertex array and running it through the vertex shader, a program that takes a set of vertex attributes as inputs and outputs a new set of attributes, referred to as varying values, that get fed to the rasterizer. At a minimum, the vertex shader calculates the projected position of the vertex in screen space. The vertex shader can also generate other varying outputs, such as a color or texture coordinates, for the rasterizer to blend across the surface of the triangles connecting the vertex.</p>
<h3 id="the-fragment-shader">The fragment shader</h3>
<p>The generated fragments then pass through another program called the fragment shader. The fragment shader receives the varying values output by the vertex shader and interpolated by the rasterizer as inputs. It outputs color and depth values that then get drawn into the framebuffer. Common fragment shader operations include texture mapping and lighting. Since the fragment shader runs independently for every pixel drawn, it can perform the most sophisticated special effects; however, it is also the most performance-sensitive part of the graphics pipeline.</p>
<h3 id="glsl">GLSL</h3>
<p>Now that we've kinda glossed over the vertex and fragment shaders, you might be asking: "yes, those sound great, but how do I use them?" Answer: Graphics Language Shading Language or GLSL (double points for double "Language", right?). GLSL is a high-level programming language that’s similar to C/C++ for several parts of the graphics card. With GLSL, you can code short programs, called shaders, which are executed on the GPU. A shading language is a special programming language adapted to easily map on shader programming. It doesn't look trememndously different from what you see in the OF math classes: float, vec4, mat4, and so on. Because of the various target markets of 3-D graphics, different shading languages have been developed, but we're only focusing on GLSL in this tutorial. GLSL shaders themselves are a set of strings that are passed to the graphics card drivers for compilation from within an application using the OpenGL API’s entry points. Shaders can be created on the fly from within an application or read in as text files, but they must be sent to the driver in the form of a text string.</p>
<p>In OF we load our shaders into ofShader objects and I'm going to drive-by lay out the most important elements of that object:</p>
<p><em>load()</em> - load a shader from two (or three) files: a .vert file and a .frag file.</p>
<p><em>begin()</em> - start using your shader to alter all the drawing that your application is doing</p>
<p><em>end()</em> - stop using your shader to alter all the drawing that your application is doing</p>
<p>You can load shader programs into your ofShader object using <em>shader.load()</em> or just use strings from your application with <em>shader.setupShaderFromSource()</em>, passing body of your shader in a string as a second parameter using STRINGIFY macro and linking it with <em>shader.linkProgram()</em>. Either way is a-ok.</p>
<p>Before we go get into trouble, there's something that I want to explain that might not make sense right at first but is fairly important to acknoweldge and is not so important to deeply grok at first: our examples use OpenGL3 mostly and to use OpenGL3 in OF you need to alter your main.cpp file. The main files in the tutorial download all look like this:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include "ofMain.h"</span>
<span class="ot">#include "ofApp.h"</span>

<span class="dt">int</span> main( ){
    ofGLFWWindowSettings settings;
    settings.setGLVersion(<span class="dv">3</span>, <span class="dv">2</span>); <span class="co">//we define the OpenGL version we want to use</span>
    settings.width = <span class="dv">1024</span>;
    settings.height = <span class="dv">768</span>;
    ofCreateWindow(settings);
    <span class="co">// this kicks off the running of my app</span>
    ofRunApp(<span class="kw">new</span> ofApp());
}</code></pre>
<p>Did you catch that? There's a new setting object that lets you define the OpenGL version and the dimension of the window.</p>
<p>Now, what OpenGL3 is and how it's going to change the way that you think about code and graphics on your computer isn't a topic for this tutorial, but if you want to look up some tutorials on that <a href="http://www.youtube.com/watch?v=XMgfddy7S7Q" target="_blank">please do so</a>. We're working on an OpenGL tutorial but for the the moment we're going to stick with shaders. The OpenGL3 shader which confusingly uses GLSL 1.5, has the following at the top:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="er">#version 150</span></code></pre>
<p>The OpenGL2 version of a shader (confusing, GLSL 1.2), does not have a define above it (though you can use one "#version 120"). Most graphics cards support OpenGL3 but some do not. You can always run the glInfoExample in examples/gl to see what your computer supports if you run into trouble or are just curious. Finally, we have OpenGL ES 2, which is what is supported on Android, iOS, and which you might be familar with from WebGL. It doesn't have a declaration at the top, but you'll notice something in most GLES shaders:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">precision highp <span class="dt">float</span>;</code></pre>
<p>The differences between the shaders aren't major but they exist, however it's more important to know that they exist than to have a line by line description of what's different between the three. In this tutorial all the shader examples are in the same folder so you'll seee increasingly little code in the tutorials as we go on because we don't want to waste too much space repeating stuff and you'll be such a pro by the end of this that you won't need all that code repeated anyways.</p>
<h2 id="yourfirstshader">Your first shader!</h2>
<p>Let's take a look at a very simple example to help you get going with it. First we'll look at the OF side of things:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">
<span class="dt">void</span> ofApp::setup(){
  <span class="er"># Depending on the OpenGL version that your hardware supports, you have to load the right shader.</span>
  <span class="er"># As the OpenGL version that we have set is 3.2, we will load the shaders for OpenGL 3</span>
  shader.load(<span class="st">"shadersGL3/shader"</span>);
}

<span class="dt">void</span> ofApp::draw(){
    ofSetColor(<span class="dv">255</span>);
    shader.begin();
    ofDrawRectangle(<span class="dv">0</span>, <span class="dv">0</span>, ofGetWidth(), ofGetHeight());
    shader.end();
}</code></pre>
<p>Two big things to note: take a look at <em>setup()</em> and see that thing that says: <em>shader.load("shadersGL3/shader")</em>? That's where we're actually loading the shaders in. OF lets us take a little shrtcut in loading a shader where we just tell OF what folder we're loading the shaders out of and what both files are named and we're off to the races. Those files are actualy called shader.vert (that's the vertex shader) and shader.frag (that's the fragment shader) so they're both going to be loaded with that single call. If you have files that are named separately you can always just use this:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">shader.load(<span class="st">"myCrazyVertFile.vert"</span>, <span class="st">"myCrazyFragFile.frag"</span>);</code></pre>
<p>It's up to you, go with your heart. Our version of it above is a little messy because we're loading one of three different renderees depending on whether you're on an iPhone, an old school computer or a new school computer. Even though we have shaders for all three cases, we're going to be explaining the OpenGL3 example mostly because it's probably the easiest to understand at first.</p>
<p>Next, note how the <em>draw()</em> method contains <em>shader.begin()</em> and <em>shader.end()</em>? That's how we tell our renderer that we want to have all the vertices and textures and fragments go through our shader rather than just being passed directly to the framebuffer. That's about all there is in our application.</p>
<p>Alright, onto the shaders themselves. In our tutorial examples, these live in the data folder of your application, along with images, fonts, and other data that you might want to load into your application. You can also have a shader just as a string in your applciation but we thought it might be nicer to see them in a separte folder so you can work with them outside of your OF app.</p>
<p>Here's the vertex shader, the first one that will be called in each <em>draw()</em> of our application.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">
<span class="co">// vertex shader</span>

<span class="er">#version 150</span>

uniform mat4 modelViewProjectionMatrix;
in vec4 position;

<span class="dt">void</span> main(){
    gl_Position = modelViewProjectionMatrix * position;
}</code></pre>
<p>Next is the fragment shader which is called to determine the colors for each pixel in our application.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">
<span class="co">// fragment shader</span>

<span class="er">#version 150</span>

out vec4 outputColor;

<span class="dt">void</span> main()
{
    <span class="co">// gl_FragCoord contains the window relative coordinate for the fragment.</span>
    <span class="co">// we use gl_FragCoord.x position to control the red color value.</span>
    <span class="co">// we use gl_FragCoord.y position to control the green color value.</span>
    <span class="co">// please note that all r, g, b, a values are between 0 and 1.</span>

    <span class="dt">float</span> windowWidth = <span class="fl">1024.0</span>;
    <span class="dt">float</span> windowHeight = <span class="fl">768.0</span>;

    <span class="dt">float</span> r = gl_FragCoord.x / windowWidth;
    <span class="dt">float</span> g = gl_FragCoord.y / windowHeight;
    <span class="dt">float</span> b = <span class="fl">1.0</span>;
    <span class="dt">float</span> a = <span class="fl">1.0</span>;
    outputColor = vec4(r, g, b, a);
}</code></pre>
<p>That should look like the following when you run it:</p>
<div class="figure"><div class="inner">
<div style="image"><a href="../images/shaders/images/001.png" target="_blank"><img alt="IMG" src="../images/shaders/images/001.png"/></a></div><div class="caption">IMG</div>
</div></div>
<p>Let's break some of the things in there down a little bit. At the top of the fragment and vertex shaders you can see a lot of "uniforms". A uniform is a value passed to each shader from your program that sets some additional values that you use in each stage of your shading. Uniform variables act as constants, at least for the duration of your OF applications <em>draw()</em> method. Your OF application feeds these variables to the graphics pipeline so that they're accessible in both stages of shading. Any shader can access any uniform variable as long as it declares the variable, like we do in both shaders in our example. Note though that these variables are read-only in the shaders. If you want to update the value of a uniform, you can do it in your OF application by calling:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">shader.setUniform1f(<span class="st">"myUniform"</span>, <span class="fl">1.f</span>);</code></pre>
<p>That's how you set a uniform like this:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">uniform <span class="dt">float</span> myUniform;</code></pre>
<p>You can set several different kinds of uniforms, vec3, vec4, mat4, even structs. There's one uniform in the <em>ofShader</em> that's already setup for you: <em>modelViewProjectionMatrix</em>.</p>
<h3 id="the-vertex-shader-1">The vertex shader</h3>
<p><em>modelViewProjectionMatrix</em> - This is actually a value passed in from OF. You can tell that because it's got a "uniform" in front of it. This means that it's passed in for each vertex with exactly the same value.</p>
<p>Next up in our vertex shader is a different kind of variable: <em>in vec4 position</em>. This is called an attribute and every vertex has a different one. That's helpful when you want to have lots of vertices that aren't all in the same place. Each one having its own position means that you can access the location of each vertex within the shader and use it in a calculation or even modify it in place. There are several different kinds of attributes for different kinds of objects in OF: position, color, or texture coordinates, all of which are handy for making complex geometery and shading them.</p>
<p><em>position</em> - This is also a value passed in from OF but you'll notice that it has an "in" at the front of it, which means that the value passed in is different for each vertex because the each vertex has a slightly different position. These are called attributes and they're all set up when the ofMesh is created and each value is set when they're being drawn.</p>
<p><em>gl_Position</em> - This is what comes out of the vertex shader. It's a variable with a fixed role: pass the position of the vertex to the triangle assembly. "Triangle assembly" is when the GPU connects vertices to form triangles. It does this by taking the vertices in the order specified by the element array and grouping them into sets of three that then either create triangle strips or triangle fans.</p>
<h3 id="the-fragment-shader-1">The fragment shader</h3>
<p><em>gl_FragCoord</em> - This is the location of the fragment in screen space. This is how you know where each pixel is on your screen. In our application we're using it to figure out what color to put for the pixel:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">float</span> r = gl_FragCoord.x / windowWidth;
<span class="dt">float</span> g = gl_FragCoord.y / windowHeight;
<span class="dt">float</span> b = <span class="fl">1.0</span>;
<span class="dt">float</span> a = <span class="fl">1.0</span>;
outputColor = vec4(r, g, b, a);</code></pre>
<p>The <em>gl_FragCoord</em> can also be replaced with an "out" vec2 passed from the vertex shader (confusing, I know). Finally, there's the "out" variable for the fragment shader</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">out vec4 outputColor;</code></pre>
<p>Anything marked "out" goes the next stage in the shading pipeline. For the fragment shader that next stage is to put a pixel into the framebuffer, so you need to one and only one "out" from a fragment shader. A vertex shader can have multiple "out" variables that are just passed to the fragment shader, while a fragment shader is just figuring out what color should be sent on for each pixel based on all the values passed from the vertex shader.</p>
<p>outputColor - the color, described in RGBA, that we want this pixel to be colored.</p>
<p>And that's your first shader. For fun, try commenting out the calls to <em>shader.begin()</em> and <em>shader.end()</em> in the ofApp.cpp <em>draw()</em> to see what happens when there's no shaders in them. Pretty boring right? Good thing we've shaders to keep us entertained. Next, let's move some vertices around.</p>
<h2 id="addinguniforms">Adding Uniforms</h2>
<p>This is going to be a little more fun: we're gonna move stuff around in our shaders. First, the ofApp.cpp. We're just making a plane so we have some nice vertices to play with. The ofPlanePrimitive is perfect for "just some vertices to play with" so let's use that:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">
<span class="ot">#include "ofApp.h"</span>

<span class="dt">void</span> ofApp::setup(){

    <span class="dt">float</span> planeScale = <span class="fl">0.75</span>;
    <span class="dt">int</span> planeWidth = ofGetWidth() * planeScale;
    <span class="dt">int</span> planeHeight = ofGetHeight() * planeScale;
    <span class="dt">int</span> planeGridSize = <span class="dv">20</span>;
    <span class="dt">int</span> planeColumns = planeWidth / planeGridSize;
    <span class="dt">int</span> planeRows = planeHeight / planeGridSize;

    plane.set(planeWidth, planeHeight, planeColumns, planeRows, OF_PRIMITIVE_TRIANGLES);
}</code></pre>
<p>Next up, we're going to make a mouse-reactive color and set the front color of our application using that color. GLSL will have access to the color that is set in our ofColor application through the globalColor variable. This isn't actually a GLSL special object, this is created and updated by OF, just like the modelViewMatrix mat4 that we can use to determine how our 3D world should be laid out.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">
<span class="dt">void</span> ofApp::draw(){

    <span class="dt">float</span> percentX = mouseX / (<span class="dt">float</span>)ofGetWidth();
    percentX = ofClamp(percentX, <span class="dv">0</span>, <span class="dv">1</span>);

    <span class="co">// the mouse/touch X position changes the color of the plane.</span>
    <span class="co">// please have a look inside the frag shader,</span>
    <span class="co">// we are using the globalColor value that OF passes into the shader everytime you call ofSetColor().</span>
    ofColor colorLeft = ofColor::magenta;
    ofColor colorRight = ofColor::cyan;
    ofColor colorMix = colorLeft.getLerped(colorRight, percentX);
    ofSetColor(colorMix);

    shader.begin(); <span class="co">// start shading!</span>

    <span class="co">// a lot of the time you have to pass in variables into the shader.</span>
    <span class="co">// in this case we need to pass it the elapsed time for the sine wave animation.</span>
    shader.setUniform1f(<span class="st">"time"</span>, ofGetElapsedTimef());

    <span class="co">// translate plane into center screen.</span>
    <span class="dt">float</span> tx = ofGetWidth() / <span class="dv">2</span>;
    <span class="dt">float</span> ty = ofGetHeight() / <span class="dv">2</span>;
    ofTranslate(tx, ty);

    <span class="co">// the mouse/touch Y position changes the rotation of the plane.</span>
    <span class="dt">float</span> percentY = mouseY / (<span class="dt">float</span>)ofGetHeight();
    <span class="dt">float</span> rotation = ofMap(percentY, <span class="dv">0</span>, <span class="dv">1</span>, -<span class="dv">60</span>, <span class="dv">60</span>, <span class="kw">true</span>) + <span class="dv">60</span>;
    ofRotate(rotation, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>);

    plane.drawWireframe();

    shader.end(); <span class="co">// end shading!</span>
}</code></pre>
<p>Make note of the <em>ofSetColor(colorMix)</em> call in there. That's actually going to set the color that we <em>can</em> use in our fragment shader. We could also set the "out vec4 color" to any old thing we want, but in this case, we're not going to, because we've got too much fun stuff going on in the vertex shader.</p>
<p>Now, because we have one call to the vertex shader for each vertex, we can play with the location of the vertices before we pass them on to the fragment shader. The <em>gl_Position</em> is what comes out of the vertex shader, so anything we set that to will be the location of the vertex. In this case, we'll just use a little <em>sin()</em> wave action to manipulate it, making a nice wave out of our plane:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">
<span class="er">#version 150</span>

<span class="co">// these are for the programmable pipeline system</span>
uniform mat4 modelViewProjectionMatrix;
in vec4 position;

<span class="co">// the time value is passed into the shader by the OF app.</span>
uniform <span class="dt">float</span> time;


<span class="dt">void</span> main()
{
    <span class="co">// the sine wave travels along the x-axis (across the screen),</span>
    <span class="co">// so we use the x coordinate of each vertex for the calculation,</span>
    <span class="co">// but we displace all the vertex along the y axis (up the screen)/</span>
    <span class="dt">float</span> displacementHeight = <span class="dv">100</span>;
    <span class="dt">float</span> displacementY = sin(time + (position.x / <span class="fl">100.0</span>)) * displacementHeight;

    vec4 modifiedPosition = modelViewProjectionMatrix * position;
    modifiedPosition.y += displacementY;
    gl_Position = modifiedPosition;
}</code></pre>
<p>As you hopefully recall from the last little section, we have one call to the fragment shader per pixel, which means we can play with it as well. That's what we did in the last example, though, to keep things simple in this example we're just using a global color set in a uniform. The thing about that is that we're setting it in the OF application, so that each <em>draw()</em> has a slightly different color based on the mouse position.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">
<span class="er">#version 150</span>
uniform vec4 globalColor;
out vec4 outputColor;

<span class="dt">void</span> main()
{
    outputColor = globalColor;
}</code></pre>
<p>As with the previous example, try commenting out the calls to <em>shader.begin()</em> and <em>shader.end()</em> to see what it looks like without the shader running. Pretty big difference, eh? Let's get a little more vertex-y :)</p>
<h2 id="addingsomeinteractivity">Adding some interactivity</h2>
<p>This is going to let us use the mouse position in our shader to manipulate vertices. We'll pass it in via, you guessed it, a uniform! Since the mouse position is actually two values (x,y) we'll pass it in using <em>shader.setUniform2f()</em>. On the shader side, that means we'll have a "uniform vec2 mousePos" that we can store. The mouse position can be a uniform because it's not changing per vertex, just per draw. We are going to manipulate the value of each vertex based on that mouse position though. First the ofApp draw() method. Look at all those calls to "setUniform()"!</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">
<span class="dt">void</span> ofApp::draw(){

    shader.begin();

    <span class="co">// center screen.</span>
    <span class="dt">float</span> cx = ofGetWidth() / <span class="fl">2.0</span>;
    <span class="dt">float</span> cy = ofGetHeight() / <span class="fl">2.0</span>;

    <span class="co">// the plane is being position in the middle of the screen,</span>
    <span class="co">// so we have to apply the same offset to the mouse coordinates before passing into the shader.</span>
    <span class="dt">float</span> mx = mouseX - cx;
    <span class="dt">float</span> my = mouseY - cy;

    <span class="co">// we can pass in a single value into the shader by using the setUniform1 function.</span>
    <span class="co">// if you want to pass in a float value, use setUniform1f.</span>
    <span class="co">// if you want to pass in a integer value, use setUniform1i.</span>
    shader.setUniform1f(<span class="st">"mouseRange"</span>, <span class="dv">150</span>); <span class="co">// SET A UNIFORM</span>

    <span class="co">// we can pass in two values into the shader at the same time by using the setUniform2 function.</span>
    <span class="co">// inside the shader these two values are set inside a vec2 object.</span>
    shader.setUniform2f(<span class="st">"mousePos"</span>, mx, my);  <span class="co">// SET A UNIFORM</span>

    <span class="co">// color changes from magenta to blue when moving the mouse from left to right.</span>
    <span class="dt">float</span> percentX = mouseX / (<span class="dt">float</span>)ofGetWidth();
    percentX = ofClamp(percentX, <span class="dv">0</span>, <span class="dv">1</span>);
    ofFloatColor colorLeft = ofColor::magenta;
    ofFloatColor colorRight = ofColor::blue;
    ofFloatColor colorMix = colorLeft.getLerped(colorRight, percentX);

    <span class="co">// create a float array with the color values.</span>
    <span class="dt">float</span> mouseColor[<span class="dv">4</span>] = {colorMix.r, colorMix.g, colorMix.b, colorMix.a};

    <span class="co">// we can pass in four values into the shader at the same time as a float array.</span>
    <span class="co">// we do this by passing a pointer reference to the first element in the array.</span>
    <span class="co">// inside the shader these four values are set inside a vec4 object.</span>
    shader.setUniform4fv(<span class="st">"mouseColor"</span>, &amp;mouseColor[<span class="dv">0</span>]);  <span class="co">// SET A UNIFORM</span>

    ofTranslate(cx, cy);

    plane.drawWireframe();

    shader.end();
}</code></pre>
<p>That's <em>3</em> different kinds of uniforms! A single floating point value (uniform float), an 2 float vector (uniform vec2), and a vector of 4 floating point values (uniform vec4).</p>
<p>Now onto the shaders themselves, starting with the vertex shader</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="er">#version 150</span>

<span class="co">// these are from the programmable pipeline system, no need to do anything, sweet!</span>
uniform mat4 modelViewProjectionMatrix;
in vec4 position;

uniform <span class="dt">float</span> mouseRange;
uniform vec2 mousePos;
uniform vec4 mouseColor;

<span class="dt">void</span> main()
{
    <span class="co">// copy position so we can work with it.</span>
    vec4 pos = position;

    <span class="co">// direction vector from mouse position to vertex position.</span>
    vec2 dir = pos.xy - mousePos;

    <span class="co">// distance between the mouse position and vertex position.</span>
    <span class="dt">float</span> dist =  distance(pos.xy, mousePos);

    <span class="co">// check vertex is within mouse range.</span>
    <span class="kw">if</span>(dist &gt; <span class="fl">0.0</span> &amp;&amp; dist &lt; mouseRange) {

        <span class="co">// normalise distance between 0 and 1.</span>
        <span class="dt">float</span> distNorm = dist / mouseRange;

        <span class="co">// flip it so the closer we are the greater the repulsion.</span>
        distNorm = <span class="fl">1.0</span> - distNorm;

        <span class="co">// make the direction vector magnitude fade out the further it gets from mouse position.</span>
        dir *= distNorm;

        <span class="co">// add the direction vector to the vertex position.</span>
        pos.x += dir.x;
        pos.y += dir.y;
    }

    <span class="co">// finally set the pos to be that actual position rendered</span>
    gl_Position = modelViewProjectionMatrix * pos;
}</code></pre>
<p>Did you catch that? <em>gl_Position</em> is modified by the location of the mouse <em>relative</em> to its own position. Nifty! Now let's just use that mouseColor that we passed in from the <em>ofShader</em> object.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">
<span class="co">// fragment shader</span>

<span class="er">#version 150</span>

out vec4 outputColor;
uniform vec4 mouseColor;

<span class="dt">void</span> main()
{
    outputColor = mouseColor;
}</code></pre>
<p>Now you know how to pass a few different values into a shader and use them to dynamically do some pretty stuff with the vertices. Let's talk about textures next.</p>
<h2 id="addingtextures">Adding Textures</h2>
<p>Let's talk about textures: you know textures as what you see on the screen when you draw your ofImage or a frame from your <em>ofVideo</em> player. Lots of times in shading, for example, in a vertex array, the data is fed to the vertex shader one element at a time and there's no way for the vertex shader to access other elements. A texture, on the other hand, makes its entire contents available to any vertex or fragment shader. Those shaders sample the texture at one (or a hundred) different texture coordinates. This makes it really powerful for passing data into your shader, first, because uploading a texture is (comparatively) really fast and two, because you can access any point in them.</p>
<p>There's one nice little feature wrapped into the OF application: <em>mapTexCoordsFromTexture()</em>. This lets you just pass a texture reference to the plane and auto-calculate where each part of the texture should go. This is nice because it saves you needing to loop through each vertex and assign the texture coordinate. Of course, when you want to start doing tricky things yourself you'll want to do this yourself so you have more control over it, but for a simple ofPlanePrimitive, this is pretty sweet.</p>
<p>The other thing to note is that we're binding the texture in the <em>draw()</em> method before we call <em>shader.begin()</em>. This actually happens automatically when you call <em>ofImage::draw()</em> but since we're not doing that, we need to make sure that the image is available on the graphics card. The thing about ofTexture and textures in general, is that since you can have a lot of them on the graphics card of your computer, it's nice to be able to say which ones you're going to use in your program. The way that you do that is by "binding" the images, really just making sure that the memory that holds your texture is available to your shader. You can bind quite a few textures but for starters we'll just do one.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">
<span class="co">// OF</span>

<span class="ot">#include "ofApp.h"</span>

<span class="dt">void</span> ofApp::setup() {
    <span class="co">// setup</span>
    plane.mapTexCoordsFromTexture(img.getTextureReference());
}

<span class="dt">void</span> ofApp::draw() {

    <span class="co">// bind our texture. in our shader this will now be tex0 by default</span>
    <span class="co">// so we can just go ahead and access it there.</span>
    img.getTextureReference().bind();

    <span class="co">// start our shader, in our OpenGL3 shader this will automagically set</span>
    <span class="co">// up a lot of matrices that we want for figuring out the texture matrix</span>
    <span class="co">// and the modelView matrix</span>
    shader.begin();

    <span class="co">// get mouse position relative to center of screen</span>
    <span class="dt">float</span> mousePosition = ofMap(mouseX, <span class="dv">0</span>, ofGetWidth(), plane.getWidth(), -plane.getWidth(), <span class="kw">true</span>);

    shader.setUniform1f(<span class="st">"mouseX"</span>, mousePosition);

    ofPushMatrix();
    ofTranslate(ofGetWidth()/<span class="dv">2</span>, ofGetHeight()/<span class="dv">2</span>);
    plane.draw();
    ofPopMatrix();

    shader.end();
    img.getTextureReference().unbind();

}</code></pre>
<p>Alright, onto the vertex shader. Nothing too special <em>except</em> that little bit that says: <em>out vec2 varyingtexcoord</em>. That's where we're setting up what we're going to pass to our fragment shader so that the fragment shading program knows which bit of the texture to put at its pixel. You may be wondering: wait, I've got 100 vertices but 1024x768 pixels, how does passing 100 positions from 100 vertices help me manage 1024x768 pixels? Well, hopefully you were wondering that because it's a truly excellent question. The answer is: interpolation! Let's look at a really simple rectangle with a texture:</p>
<p>Each value is interpolated between the vertices. Going from 0,0 to 0,1024 your card just goes ahead and divides the 512 pixels of the image amongst them evenly, meaning that each texture pixel goes on two screen pixels. As you can imagine that kind of looks like crap sometimes, luckily there's lots of way to manage that, unluckily for you we're not going to talk about that here.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">
<span class="er">#version 150</span>

<span class="co">// these are for the programmable pipeline system and are passed in</span>
<span class="co">// by default from OpenFrameworks</span>
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 textureMatrix;
uniform mat4 modelViewProjectionMatrix;

in vec4 position;
in vec4 color;
in vec4 normal;
in vec2 texcoord;
<span class="co">// this is the end of the default functionality</span>

<span class="co">// this is something we're creating for this shader</span>
out vec2 varyingtexcoord;

<span class="co">// this is coming from our C++ code</span>
uniform <span class="dt">float</span> mouseX;

<span class="dt">void</span> main()
{
    <span class="co">// here we move the texture coordinates</span>
    varyingtexcoord = vec2(texcoord.x + mouseX, texcoord.y);

    <span class="co">// send the vertices to the fragment shader</span>
    gl_Position = modelViewProjectionMatrix * position;
}
</code></pre>
<p>The fragment shader simply looks up the location in texture using the vec2 that's passed into it. The texture itself is represented by the sampler2DRect construct. This is the source of a lot of confusion when people get started using shaders in OF becuase there are two kinds of samplers: <em>sampler2DRect</em> and <em>sampler2D</em>. The difference between these two lies in the kind of texture data that you're actually uploading. If your texture is a power of two size where the height and width are both power of two values like 256 or 512 of 1024 or 2048, then you can use a sampler2D to represent your texture data. In OF however, we want to assume that you can use any image size because sometimes images are weird shapes and sizes like 4x1837 or 381x293 and that should be ok to work with. And it is and it works out fine in your shader as long as you use sampler2DRect. The way to get points in that data is the <em>texture()</em> method that takes the <em>sampler2DRect</em> that you're drawing the data from and the texture coordinate of the particular pixel that you want.</p>
<p>You'll notice that the <em>sampler2DRect</em> is called "tex0" and that we didn't actually set that uniform in our OF app. Why is that? The secret is in the <em>setUniformTexture()</em> method, which calls <em>bind()</em> for you. Also, drawing an image, as we do with <em>image.draw(0, 0)</em>, binds the texture as well and since it isn't given a uniform name, it appears as <em>tex0</em>. Confusing? Perhaps, but it's common enough to see that I wanted to call it to your attention. To be explicit, there are three ways of getting a texture into your shader:</p>
<ol style="list-style-type: decimal">
<li>You can bind a texture and access it as <em>tex0</em> if it's the only one bound without a uniform name.</li>
<li>You can call <em>setUniformTexture()</em> and pass a uniform name and the texture itself</li>
<li>You can call <em>image.draw()</em> and access the image as tex0 if it's the only one bound without a uniform name.</li>
</ol>
<p>It's good to know all these because they're there and you'll see them out in the wild.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">
<span class="co">// fragment shader</span>
<span class="er">#version 150</span>

<span class="co">// this is how we receive the texture</span>
uniform sampler2DRect tex0;
in vec2 varyingtexcoord;
out vec4 outputColor;

<span class="dt">void</span> main()
{
    outputColor = texture(tex0, varyingtexcoord);
}
</code></pre>
<p>So, that's one texture, but we can do some much better tricks when we have two textures.</p>
<h2 id="alphamasking">Alpha Masking</h2>
<p>Using multiple textures in a shader isn't hard at all, you just need to make sure that you're passing them into the shader using the <em>setUniformTexture()</em> method. As in the previous example, we're relying on the default <em>tex0</em> but we've added another texture that we're passing in via the <em>setUniformTexture()</em> method.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> ofApp::draw(){

    <span class="co">// draw a white rectangle for background.</span>
    ofDrawRectangle(<span class="dv">0</span>, <span class="dv">0</span>, image.getWidth(), image.getHeight());

    shader.begin();
    shader.setUniformTexture(<span class="st">"imageMask"</span>, imageMask.getTextureReference(), <span class="dv">1</span>);

    image.draw(<span class="dv">0</span>, <span class="dv">0</span>);

    shader.end();
}</code></pre>
<p>The vertex shader for this example is unremarkable, so we're actually going to omit it, but you can, of course, find all three examples in the examples/bin/data folder. The fragment shader though has a little bit of new stuff in it, conceptually speaking. Think of your texture as data and think of each value in that texture as a data point. The "in" of your data is going to be a color and the "out" of your data is also going to be a color but everything in between is pure data manipulation and what that "in" color can represent can be everything from the height of generated landscape geometry to the location of a sprite. In this case, we're using the alpha value of our two different textures to figure out where our mask begins and ends. One texture has a mask with alpha values ranging from 0 to 1 and the other simply has color values with full alpha (e.g. alpha = 1). Multiplying the two alpha values together gets us a masking effect because, well, that's how multiplication works. We build a vec4 out of the color of the main image and the alpha out of the mask image:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">
<span class="er">#version 150</span>

uniform sampler2DRect tex0;
uniform sampler2DRect imageMask;

in vec2 texCoordVarying;

out vec4 outputColor;

<span class="dt">void</span> main()
{
    vec4 texel0 = texture(tex0, texCoordVarying);
    vec4 texel1 = texture(imageMask, texCoordVarying);
    <span class="co">// first three values are the rgb, fourth is the alpha</span>
    outputColor = vec4(texel0.rgb, texel0.a * texel1.a);
}</code></pre>
<p>Voila, you're well on your way to recreating Photoshop. Speaking of which, let's move on to some more serious composition strategies in shaders, in particular, using the OpenFrameworks implementation of Frame Buffer Objects, the <em>ofFbo</em>.</p>
<h2 id="multipletextures">Multiple Textures</h2>
<p>First: what is an FBO? At it's core it’s a container for textures and an optional depth buffer. Kind of like, well, an OpenGL framebuffer, which is what you're normally rendering to. One way to think of it, conceptually correct but technically a bit loose, is that it's another renderer that you can write to. You can draw textures to it, draw 3D or 2D objects to it, render the view of cameras inside of it, all with one key difference: it's just an object. You can have multiple of them, draw all kinds of things inside of them, and then get all the textures out of them to play with in a shader or just draw them directly to the screen. They are, for most purposes, little render buffers and as such, they're excellent for doing multiple shader passes. So, we're going to set up two <em>ofFbo</em> objects and use them to mask textures using different channels, i.e. RGB elements of the textures. You'll see how this works once you run the application. Those textures are, to make it more interesting, coming from an ofCamera and an ofVideoPlayer, that's actually not a big deal to set up. We'll set up the camera and movie first in the setup() method <em>and</em> we'll set up both of the FBO objects that we're going to use:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">
<span class="dt">int</span> camWidth = <span class="dv">320</span>;
<span class="dt">int</span> camHeight = <span class="dv">240</span>;

camera.setVerbose(<span class="kw">false</span>);
camera.initGrabber(camWidth, camHeight);

movie.loadMovie(<span class="st">"movie.mov"</span>);
movie.play();

image.loadImage(<span class="st">"img.jpg"</span>);
imageMask.loadImage(<span class="st">"mask.jpg"</span>);

<span class="co">// say how big you want each FBO to be</span>
fbo.allocate(camWidth, camHeight);
maskFbo.allocate(camWidth, camHeight);</code></pre>
<p>Calling ofFbo::begin() sets the FBO as the render buffer that everything will be rendered to. Conversely, calling <em>ofFbo::end()</em> unsets the FBO as the render buffer that everything will be rendered to.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">
     <span class="co">//------------------------------------------- draw to fbo.</span>
    fbo.begin();
    ofClear(<span class="dv">255</span>, <span class="dv">255</span>, <span class="dv">255</span>, <span class="dv">255</span>);

    shader.begin();
    shader.setUniformTexture(<span class="st">"redTex"</span>, camera.getTextureReference(), <span class="dv">1</span>);
    shader.setUniformTexture(<span class="st">"greenTex"</span>, greenOF, <span class="dv">2</span>);
    shader.setUniformTexture(<span class="st">"blueTex"</span>, movie.getTextureReference(), <span class="dv">3</span>);
    shader.setUniformTexture(<span class="st">"imageMask"</span>, imageMask.getTextureReference(), <span class="dv">4</span>);

    imageMask.draw(<span class="dv">0</span>, <span class="dv">0</span>);

    shader.end();
    fbo.end();</code></pre>
<p>Now we've just drawn the image mask, camera texture, color texture, and movie texture to the ofFbo, which means that none of them will show up until the second fbo object is drawn. So, continuing down the <em>draw()</em> method, we're drawing the camera, the image, the movie, the mask FBO and the final rendered FBO.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">
    ofSetColor(<span class="dv">255</span>);
    camera.draw(<span class="dv">5</span>,<span class="dv">5</span>,<span class="dv">320</span>,<span class="dv">240</span>);
    ofSetColor(ofColor::red);
    ofDrawBitmapString(<span class="st">"RED"</span>, <span class="dv">5+30</span>, <span class="dv">5+30</span>);

    ofSetColor(<span class="dv">255</span>);
    greenOF.draw(<span class="dv">320+10</span>,<span class="dv">5</span>,<span class="dv">320</span>,<span class="dv">240</span>);
    ofSetColor(ofColor::green);
    ofDrawBitmapString(<span class="st">"GREEN"</span>, <span class="dv">320+10+30</span>,<span class="dv">5+30</span>);

    ofSetColor(<span class="dv">255</span>);
    movie.draw(<span class="dv">320</span>*<span class="dv">2+15</span>,<span class="dv">5</span>,<span class="dv">320</span>,<span class="dv">240</span>);
    ofSetColor(ofColor::blue);
    ofDrawBitmapString(<span class="st">"BLUE"</span>, <span class="dv">320</span>*<span class="dv">2+5+30</span>,<span class="dv">5+30</span>);

    ofSetColor(<span class="dv">255</span>);
    imageMask.draw(<span class="dv">320+10</span>,<span class="dv">240+10</span>,<span class="dv">320</span>,<span class="dv">240</span>);
    ofDrawBitmapString(<span class="st">"RGB MASK"</span>, <span class="dv">320+10+30</span>,<span class="dv">240+10+30</span>);

    fbo.draw(<span class="dv">320+10</span>,<span class="dv">240</span>*<span class="dv">2+15</span>,<span class="dv">320</span>,<span class="dv">240</span>);
    ofDrawBitmapString(<span class="st">"Final FBO"</span>, <span class="dv">320+10+30</span>,<span class="dv">240</span>*<span class="dv">2+15+30</span>);
}</code></pre>
<p>So that's getting 4 textures into the shader and then rendering that shader into the FBO to be drawn later. This is a very powerful technique for doing multiple render passes, rendering complex scenes to a texture, what's called "ping-ponging textures", and a range of other techniques for trickery and beautification. Let's look at the fragment shader. Unsurprisingly it has 4 <em>sampler2DRect</em> uniforms declared in it and each of those is queried for its color and then individual channels of those images are used to generate the color for the final output pixel.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">
<span class="er">#version 150</span>

uniform sampler2DRect redTex;
uniform sampler2DRect greenTex;
uniform sampler2DRect blueTex;
uniform sampler2DRect imageMask;

in vec2 texCoordVarying;

out vec4 outputColor;

<span class="dt">void</span> main()
{
    vec4 rTxt = texture(redTex, texCoordVarying);
    vec4 gTxt = texture(greenTex, texCoordVarying);
    vec4 bTxt = texture(blueTex, texCoordVarying);
    vec4 mask = texture(imageMask, texCoordVarying);

    outputColor = vec4(rTxt.r, gTxt.g, bTxt.b, mask.r);
}</code></pre>
<p>In the next example we'll create a pair of ofFbos and make a drawing application out of them.</p>
<h2 id="offbo">ofFbo</h2>
<p>Setup is very similar to the previous example: make two ofFbo objects, allocate them, and then ensure that they're cleared of any junk data that might be living on the graphics card in the memory space that this FBO was just given. This is an important little lesson: graphics cards often don't clear out their memory for you before handing it to you, which means that the junk will show up unless you empty it. This is particualrly true in FBO objects.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">
    backgroundImage.loadImage(<span class="st">"A.jpg"</span>);
    foregroundImage.loadImage(<span class="st">"B.jpg"</span>);
    brushImage.loadImage(<span class="st">"brush.png"</span>);

    <span class="dt">int</span> width = backgroundImage.getWidth();
    <span class="dt">int</span> height = backgroundImage.getHeight();

    maskFbo.allocate(width, height);
    fbo.allocate(width, height);

    <span class="co">// Clear the FBO's</span>
    <span class="co">// otherwise it will bring some junk with it from the memory</span>
    maskFbo.begin();
    ofClear(<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">255</span>);
    maskFbo.end();

    fbo.begin();
    ofClear(<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">255</span>);
    fbo.end();</code></pre>
<p>The <em>draw()</em> method is really just passing data into these two FBO objects:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">
<span class="co">// this is our alpha mask which we draw into.</span>
<span class="kw">if</span>(bBrushDown) {
    maskFbo.begin();

    <span class="dt">int</span> brushImageSize = <span class="dv">50</span>;
    <span class="dt">int</span> brushImageX = mouseX - brushImageSize * <span class="fl">0.5</span>;
    <span class="dt">int</span> brushImageY = mouseY - brushImageSize * <span class="fl">0.5</span>;
    brushImage.draw(brushImageX, brushImageY, brushImageSize, brushImageSize);

    maskFbo.end();
}</code></pre>
<p>Catch that? Just drawing a brush image into the maskFbo as the users drags it around. Next, as in the previous example, the masking FBO is passed right into the shader and then creating a mask of the previous image.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">
<span class="co">// HERE the shader-masking happens</span>
fbo.begin();
<span class="co">// Cleaning everthing with alpha mask on 0 in order to make it transparent by default</span>
ofClear(<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>);

shader.begin();
<span class="co">// here is where the fbo is passed to the shader</span>
shader.setUniformTexture(<span class="st">"maskTex"</span>, maskFbo.getTextureReference(), <span class="dv">1</span> );

backgroundImage.draw(<span class="dv">0</span>, <span class="dv">0</span>);

shader.end();
fbo.end();

<span class="co">// FIRST draw the background image</span>
foregroundImage.draw(<span class="dv">0</span>,<span class="dv">0</span>);

<span class="co">// THEN draw the masked fbo on top</span>
fbo.draw(<span class="dv">0</span>,<span class="dv">0</span>);

<span class="co">//----------------------------------------------------------</span>
ofDrawBitmapString(<span class="st">"Drag the Mouse to draw"</span>, <span class="dv">15</span>,<span class="dv">15</span>);
ofDrawBitmapString(<span class="st">"Press spacebar to clear"</span>, <span class="dv">15</span>, <span class="dv">30</span>);</code></pre>
<p>In the fragment shader all we really need to do is look up any value of the mask texture to determine whether or not we're going to be using it. It doesn't matter that our mask is actually an FBO because it has texture data and that's good enough for our shader. There's one more little trick to call out in this tutorial and that is how the <em>outputColor</em> variable is actually being set with a vec3 and a float. This is totally legal in GLSL. In fact, a float and a <em>vec3</em>, two <em>vec2</em>s, one row of a <em>mat4</em>, anything or combination of things that have 4 values can be used to set a vec4. The same goes for anything/s with 3 values and a <em>vec3</em> and so on and so forth. It makes GLSL code very elegant, though it is a bit strange to get used to at first.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// fragment</span>
<span class="er">#version 150</span>

<span class="co">// these are our textures</span>
uniform sampler2DRect tex0;
uniform sampler2DRect maskTex;

<span class="co">// this comes from the vertex shader</span>
in vec2 texCoordVarying;

<span class="co">// this is the output of the fragment shader</span>
out vec4 outputColor;

<span class="dt">void</span> main()
{
    <span class="co">// get rgb from tex0</span>
    vec3 src = texture(tex0, texCoordVarying).rgb;

    <span class="co">// get alpha from mask</span>
    <span class="dt">float</span> mask = texture(maskTex, texCoordVarying).r;

    <span class="co">//mix the rgb from tex0 with the alpha of the mask</span>
    outputColor = vec4(src , mask);
}</code></pre>
<p>The idea of passing an FBO as data is interesting, but it's more interesting if we just go ahead and actually pass a texture as pure data, which is, unsurprisingly, what we're going to do next.</p>
<h2 id="texturesasdataegdisplacement">Textures as Data (e.g. Displacement)</h2>
<p>In this application we're going to generate some noise data and store it in a texture to then use it as a displacement value to move vertices in our vertex shader. The noise is just generated using ofNoise() and then saved in an ofPixels object, then uploaded to the graphics card in a texture.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> ofApp::update(){
    <span class="dt">float</span> noiseScale = ofMap(mouseX, <span class="dv">0</span>, ofGetWidth(), <span class="dv">0</span>, <span class="fl">0.1</span>);
    <span class="dt">float</span> noiseVel = ofGetElapsedTimef();

    <span class="dt">unsigned</span> <span class="dt">char</span> * pixels = img.getPixels();
    <span class="dt">int</span> w = img.getWidth();
    <span class="dt">int</span> h = img.getHeight();
    <span class="kw">for</span>(<span class="dt">int</span> y=<span class="dv">0</span>; y&lt;h; y++) {
        <span class="kw">for</span>(<span class="dt">int</span> x=<span class="dv">0</span>; x&lt;w; x++) {
            <span class="dt">int</span> i = y * w + x;
            <span class="dt">float</span> noiseVelue = ofNoise(x * noiseScale, y * noiseScale, noiseVel);
            pixels[i] = <span class="dv">255</span> * noiseVelue;
        }
    }
    img.update();
}</code></pre>
<p>The shader itself doesn't need much special and we just add a little bit of rotation to make the view a bit more dynamic. Otherwise though, nothing tricky.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">
<span class="co">// bind our texture. in our shader this will now be tex0 by default</span>
<span class="co">// so we can just go ahead and access it there.</span>
img.getTextureReference().bind();

shader.begin();

ofPushMatrix();

<span class="co">// translate plane into center screen.</span>
<span class="dt">float</span> tx = ofGetWidth() / <span class="dv">2</span>;
<span class="dt">float</span> ty = ofGetHeight() / <span class="dv">2</span>;
ofTranslate(tx, ty);

<span class="co">// the mouse/touch Y position changes the rotation of the plane.</span>
<span class="dt">float</span> percentY = mouseY / (<span class="dt">float</span>)ofGetHeight();
<span class="dt">float</span> rotation = ofMap(percentY, <span class="dv">0</span>, <span class="dv">1</span>, -<span class="dv">60</span>, <span class="dv">60</span>, <span class="kw">true</span>) + <span class="dv">60</span>;
ofRotate(rotation, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>);

plane.drawWireframe();

ofPopMatrix();

shader.end();

ofSetColor(ofColor::white);
img.draw(<span class="dv">0</span>, <span class="dv">0</span>);</code></pre>
<p>Unlike the last few instances, all the interesting stuff in this example is happening in the vertex shader since as you might have guessed from the name of the example, displacement is primarily a geometry based action rather than a pixel-shading based one. As I've mentioned elsehwere, the handy thing about texture data is that it's available everywhere all at the same time, even in the vertex shader. The <em>gl_Position</em> variable is modified using the <em>r</em> value of the texture at the texture coordinate passed in from the ofPlanePrimitive and that's really all the trickery there is.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="er">#version 150</span>

<span class="co">// these are from the programmable pipeline system</span>
uniform mat4 modelViewProjectionMatrix;
in vec4 position;
in vec2 texcoord;

<span class="co">// this is how we receive the texture</span>
uniform sampler2DRect tex0;

out vec2 texCoordVarying;

<span class="dt">void</span> main()
{
    <span class="co">// get the position of the vertex relative to the modelViewProjectionMatrix</span>
    vec4 modifiedPosition = modelViewProjectionMatrix * position;

    <span class="co">// we need to scale up the values we get from the texture</span>
    <span class="dt">float</span> scale = <span class="dv">100</span>;

    <span class="co">// here we get the red channel value from the texture</span>
    <span class="co">// to use it as vertical displacement</span>
    <span class="dt">float</span> displacementY = texture(tex0, texcoord).r;

    <span class="co">// use the displacement we created from the texture data</span>
    <span class="co">// to modify the vertex position</span>
    modifiedPosition.y += displacementY * scale;

    <span class="co">// this is the resulting vertex position</span>
    gl_Position = modifiedPosition;

    <span class="co">// pass the texture coordinates to the fragment shader</span>
    texCoordVarying = texcoord;
}</code></pre>
<p>Finally, we'll look at creating a blur effect using two shaders and two FBOs.</p>
<p><a name="blurring" target="_blank"></a> ##Blurring</p>
<p>Blurring is one of the best ways to start thinking about multi-pass shading, that is, using multiple shaders in a single application to do multiple passes. Because GLSL (and GPU computing in general for that matter) is so heavily optimized towards doing specific types of operations on discrete blocks of memory, sometimes it makes more sense and gets you better performance to do multiple shading passes rather than put branching logic in your shaders. Blurring is one such operation where, though there are complex techniques for doing it in a single pass, is easier to break into two passes: an X pass and a Y pass. Making two shaders is pretty simple: declare two ofShader objects and then load two shaders into them.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">
shaderBlurX.load(<span class="st">"shadersGL3/shaderBlurX"</span>);
shaderBlurY.load(<span class="st">"shadersGL3/shaderBlurY"</span>);</code></pre>
<p>In the draw() we're going to create two <em>ofFbo</em>s to draw into, run our <em>shaderBlurX</em> program on the first, draw it into the second, and then run our shaderBlurY program on the second. This is called "ping-ponging" and it's a very powerful way to create complex effects in multiple stages that is, particularly when you're using FBO objects, comparatively very fast and very effective.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">
<span class="dt">void</span> ofApp::draw(){

    <span class="dt">float</span> blur = ofMap(mouseX, <span class="dv">0</span>, ofGetWidth(), <span class="dv">0</span>, <span class="dv">10</span>, <span class="kw">true</span>);

    <span class="co">//----------------------------------------------------------</span>
    fboBlurOnePass.begin();

    shaderBlurX.begin();
    shaderBlurX.setUniform1f(<span class="st">"blurAmnt"</span>, blur);

    image.draw(<span class="dv">0</span>, <span class="dv">0</span>);

    shaderBlurX.end();

    fboBlurOnePass.end();

    <span class="co">//----------------------------------------------------------</span>
    fboBlurTwoPass.begin();

    shaderBlurY.begin();
    shaderBlurY.setUniform1f(<span class="st">"blurAmnt"</span>, blur);

    fboBlurOnePass.draw(<span class="dv">0</span>, <span class="dv">0</span>);

    shaderBlurY.end();

    fboBlurTwoPass.end();

    <span class="co">//----------------------------------------------------------</span>
    ofSetColor(ofColor::white);
    fboBlurTwoPass.draw(<span class="dv">0</span>, <span class="dv">0</span>);
}</code></pre>
<p>This is a pretty canonical blur fragment shader, you'll see it or something very similar to it in lots of different sources. Really you're just creating an image kernel and looking at different texels around the texture to figure out what an averaged or blurred approximation of each pixel would look like. This is another one of the places where having access to the entire texture at a given time is very helpful and lets us create complex effects very quickly by doing image processing on the graphics card. You'll notice that this is just the X pass. The Y pass looks almost identical, but with Y values in the <em>vec2</em> rather than X values. Why two passes? Let's look at the math: the computational cost for the multi-stage blur shader is 18 (9 + 9) texture look-up operations. The computational cost for the shader if it's all blured in one pass is 9*9 or 81 texture look-up operations. You can see how it'd save some time to do two passes, no?</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">
<span class="er">#version 150</span>

uniform sampler2DRect tex0;
uniform <span class="dt">float</span> blurAmnt;
in vec2 texCoordVarying;
out vec4 outputColor;

<span class="dt">void</span> main()
{
    vec4 color;

    color += <span class="fl">1.0</span> * texture(tex0, texCoordVarying + vec2(blurAmnt * -<span class="fl">4.0</span>, <span class="fl">0.0</span>));
    color += <span class="fl">2.0</span> * texture(tex0, texCoordVarying + vec2(blurAmnt * -<span class="fl">3.0</span>, <span class="fl">0.0</span>));
    color += <span class="fl">3.0</span> * texture(tex0, texCoordVarying + vec2(blurAmnt * -<span class="fl">2.0</span>, <span class="fl">0.0</span>));
    color += <span class="fl">4.0</span> * texture(tex0, texCoordVarying + vec2(blurAmnt * -<span class="fl">1.0</span>, <span class="fl">0.0</span>));

    color += <span class="fl">5.0</span> * texture(tex0, texCoordVarying + vec2(blurAmnt, <span class="dv">0</span>));

    color += <span class="fl">4.0</span> * texture(tex0, texCoordVarying + vec2(blurAmnt * <span class="fl">1.0</span>, <span class="fl">0.0</span>));
    color += <span class="fl">3.0</span> * texture(tex0, texCoordVarying + vec2(blurAmnt * <span class="fl">2.0</span>, <span class="fl">0.0</span>));
    color += <span class="fl">2.0</span> * texture(tex0, texCoordVarying + vec2(blurAmnt * <span class="fl">3.0</span>, <span class="fl">0.0</span>));
    color += <span class="fl">1.0</span> * texture(tex0, texCoordVarying + vec2(blurAmnt * <span class="fl">4.0</span>, <span class="fl">0.0</span>));

    color /= <span class="fl">25.0</span>;

    outputColor = color;
}</code></pre>
<h2 id="theendcongrats">The End, Congrats!</h2>
<p>If you've made it all the way to end of this, thanks and congratulations to you. A few further resources for you, if you're interested:</p>
<ul>
<li><a href="http://fgiesen.wordpress.com/2011/07/09/a-trip-through-the-graphics-pipeline-2011-index/" target="_blank">A trip through the graphics pipeline</a></li>
<li><a href="http://www.amazon.com/Graphics-Shaders-Theory-Practice-Edition/dp/1568814348" target="_blank">Graphics Shaders Theory and Practice</a></li>
<li><a href="http://www.amazon.com/OpenGL-4-0-Shading-Language-Cookbook/dp/1849514763" target="_blank">OpenGL 4.0 Shading Language Cookbook</a></li>
</ul>
<p>Check out the rest of the examples, particularly the GL ones, ask questions and share your work on the forum, and above all have fun.</p>
<div class="footer">
<div id="prev_chapter"><a href="advanced_graphics.html">&lt; Advanced graphics</a></div>
<div id="next_chapter"><a href="threads.html">threads &gt;</a></div>
</div>
<div id="help"><i>이 책은 현재 번역작업중이므로, 오탈자나 여러 오류가 있을 수 있습니다. 원본 영문의 내용도 활발히 수정중임 또한 감안해주시기 바랍니다. 오류 발견시 <a href="https://github.com/openframeworks/ofbook" target="_blank">이곳</a>에 글을 남겨주시기 바라며, 한글 번역에 관한 내용은 <a href="http://forum.openframeworks.kr/" target="_blank">오픈프레임웍스한글포럼</a>에의견을 남겨주시기 바랍니다.</i></div>
</div>
</div>
</body>
</html>
