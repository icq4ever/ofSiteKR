<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<meta content="text/css" http-equiv="Content-Style-Type"/>
<meta content="pandoc" name="generator"/>
<title>ofBook - Ooops! = Object Oriented Programming + Classes</title>
<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
  </style>
<link href="../style/bootstrap.min.css" rel="stylesheet">
<link href="../style/style.css" rel="stylesheet" type="text/css"/>
<link href="http://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic,700italic|Merriweather:400,300,300italic,400italic,700,900,700italic,900italic" rel="stylesheet" type="text/css">
<script src="../javascript/jquery-1.8.3.min.js"></script>
<script src="../javascript/bootstrap.min.js"></script>
<script src="../javascript/navbar.js"></script>
</link></link></head>
<body>
<div class="banner">
<div class="content-wrapper">
<b>Work in progress!</b>
        This is a preliminary version of ofBook, a collaboratively written book about openFrameworks.  Please post any issues, suggestions, comments on our <a href="https://github.com/openframeworks/ofBook/" target="_blank">repo</a>.
    </div>
</div>
<div class="content-wrapper">
<nav role="navigation">
<ul id="nav-parts"><li class="group"><div class="groupTitle">Foreword</div><ul><li class="chapter"><div class="chapterTitle"><a href="foreword.html">foreword</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#책에관하여" target="_top">책에 관하여</a></li><li class="section"><a href="#credits" target="_top">Credits</a></li></ul></div></li></ul></li><li class="group selected"><div class="groupTitle">Basics</div><ul><li class="chapter"><div class="chapterTitle"><a href="of_philosophy.html">Philosophy</a></div></li></ul><ul><li class="chapter"><div class="chapterTitle"><a href="cplusplus_basics.html">C++ Language Basics</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#lookalive" target="_top">Look Alive!</a></li><li class="section"><a href="#iteration" target="_top">Iteration</a></li><li class="section"><a href="#compilingmyfirstapp" target="_top">Compiling My First App</a></li><li class="section"><a href="#beyondhelloworld" target="_top">Beyond Hello World</a></li><li class="section"><a href="#functions" target="_top">Functions</a></li><li class="section"><a href="#customfunctions" target="_top">Custom Functions</a></li><li class="section"><a href="#encapsulationofcomplexity" target="_top">Encapsulation of Complexity</a></li><li class="section"><a href="#variablespart1" target="_top">Variables (part 1)</a></li><li class="section"><a href="#conclusion" target="_top">Conclusion</a></li><li class="section"><a href="#ps" target="_top">PS.</a></li></ul></div></li></ul><ul><li class="chapter"><div class="chapterTitle"><a href="setup_and_project_structure.html">oF structure</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#firstthingsfirst" target="_top">First things first</a></li><li class="section"><a href="#welcometoyournewkitchen" target="_top">Welcome to your new kitchen</a></li><li class="section"><a href="#runningexamples" target="_top">Running examples</a></li><li class="section"><a href="#offolderstructure" target="_top">oF folder structure</a></li><li class="section"><a href="#theofpantry" target="_top">The oF Pantry</a></li></ul></div></li></ul><ul><li class="chapter"><div class="chapterTitle"><a href="intro_to_graphics.html">Graphics</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#brusheswithbasicshapes" target="_top">Brushes with Basic Shapes</a></li><li class="section"><a href="#brushesfromfreeformshapes" target="_top">Brushes from Freeform Shapes</a></li><li class="section"><a href="#movingtheworld" target="_top">Moving The World</a></li><li class="section"><a href="#nextsteps" target="_top">Next Steps</a></li></ul></div></li></ul><ul><li class="chapter selected"><div class="chapterTitle selected"><a href="OOPs!.html">Ooops! = Object Oriented Programming + Classes</a></div><div class="chapterContents selected"><ul><li class="section selected"><a href="#overview" target="_top">Overview</a></li><li class="section"><a href="#whatisobjectorientedprogramming" target="_top">What is Object Oriented Programming</a></li><li class="section"><a href="#howtobuildyourownclassessimpleclass" target="_top">How to build your own Classes (simple Class)</a></li><li class="section"><a href="#makeanobjectfromyourclass" target="_top">Make an Object from your Class</a></li><li class="section"><a href="#makeobjectsfromyourclass" target="_top">Make objects from your Class</a></li><li class="section"><a href="#makemoreobjectsfromyourclass" target="_top">Make more Objects from your Class</a></li><li class="section"><a href="#makeevenmoreobjectsfromyourclasspropertiesandconstructors" target="_top">Make even more Objects from your Class: properties and constructors</a></li><li class="section"><a href="#makeobjectsonthefly" target="_top">Make Objects on the fly</a></li><li class="section"><a href="#makinganddeleteasyouwishusingvectors" target="_top">Making and delete as you wish - using vectors</a></li><li class="section"><a href="#quickintrotopolymorphisminheritance" target="_top">Quick intro to polymorphism (inheritance)</a></li></ul></div></li></ul><ul><li class="chapter"><div class="chapterTitle"><a href="how_of_works.html">how OF works</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#오픈프레임웍스코드의일반적인패턴설명" target="_top">오픈프레임웍스 코드의 일반적인 패턴 설명</a></li><li class="section"><a href="#setupupdatedraw" target="_top">setup, update, draw</a></li><li class="section"><a href="#클래스" target="_top">클래스</a></li><li class="section"><a href="#함수" target="_top">함수</a></li></ul></div></li></ul></li><li class="group"><div class="groupTitle">Approaches</div><ul><li class="chapter"><div class="chapterTitle"><a href="animation.html">Animation</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#background" target="_top">Background</a></li><li class="section"><a href="#animationinofusefulconcepts" target="_top">Animation in oF / useful concepts:</a></li><li class="section"><a href="#linearmovement" target="_top">Linear movement</a></li><li class="section"><a href="#functionbasedmovement" target="_top">Function based movement</a></li><li class="section"><a href="#simulation" target="_top">Simulation</a></li><li class="section"><a href="#wheretogofurther" target="_top">Where to go further</a></li></ul></div></li></ul><ul><li class="chapter"><div class="chapterTitle"><a href="game_design.html">Experimental Game Development</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#howdogamedevelopersactuallymakegames" target="_top">How do game developers actually make games?</a></li><li class="section"><a href="#sowhatisoscanyway" target="_top">So what is OSC, anyway?</a></li><li class="section"><a href="#ourbasicgameandmakingitnotsobasic" target="_top">Our basic game–and making it not so basic</a></li></ul></div></li></ul><ul><li class="chapter"><div class="chapterTitle"><a href="image_processing_computer_vision.html">image processing and computer vision</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#maybethereisamagicbullet" target="_top">Maybe There is a Magic Bullet</a></li><li class="section"><a href="#preliminariestoimageprocessing" target="_top">Preliminaries to Image Processing</a></li><li class="section"><a href="#이미지처리를얘기하기전에알아두어야할것들" target="_top">이미지처리를 얘기하기 전에 알아두어야 할것들</a></li><li class="section"><a href="#pointprocessingoperationsonimages" target="_top">Point Processing Operations on Images</a></li><li class="section"><a href="#acompleteworkflowbackgroundsubtraction" target="_top">A Complete Workflow: Background Subtraction</a></li><li class="section"><a href="#refinements" target="_top">Refinements</a></li><li class="section"><a href="#suggestionsforfurtherexperimentation" target="_top">Suggestions for Further Experimentation</a></li></ul></div></li></ul></li><li class="group"><div class="groupTitle">I/O</div><ul><li class="chapter"><div class="chapterTitle"><a href="hardware.html">Hardware</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#introduction" target="_top">introduction</a></li><li class="section"><a href="#소개" target="_top">소개</a></li><li class="section"><a href="#gettingstartedwithserialcommunication" target="_top">getting started with serial communication</a></li><li class="section"><a href="#시리얼통신시작하기" target="_top">시리얼 통신 시작 하기</a></li><li class="section"><a href="#digitalandanalogcommunication" target="_top">digital and analog communication</a></li><li class="section"><a href="#디지털과아날로그통신" target="_top">디지털과 아날로그 통신</a></li><li class="section"><a href="#usingserialforcommunicationbetweenarduinoandopenframeworks" target="_top">using serial for communication between arduino and openframeworks</a></li><li class="section"><a href="#lightsoncontrollinghardwareviadmx" target="_top">Lights On - controlling hardware via DMX</a></li></ul></div></li></ul><ul><li class="chapter"><div class="chapterTitle"><a href="sound.html">Sound</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#gettingstartedwithsoundfiles" target="_top">Getting Started With Sound Files</a></li><li class="section"><a href="#gettingstartedwiththesoundstream" target="_top">Getting Started With the Sound Stream</a></li><li class="section"><a href="#why1to1" target="_top">Why -1 to 1?</a></li><li class="section"><a href="#timedomainvsfrequencydomain" target="_top">Time Domain vs Frequency Domain</a></li><li class="section"><a href="#reactingtoliveaudio" target="_top">Reacting to Live Audio</a></li><li class="section"><a href="#synthesizingaudio" target="_top">Synthesizing Audio</a></li><li class="section"><a href="#audiogotchas" target="_top">Audio Gotchas</a></li></ul></div></li></ul><ul><li class="chapter"><div class="chapterTitle"><a href="network.html">Network</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#tcpvsudp" target="_top">TCP vs UDP</a></li><li class="section"><a href="#osc" target="_top">OSC</a></li></ul></div></li></ul></li><li class="group"><div class="groupTitle">Graphics</div><ul><li class="chapter"><div class="chapterTitle"><a href="openGL.html">Introducing OpenGL for OF</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#introducing" target="_top">Introducing</a></li><li class="section"><a href="#vertices" target="_top">Vertices</a></li><li class="section"><a href="#meshes" target="_top">Meshes</a></li><li class="section"><a href="#vbos" target="_top">VBOs</a></li><li class="section"><a href="#abasic3dscene" target="_top">A Basic 3D Scene</a></li><li class="section"><a href="#matrices" target="_top">Matrices</a></li><li class="section"><a href="#textures" target="_top">Textures</a></li><li class="section"><a href="#cameras" target="_top">Cameras</a></li></ul></div></li></ul><ul><li class="chapter"><div class="chapterTitle"><a href="lines.html">drawing lines</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#소개" target="_top">소개 ...</a></li><li class="section"><a href="#선그리기" target="_top">선 그리기</a></li><li class="section"><a href="#약간의노이즈abitofnoise" target="_top">약간의 노이즈A bit of noise</a></li><li class="section"><a href="#aweboflines" target="_top">A web of lines</a></li><li class="section"><a href="#makeasmoothlineinmovementina3dspace" target="_top">Make a smooth line in movement in a 3D space</a></li></ul></div></li></ul><ul><li class="chapter"><div class="chapterTitle"><a href="generativemesh.html">Basics of Generating Meshes from an Image</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#basicsofgeneratingmeshesfromanimage1" target="_top">Basics of Generating Meshes from an Image</a></li><li class="section"><a href="#basicsworkingwithofmesh" target="_top">Basics: Working with ofMesh</a></li><li class="section"><a href="#generativemeshusinganimagetodrivethecreationofamesh" target="_top">Generative Mesh: Using an image to drive the creation of a mesh</a></li><li class="section"><a href="#manipulationsaddingeffectsthatmodifythemesh" target="_top">Manipulations: Adding effects that modify the mesh</a></li><li class="section"><a href="#nextsteps" target="_top">Next Steps</a></li></ul></div></li></ul><ul><li class="chapter"><div class="chapterTitle"><a href="advanced_graphics.html">Advanced graphics</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#dimmediatemodevsofpolylineofpath" target="_top">2D, immediate mode vs ofPolyline/ofPath</a></li><li class="section"><a href="#d" target="_top">3D</a></li></ul></div></li></ul><ul><li class="chapter"><div class="chapterTitle"><a href="shaders.html">Introducing Shaders</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#introducing" target="_top">introducing</a></li><li class="section"><a href="#yourfirstshader" target="_top">Your first shader!</a></li><li class="section"><a href="#addinguniforms" target="_top">Adding Uniforms</a></li><li class="section"><a href="#addingsomeinteractivity" target="_top">Adding some interactivity</a></li><li class="section"><a href="#addingtextures" target="_top">Adding Textures</a></li><li class="section"><a href="#alphamasking" target="_top">Alpha Masking</a></li><li class="section"><a href="#multipletextures" target="_top">Multiple Textures</a></li><li class="section"><a href="#offbo" target="_top">ofFbo</a></li><li class="section"><a href="#texturesasdataegdisplacement" target="_top">Textures as Data (e.g. Displacement)</a></li><li class="section"><a href="#theendcongrats" target="_top">The End, Congrats!</a></li></ul></div></li></ul></li><li class="group"><div class="groupTitle">C++</div><ul><li class="chapter"><div class="chapterTitle"><a href="threads.html">threads</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#쓰레드란무엇이고언제사용해야하는가" target="_top">쓰레드란 무엇이고 언제 사용해야 하는가</a></li><li class="section"><a href="#ofthread" target="_top">ofThread</a></li><li class="section"><a href="#스레드와opengl" target="_top">스레드와 openGL</a></li><li class="section"><a href="#ofmutex" target="_top">ofMutex</a></li><li class="section"><a href="#externalthreadsanddoublebuffering" target="_top">External threads and double buffering</a></li><li class="section"><a href="#ofscopedlock" target="_top">ofScopedLock</a></li><li class="section"><a href="#pococondition" target="_top">Poco::Condition</a></li><li class="section"><a href="#conclusion" target="_top">Conclusion</a></li></ul></div></li></ul><ul><li class="chapter"><div class="chapterTitle"><a href="memory.html">memory of C++</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#컴퓨터메모리와변수" target="_top">컴퓨터 메모리와 변수</a></li><li class="section"><a href="#스택변수함수내의변수vs오브젝트내의변수" target="_top">스택 변수, 함수내의 변수 vs 오브젝트내의 변수</a></li><li class="section"><a href="#포인터와레퍼런스" target="_top">포인터와 레퍼런스</a></li><li class="section"><a href="#힙heap영역에서의변수들" target="_top">힙(heap) 영역에서의 변수들</a></li><li class="section"><a href="#메모리구조배열과vector" target="_top">메모리 구조, 배열과 vector</a></li><li class="section"><a href="#다른메모리구조리스트와맵" target="_top">다른 메모리 구조, 리스트와 맵</a></li><li class="section"><a href="#스마트포인터" target="_top">스마트 포인터</a></li></ul></div></li></ul><ul><li class="chapter"><div class="chapterTitle"><a href="stl_vector.html">Introduction to vectors</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#quickreview" target="_top">Quick Review:</a></li><li class="section"><a href="#declaringavector" target="_top">Declaring a vector</a></li><li class="section"><a href="#addingelementstoavector" target="_top">Adding elements to a vector</a></li><li class="section"><a href="#resize" target="_top">resize</a></li><li class="section"><a href="#assign" target="_top">assign</a></li><li class="section"><a href="#accessingelementsofavector" target="_top">Accessing elements of a vector</a></li><li class="section"><a href="#erasingelementsofavector" target="_top">Erasing elements of a vector</a></li><li class="section"><a href="#iterators" target="_top">Iterators</a></li><li class="section"><a href="#sortingandshufflingavector" target="_top">Sorting and shuffling a vector</a></li><li class="section"><a href="#vectorsofobjects" target="_top">Vectors of objects</a></li></ul></div></li></ul><ul><li class="chapter"><div class="chapterTitle"><a href="stl_map.html">let's play with Map, std::map</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#소개map이무엇인가요" target="_top">소개 : map이 무엇인가요?</a></li><li class="section"><a href="#map에값삽입하기" target="_top">map에 값 삽입하기</a></li><li class="section"><a href="#map에서요소삭제하기" target="_top">map에서 요소 삭제하기</a></li><li class="section"><a href="#map을훑기" target="_top">map을 훑기</a></li><li class="section"><a href="#map에서요소찾기" target="_top">map에서 요소 찾기</a></li><li class="section"><a href="#map에오브젝트저장하기" target="_top">map에 오브젝트 저장하기</a></li><li class="section"><a href="#multimap이란무엇인가요" target="_top">multimap이란 무엇인가요?</a></li><li class="section"><a href="#다른유용한메소드들" target="_top">다른 유용한 메소드들</a></li><li class="section"><a href="#추가참고자료역자에의해추가됨" target="_top">추가 참고 자료 (역자에 의해 추가됨)</a></li></ul></div></li></ul><ul><li class="chapter"><div class="chapterTitle"><a href="c++11.html">C++ 11</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#introduction" target="_top">Introduction</a></li><li class="section"><a href="#auto" target="_top">auto</a></li><li class="section"><a href="#forthingthings" target="_top">for (thing : things)</a></li><li class="section"><a href="#override" target="_top">override</a></li><li class="section"><a href="#lambdafunctions" target="_top">Lambda functions</a></li></ul></div></li></ul></li><li class="group"><div class="groupTitle">Advanced topics</div><ul><li class="chapter"><div class="chapterTitle"><a href="math.html">Math: From 1D to 4D</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#onedimensionusingchange" target="_top">One Dimension: Using Change</a></li><li class="section"><a href="#moredimensionssomelinearalgebra" target="_top">More Dimensions: Some Linear Algebra</a></li></ul></div></li></ul></li><li class="group"><div class="groupTitle">Platforms</div><ul><li class="chapter"><div class="chapterTitle"><a href="ios.html">ofxiOS</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#openframeworksoniosdevices" target="_top">OpenFrameworks on iOS devices.</a></li><li class="section"><a href="#intro" target="_top">Intro</a></li><li class="section"><a href="#introtoobjectivec" target="_top">Intro to Objective-C</a></li><li class="section"><a href="#underthehood" target="_top">Under the Hood</a></li><li class="section"><a href="#ofuikit" target="_top">OF &amp; UIKit</a></li><li class="section"><a href="#mediaplaybackandcapture" target="_top">Media Playback and Capture</a></li><li class="section"><a href="#lifehacks" target="_top">Life Hacks</a></li><li class="section"><a href="#appstore" target="_top">App Store</a></li><li class="section"><a href="#casestudies" target="_top">Case Studies</a></li></ul></div></li></ul></li><li class="group"><div class="groupTitle">Tools</div><ul><li class="chapter"><div class="chapterTitle"><a href="version_control_with_git.html">Version control with Git</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#whatisversioncontrolandwhyshouldyouuseit" target="_top">What is version control, and why should you use it?</a></li><li class="section"><a href="#differentversioncontrolsystems" target="_top">Different version control systems</a></li><li class="section"><a href="#introductiontogit" target="_top">Introduction to Git</a></li><li class="section"><a href="#popularguiclients" target="_top">Popular GUI clients</a></li><li class="section"><a href="#conclusion" target="_top">Conclusion</a></li></ul></div></li></ul><ul><li class="chapter"><div class="chapterTitle"><a href="ofSketch.html">ofSketch</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#whatisofsketch" target="_top">What is ofSketch?</a></li><li class="section"><a href="#download" target="_top">Download</a></li><li class="section"><a href="#sketchformat" target="_top">Sketch Format</a></li><li class="section"><a href="#remotecoding" target="_top">Remote Coding</a></li><li class="section"><a href="#future" target="_top">Future</a></li></ul></div></li></ul><ul><li class="chapter"><div class="chapterTitle"><a href="installation_up_4evr_macosx.html">Installation up 4evr</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#step1prepyoursoftwareandthecomputer" target="_top">Step 1: Prep your software and the computer</a></li><li class="section"><a href="#step2bootintoyoursoftware" target="_top">Step 2: Boot into your software</a></li><li class="section"><a href="#step3keepitupchamp" target="_top">Step 3: Keep it up (champ!)</a></li><li class="section"><a href="#step4rebootperiodically" target="_top">Step 4: Reboot periodically</a></li><li class="section"><a href="#step5checkinonitfromafar" target="_top">Step 5: Check in on it from afar.</a></li><li class="section"><a href="#step6testtesttest" target="_top">Step 6: Test, test, test.</a></li><li class="section"><a href="#additionaltipslogging" target="_top">Additional Tips: Logging</a></li><li class="section"><a href="#memoryleakmurderer" target="_top">Memory leak murderer</a></li><li class="section"><a href="#alternateresources" target="_top">Alternate resources:</a></li></ul></div></li></ul><ul><li class="chapter"><div class="chapterTitle"><a href="installation_up_4evr_linux.html">installation up4ever - linux</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#몇가지추가적인팁" target="_top">몇가지 추가적인 팁:</a></li></ul></div></li></ul></li><li class="group"><div class="groupTitle">Case studies</div><ul><li class="chapter"><div class="chapterTitle"><a href="project_eva.html">Choreographies for Humans and Stars</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#projectoverview" target="_top">Project Overview</a></li><li class="section"><a href="#ideationandprototyping" target="_top">Ideation and Prototyping</a></li><li class="section"><a href="#findingthetechnicalsolutions" target="_top">Finding the Technical Solutions</a></li><li class="section"><a href="#developingthevisualizationsoftware" target="_top">Developing the Visualization Software</a></li><li class="section"><a href="#failsafesanddirtyfixes" target="_top">Fail-safes and dirty fixes</a></li><li class="section"><a href="#resultsandreception" target="_top">Results and Reception</a></li></ul></div></li></ul><ul><li class="chapter"><div class="chapterTitle"><a href="project_joel.html">Anthropocene</a></div><div class="chapterContents"><ul><li class="section selected"><a href="#theproject" target="_top">The Project</a></li><li class="section"><a href="#development" target="_top">Development</a></li><li class="section"><a href="#showtime" target="_top">Show time</a></li><li class="section"><a href="#postevent" target="_top">Post Event</a></li><li class="section"><a href="#teamandcredits" target="_top">Team and Credits</a></li><li class="section"><a href="#hardwareselection" target="_top">Hardware selection</a></li></ul></div></li></ul></li></ul>
</nav>
<div class="chapter-content">
<h1 id="ooops-object-oriented-programming-classes">Ooops! = Object Oriented Programming + Classes</h1>
<p><em>by <a href="http://www.rux-werx-here.net/" target="_blank">Rui Pereira</a></em></p>
<h2 id="overview">Overview</h2>
<p>This tutorial is a quick and practical introduction to Object Oriented Programming in openFrameworks and a how-to guide to build and use your own classes. By the end of this chapter you should understand how to create your own objects and have a lot of balls bouncing on your screen!</p>
<div class="figure"><div class="inner">
<div style="image"><a href="../images/OOPs!/images/balls_screenshot.png" target="_blank"><img alt="balls screenshot" src="../images/OOPs!/images/balls_screenshot.png" title="balls screenshot"/></a></div><div class="caption">balls screenshot</div>
</div></div>
<h2 id="whatisobjectorientedprogramming">What is Object Oriented Programming</h2>
<p>Object Oriented Programming (OOP) is a programming paradigm based on the use of objects and their interactions. A recurring analogy is to see a "class" as a cookie cutter that can create many cookies, the "objects". Some terms and definitions used within OOP are listed below:</p>
<ul>
<li><p>A class defines the characteristics of a thing - the object - and its behaviours; it defines not only its properties and attributes but also what it can do.</p></li>
<li><p>An object is an instance of a class.</p></li>
<li><p>The methods are the objects abilities.</p></li>
</ul>
<h2 id="howtobuildyourownclassessimpleclass">How to build your own Classes (simple Class)</h2>
<p>Classes and objects are the fundamental part of Object Oriented programming. Because cooking, like coding, is fun and we tend to experiment in the kitchen let's continue with the classic metaphor of a cookie cutter as a class, defining its interactions, capabilities and affordances, and cookies as the objects. Every class has two files: a header file, also known as a declarations file with the termination '.h' and an implementation file, terminating in '.cpp'. A very easy way of knowing what these two files do is to think of the header file (.h) as a recipe, a list of the main ingredients of your cookie. The implementation file (.cpp) is what we're going to do with them, how you mix and work them to be the perfect cookie! So let's see how it works:</p>
<p>First of all let's create the two class files: If you're using Xcode as your IDE (it stands for: Integrated Development Environment), select the src folder and left Click (or CTRL + click), on the pop-up menu select 'New File' and you'll be taken to a new window menu, choose the appropriate platform you're developing for (OS X or iOS) and select C++ class and finally choose a name (we used 'Ball'). You'll automatically see the two files in your 'src' folder: 'Ball.h' and 'Ball.cpp'. If you are using Code::Blocks create a new project from empty one given inside the "examples" directory (or check out the ProjectGenerator). Copy the folder "empty" and rename it to "OOP". Change into this new directory, copy the "emptyExample" and rename it to "ball1". Inside the "ball1" directory rename "emptyExample.workspace" to "ball1.workspace" and "emptyExample.cbp" to "ball1.cbp". Now you have a dedicated directory and a dedicated project to play around with. Open "ball1.cbp" with Code::Blocks , right-click on the "emptyExample" workspace, select "Properties" (last entry in the list) and change the title of the project. The "src" directory in your project contains all the files you need to edit in this chapter. Add two new files inside the 'src' directory by either using 'File'-&gt;'New'-&gt;'Empty File' or pressing Tab+Ctrl+N. One file should be named 'Ball.h' and the other 'Ball.cpp'. Now let's edit your class header (.h) file. Feel free to delete all its contents and let's start from scratch: Declare a class in the header file (.h). In this case, the file name should be Ball.h. Follow the code below and type into your own Ball.h file, please note the comments I've included to guide you along.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#ifndef _BALL </span><span class="co">// if this class hasn't been defined, the program can define it</span>
<span class="ot">#define _BALL </span><span class="co">// by using this if statement you prevent the class to be called more than once which would confuse the compiler</span>
<span class="ot">#include "ofMain.h" </span><span class="co">// we need to include this to have a reference to the openFrameworks framework</span>
<span class="kw">class</span> Ball {

    <span class="kw">public</span>: <span class="co">// place public functions or variables declarations here</span>

    <span class="co">// methods, equivalent to specific functions of your class objects</span>
    <span class="dt">void</span> setup();	<span class="co">// setup method, use this to setup your object's initial state</span>
    <span class="dt">void</span> update();  <span class="co">// update method, used to refresh your objects properties</span>
    <span class="dt">void</span> draw();    <span class="co">// draw method, this where you'll do the object's drawing </span>

    <span class="co">// variables</span>
    <span class="dt">float</span> x;        <span class="co">// position</span>
    <span class="dt">float</span> y;
    <span class="dt">float</span> speedY;   <span class="co">// speed and direction</span>
    <span class="dt">float</span> speedX;
    <span class="dt">int</span> dim;        <span class="co">// size</span>
    ofColor color;  <span class="co">// color using ofColor type</span>

    Ball();  <span class="co">// constructor - used to initialize an object, if no properties are passed the program sets them to the default value</span>
    <span class="kw">private</span>: <span class="co">// place private functions or variables declarations here</span>
}; <span class="co">// don't forget the semicolon!</span>
<span class="ot">#endif</span></code></pre>
<p>We have declared the Ball class header file (the list of ingredients) and now lets get to the cooking part to see what these ingredients can do! Please notice the '#include' tag. This is a way to tell the <a href="http://www.cplusplus.com/doc/tutorial/introduction/" target="_blank" title="Compiler introduction on cplusplus.com">compiler</a> (<a href="https://en.wikipedia.org/wiki/Compiler" target="_blank" title="Wikipedia on compilers">wikipedia</a>) about any files to include in the implementation file. When the program is compiled these '#include' tags will be replaced by the original file they're referring to. The 'if statement' (#ifndef) is a way to prevent the repetition of header files which could easily occur. This is called an <a href="https://en.wikipedia.org/wiki/Include_guard" target="_blank" title="Wikipedia on include guards">include guard</a>. Using this pattern helps the compiler to only include the file once and avoid repetition. Don't worry about this now, we'll talk about it later on!</p>
<p>We will now create a class for a ball object. This ball will have color, speed and direction properties: it will move across the screen and bounce against the wall. Some of these properties we will create with randomized attributes but we'll be careful to create the right logic for its motion behaviours.</p>
<p>Here's how you can write the class Ball.cpp file, the implementation file:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include "Ball.h"</span>
Ball::Ball(){
}

<span class="dt">void</span> Ball::setup(){
    x = ofRandom(<span class="dv">0</span>, ofGetWidth());      <span class="co">// give some random positioning</span>
    y = ofRandom(<span class="dv">0</span>, ofGetHeight());

    speedX = ofRandom(-<span class="dv">1</span>, <span class="dv">1</span>);           <span class="co">// and random speed and direction</span>
    speedY = ofRandom(-<span class="dv">1</span>, <span class="dv">1</span>);

    dim = <span class="dv">20</span>;

    color.set(ofRandom(<span class="dv">255</span>),ofRandom(<span class="dv">255</span>),ofRandom(<span class="dv">255</span>)); <span class="co">// one way of defining digital color is by addressing its 3 components individually (Red, Green, Blue) in a value from 0-255, in this example we're setting each to a random value</span>
}

<span class="dt">void</span> Ball::update(){
    <span class="kw">if</span>(x &lt; <span class="dv">0</span> ){
        x = <span class="dv">0</span>;
        speedX *= -<span class="dv">1</span>;
    } <span class="kw">else</span> <span class="kw">if</span>(x &gt; ofGetWidth()){
        x = ofGetWidth();
        speedX *= -<span class="dv">1</span>;
    }

    <span class="kw">if</span>(y &lt; <span class="dv">0</span> ){
        y = <span class="dv">0</span>;
        speedY *= -<span class="dv">1</span>;
    } <span class="kw">else</span> <span class="kw">if</span>(y &gt; ofGetHeight()){
        y = ofGetHeight();
        speedY *= -<span class="dv">1</span>;
    }

    x+=speedX;
    y+=speedY;
}

<span class="dt">void</span> Ball::draw(){
    ofSetColor(color);
    ofDrawCircle(x, y, dim);
}</code></pre>
<p>Now, this is such a simple program that we could have written it inside our ofApp(.h and .cpp) files and that would make sense if we didn't want to reuse this code elsewhere. One of the advantages of Object Oriented Programming is reuse. Imagine we want to create thousands of these balls. The code could easily get messy without OOP. By creating our own class we can later re-create as many objects as we need from it and just call the appropriate methods when needed keeping our code clean and efficient. In a more pragmatic example think of creating a class for each of your user-interface (UI) elements (button, slider, etc) and how easy it would be to then deploy them in your program but also to include and reuse them in future programs.</p>
<h2 id="makeanobjectfromyourclass">Make an Object from your Class</h2>
<p>Now that we've created a class let's make the real object! In your ofApp.h (header file) we'll have to declare a new object but first we need to include (or give the instructions to do so) your Ball class in our program. To do this we need to write:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include "Ball.h"</span></code></pre>
<p>on the top of your ofApp.h file. Then we can finally declare an instance of the class in our program. Add the following line inside the <code>ofApp</code> class, just above the final "};".</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">Ball myBall;</code></pre>
<p>Now let's get that ball bouncing on screen! Go to your project ofApp.cpp (implementation) file. Now that we've created the object, we just need to set it up and then update its values and draw it by calling its methods.</p>
<p>In the <code>setup()</code> function of ofApp.cpp add the following code:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">myBall.setup(); <span class="co">// calling the object's setup method</span></code></pre>
<p>In the <code>update()</code> function add:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">myBall.update(); <span class="co">// calling the object's update method</span></code></pre>
<p>and in the <code>draw()</code> function lets add:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">myBall.draw(); <span class="co">// call the draw method to draw the object</span></code></pre>
<p>Compile and run! At this point you should be seeing a bouncing ball on the screen! Great!</p>
<h2 id="makeobjectsfromyourclass">Make objects from your Class</h2>
<p>By now, you're probably asking yourself why you went to so much trouble to create a bouncing ball. You could have done this (and probably have) without using classes. In fact one of the advantages of using classes is to be able to create multiple individual objects with the same characteristics. So, let's do that now! Go back to your ofApp.h file and create a couple of new objects:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">Ball myBall1;
Ball myBall2;
Ball myBall3;</code></pre>
<p>In the implementation file (ofApp.cpp), call the corresponding methods for each of the objects in the ofApp's <code>setup()</code> function:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">myBall1.setup();
myBall2.setup();
myBall3.setup();</code></pre>
<p>in the ofApp's <code>update()</code> function:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">myBall1.update();
myBall2.update();
myBall3.update();</code></pre>
<p>and also in the <code>draw()</code> function:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">myBall1.draw();
myBall2.draw();
myBall3.draw();</code></pre>
<h2 id="makemoreobjectsfromyourclass">Make more Objects from your Class</h2>
<p>We've just created 3 objects but you can have already see how tedious it would be to create 10, 100 or maybe 1000's of them. Hard-coding them one by one would be a long and painful process that could be easily solved by automating the object creation and function calls. Just by using a couple for loops we'll make this process simpler and cleaner. Instead of declaring a list of objects one by one, we'll create an array of objects of type <code>Ball</code>. We'll also introduce another new element: a constant. Constants are set after any #includes as #define CONSTANT_NAME value. This is a way of setting a value that won't ever change in the program. In the ofApp class header file, where you define the balls objects, you also define the constant that we'll use for the number of objects:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#define NBALLS 10</span></code></pre>
<p>We'll now use the constant NBALLS value to define the size of our array of objects:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">Ball myBall[NBALLS];</code></pre>
<p>An array is an indexed list of items of the same type. The index is used to access a particular item in the list. This index usually starts with 0, so the first <code>Ball</code> (object) is found at myBall[0]. Only a handful of programming languages start the index of an array with 1. If you try to access an invalid index (either larger than the size of the array or a negative one), you get an error. Check the 'C++ basics' chapter for more information on arrays. In our implementation file we create an array of objects and call their methods through 'for' loops.</p>
<p>In the <code>setup()</code> function remove:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">myBall1.setup();
myBall2.setup();
myBall3.setup();</code></pre>
<p>and add</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>; i&lt;NBALLS; i++){
    myBall[i].setup();
}</code></pre>
<p>instead.</p>
<p>In the <code>update()</code> function remove</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">myBall1.update();
myBall2.update();
myBall3.update();</code></pre>
<p>and write</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>; i&lt;NBALLS; i++){
    myBall[i].update();
}</code></pre>
<p>In the <code>draw()</code> function replace</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">myBall1.draw();
myBall2.draw();
myBall3.draw();</code></pre>
<p>with</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>; i&lt;NBALLS; i++){
    myBall[i].draw();
}</code></pre>
<p>By using the for loop, the <code>setup()</code>, the <code>update()</code> and the <code>draw()</code> method is called for each <code>Ball</code> object in the <code>myBall</code>-array and no object has to be touched manually.</p>
<h2 id="makeevenmoreobjectsfromyourclasspropertiesandconstructors">Make even more Objects from your Class: properties and constructors</h2>
<p>As we've seen, each of the objects has a set of properties defined by its variables (position, speed, direction and dimension). Another advantage of object oriented programming is that the objects created can have different values for each of their properties. For us to have better control of each object, we can have a method that allows us to define these characteristics and lets us access them. Because we want to do this right after creating the object, let's do this in the method called <code>setup()</code>. We will modify it to pass in some of the objects properties, let's say its position and dimension. First let's do this in the Ball definitions file (*.h):</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> setup(<span class="dt">float</span> _x, <span class="dt">float</span> _y, <span class="dt">int</span> _dim);</code></pre>
<p>We'll need to update the Ball implementation (*.cpp) file to reflect these changes.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> Ball::setup(<span class="dt">float</span> _x, <span class="dt">float</span> _y, <span class="dt">int</span> _dim){
    x = _x;
    y = _y;
    dim = _dim;

    speedX = ofRandom(-<span class="dv">1</span>, <span class="dv">1</span>);
    speedY = ofRandom(-<span class="dv">1</span>, <span class="dv">1</span>);
}</code></pre>
<p>Your Ball.cpp file should look like this by now:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include "Ball.h"</span>

Ball::Ball(){
};

<span class="dt">void</span> Ball::setup(<span class="dt">float</span> _x, <span class="dt">float</span> _y, <span class="dt">int</span> _dim){
    x = _x;
    y = _y;
    dim = _dim;

    speedX = ofRandom(-<span class="dv">1</span>, <span class="dv">1</span>);
    speedY = ofRandom(-<span class="dv">1</span>, <span class="dv">1</span>);

    color.set(ofRandom(<span class="dv">255</span>), ofRandom(<span class="dv">255</span>), ofRandom(<span class="dv">255</span>));
}

<span class="dt">void</span> Ball::update(){
    <span class="kw">if</span>(x &lt; <span class="dv">0</span> ){
        x = <span class="dv">0</span>;
        speedX *= -<span class="dv">1</span>;
    } <span class="kw">else</span> <span class="kw">if</span>(x &gt; ofGetWidth()){
        x = ofGetWidth();
    speedX *= -<span class="dv">1</span>;
    }

    <span class="kw">if</span>(y &lt; <span class="dv">0</span> ){
        y = <span class="dv">0</span>;
        speedY *= -<span class="dv">1</span>;
    } <span class="kw">else</span> <span class="kw">if</span>(y &gt; ofGetHeight()){
        y = ofGetHeight();
        speedY *= -<span class="dv">1</span>;
    }

    x+=speedX;
    y+=speedY;
}

<span class="dt">void</span> Ball::draw(){
    ofSetColor(color);
    ofDrawCircle(x, y, dim);
}</code></pre>
<p>Now in the ofApp.cpp file we will need to run this newly implemented method right when we start our application so it will reflect the different settings on each object as they are created. So, in the <code>ofApp::setup()</code></p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>; i&lt;NBALLS; i++){

	<span class="dt">int</span> size = (i<span class="dv">+1</span>) * <span class="dv">10</span>; <span class="co">// defining the size of each ball based on its place in the array</span>
	<span class="dt">int</span> randomX = ofRandom( <span class="dv">0</span>, ofGetWidth() ); <span class="co">//generate a random value bigger than 0 and smaller than our application screen width</span>
	<span class="dt">int</span> randomY = ofRandom( <span class="dv">0</span>, ofGetHeight() ); <span class="co">//generate a random value bigger than 0 and smaller than our application screen height</span>

    myBall[i].setup(randomX, randomY, size);
}</code></pre>
<p>As you see it is now possible to directly control the objects properties on its creation. Now we'll just need to use the for loop from above to go through the balls to update and draw them in the respective functions.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">myBall[i].update();

myBall[i].draw();</code></pre>
<h2 id="makeobjectsonthefly">Make Objects on the fly</h2>
<p>While many times you'll already have a pre-defined number of objects you'll need to create and using arrays is the right choice, there are other ways to create multiple objects that offer other advantages: welcome vectors! Vectors are really great as they'll allow to create collections of objects without a predefined number of elements. They're quite dynamic and allow you to add objects on the fly (e.g. while your program is running) but also to remove them when you need longer need the objects. Think of them as elastic arrays. So, let's use them! Note: You'll be hearing about two different types of vectors throughout this book. Please don't confuse stl::vectors (the elastic arrays type we're talking about) with mathematical vectors (e.g. forces).</p>
<p>To learn more about stl::vector check the "C++ basics" chapter or the <a href="http://openframeworks.cc/tutorials/c++%20concepts/001_stl_vectors_basic.html" target="_blank">short online tutorial on the openFrameworks website</a>.</p>
<p>Back to our beloved ofApp.h file, let's define a vector of <code>Ball</code> objects by typing:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">vector &lt;Ball&gt; myBall;</code></pre>
<p>In this expression we're creating a type (vector) of type (Ball pointers) and naming it myBall. Now, let's head to our ofApp.cpp and start cooking! Ignore the <code>setup()</code>, <code>update()</code> and <code>draw()</code> methods in the ofApp for now, let's jump to <code>ofApp::mouseDragged(...)</code> method. This method constantly listens to the mouse drag action and if it has changed it reveals its values (position and button state) to us.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> ofApp::mouseDragged(<span class="dt">int</span> x, <span class="dt">int</span> y, <span class="dt">int</span> button){
}</code></pre>
<p>In this method we're listening to the dragging activity of your mouse, and we'll use this to create interaction! So let's just create some code to create <code>Ball</code>s and add them to our program when we drag the mouse. The dragging activity of your mouse or trackpad is an ubiquitous, simple but also very gestural source of data and we'll use this simplicity to create interaction! Let's add some code to create <code>Ball</code>s and add them to our program when we drag the mouse.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> ofApp::mouseDragged(<span class="dt">int</span> x, <span class="dt">int</span> y, <span class="dt">int</span> button){
    Ball tempBall;							<span class="co">// create the ball object</span>
    tempBall.setup(x,y, ofRandom(<span class="dv">10</span>,<span class="dv">40</span>));	<span class="co">// setup its initial state</span>
    myBall.push_back(tempBall);				<span class="co">// add it to the vector</span>
}</code></pre>
<p>A few new things in our code: we begin by declaring a temporary object, think of it as a placeholder for the real object - that will be inside the vector! - we them define its initial properties by assigning the <code>x</code> and <code>y</code> mouse drag coordinates to its setup variables. Afterwards, we use this temporary object as a placeholder to add <code>Ball</code> objects to our vector.</p>
<p>Back to our update and draw methods. We can add the needed 'for loops' to iterate over the objects in the vector to update and draw them like we would do with arrays. This time though we didn't declare a variable that stores the maximum number of objects but instead, the vector object provides us with a handy method we can call to know their size (<code>size()</code>). See code below for <code>update()</code></p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i&lt;myBall.size(); i++) {
    myBall[i].update();
}</code></pre>
<p>and for <code>draw()</code>:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span> ; i&lt;myBall.size(); i++) {
    myBall[i].draw();
}</code></pre>
<p>Now the 'for' loop iterates over all objects in the vector without us needing to specify the exact number of items beforehand. It gets adjusted on the fly thanks to <code>size()</code>.</p>
<h2 id="makinganddeleteasyouwishusingvectors">Making and delete as you wish - using vectors</h2>
<p>If you ran the previous code you'll see that in a very short time you'll not only create a huge amount of balls but at some point your system might become sluggish because there are just way too many objects on screen. As we just mentioned vectors are very special as we can add and remove elements dynamically. That's their magic: vectors are elastic! So, let's also implement a way to delete them before we have way too many Balls.</p>
<p>On the <code>ofApp::MousePressed(...)</code> call we will loop though our vector and check the distance between the coordinates of the mouse with a particular <code>Ball</code> position. If this distance is smaller than the <code>Ball</code> radius then we know that we're clicking inside it and we can delete it. Because we're using the <code>vector.erase(...)</code> method we need to use an iterator (<code>myBall.begin()</code>). Iterators are pointing to some element in a larger contained group and have the ability to iterate through the elements of that range. See them as paths or links. In this very case they are a shortcut that references the first element of the vector as a starting point to access the vector element we really want to erase (<code>i</code>), thus <code>myBall.begin()+i</code>.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">for</span> (<span class="dt">int</span> i =<span class="dv">0</span>; i &lt; myBall.size(); i++) {
    <span class="dt">float</span> distance = ofDist(x,y, myBall[i].x, myBall[i].y); <span class="co">// a method oF gives us to check the distance between two coordinates</span>

    <span class="kw">if</span> (distance &lt; myBall[i].dim) {
        myBall.erase(myBall.begin()+i); <span class="co">// we need to use an iterator/ reference to the vector position we want to delete</span>
    }
}</code></pre>
<p>But because there's always a time you might just want to destroy them all, vectors also have a very handy method to help you: <code>clear()</code>. Feel free to experiment and try using it yourself!</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">myBall.clear();</code></pre>
<h2 id="quickintrotopolymorphisminheritance">Quick intro to polymorphism (inheritance)</h2>
<p>You're now discovering the power of OOP: making a class and creating as many objects from that in an instant, adding and deleting by your application needs. Now, for a second let's go back to our cooking metaphor (yummy!) and imagine that your cookies, even though sharing the same cookie cutter and dough, are using some different sprinkles on each to add some desired variation to our cookie jar selection! This is also the power of OOP and inheritance. It allows us to use a base class and add some specific behaviours, overwriting some of the behaviours of a class, creating a subset of instances / objects with slightly different behaviours. The great thing about this is it's reusability. We're using the parent class as a starting point, using all its capabilities but we overwrite one of its methods to give it more flexibility. Going back to the initial version of our <code>Ball</code> class we'll build some child classes based on its main characteristics (motion behaviours and shape) but we'll distinguish each inherited sub-class by using a different color in its drawing method.</p>
<p>Your Ball header file should look like this:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#ifndef _BALL </span><span class="co">// if this class hasn't been defined, the program can define it</span>
<span class="ot">#define _BALL </span><span class="co">// by using this if statement you prevent the class to be called more than once which would confuse the compiler</span>
<span class="ot">#include "ofMain.h"</span>


<span class="kw">class</span> Ball {
    <span class="kw">public</span>: <span class="co">// place public functions or variables declarations here</span>

    <span class="dt">void</span> setup();
    <span class="dt">void</span> update();
    <span class="dt">void</span> draw();

    <span class="co">// variables</span>
    <span class="dt">float</span> x;
    <span class="dt">float</span> y;
    <span class="dt">float</span> speedY;
    <span class="dt">float</span> speedX;
    <span class="dt">int</span> dim;

    ofColor color;

    Ball();

    <span class="kw">private</span>:
};
<span class="ot">#endif</span></code></pre>
<p>Let's make some slight changes on the implementation file. Lets change the minimum and maximum values of the random size to larger values and set the position to the center of the screen. Make the source code look like this:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include "Ball.h"</span>

Ball::Ball(){
}

<span class="dt">void</span> Ball::setup(){

    x = ofGetWidth()*.<span class="dv">5</span>;
    y = ofGetHeight()*.<span class="dv">5</span>;
    dim = ofRandom(<span class="dv">200</span>,<span class="dv">250</span>);

    speedX = ofRandom(-<span class="dv">1</span>, <span class="dv">1</span>);
    speedY = ofRandom(-<span class="dv">1</span>, <span class="dv">1</span>);

    color.set(ofRandom(<span class="dv">255</span>), ofRandom(<span class="dv">255</span>), ofRandom(<span class="dv">255</span>));
}</code></pre>
<p>We can leave the <code>update()</code> and <code>draw()</code> functions as they were, but <code>mouseDragged(...)</code> inside ofApp.cpp needs to be adjusted to the new <code>setup()</code> function by removing the three arguments:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> ofApp::mouseDragged(<span class="dt">int</span> x, <span class="dt">int</span> y, <span class="dt">int</span> button){
    Ball tempBall;				<span class="co">// create the ball object</span>
    tempBall.setup();			<span class="co">// setup its initial state</span>
    myBall.push_back(tempBall);	<span class="co">// add it to the vector</span>
}</code></pre>
<p>Now, let's start making child versions of this parent class. Create a new class set of files and name them <code>BallBlue</code>. Feel free to copy the code below. It's '.h' should look like this:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#pragma once                </span><span class="co">// another and more modern way to prevent the compiler from including this file more than once</span>

<span class="ot">#include "ofMain.h"</span>
<span class="ot">#include "Ball.h"            </span><span class="co">// we need to include the parent class, the compiler will include the mother/base class so we have access to all the methods inherited</span>

<span class="kw">class</span> BallBlue : <span class="kw">public</span> Ball {     <span class="co">// we set the class to inherit from 'Ball'</span>
    <span class="kw">public</span>:
        <span class="kw">virtual</span> <span class="dt">void</span> draw();       <span class="co">// this is the only method we actually want to be different from the parent class</span>
};</code></pre>
<p>In the '.cpp' file we'll need to then specify what we want the new <code>draw()</code> method to behave differently from the one in the parent class.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include "BallBlue.h"</span>

<span class="dt">void</span> BallBlue::draw(){
    ofSetColor(ofColor::blue);    <span class="co">// this is a shortcut for full blue color ;)</span>
    ofDrawCircle(x, y, dim);
}</code></pre>
<p>Now create two new classes on your own: <code>BallRed</code> and <code>BallGreen</code> based on the <code>Ball</code> class like <code>BallBlue</code>. Back to your 'ofApp.h'. Include the newly made classes and create one instance of each and in your 'ofApp.cpp' file. Initialize them and call their <code>update()</code> and <code>draw()</code> methods. A quick trick! Right before you call the <code>draw()</code> method, make this call:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">ofEnableBlendMode(OF_BLENDMODE_ADD);</code></pre>
<p>This will make your application drawing methods have an additive blending mode. For more on this check the "Graphics" chapter.</p>
<p>Hope you enjoyed this short tutorial! Have fun!</p>
<div class="footer">
<div id="prev_chapter"><a href="intro_to_graphics.html">&lt; Graphics</a></div>
<div id="next_chapter"><a href="how_of_works.html">how OF works &gt;</a></div>
</div>
<div id="help"><i>please note that this book / chapter is a work in progress.  Feel free to suggest edits / corrections <a href="https://github.com/openframeworks/ofbook" target="_blank">here</a></i></div>
</div>
</div>
</body>
</html>
