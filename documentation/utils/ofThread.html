








<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    
	
  <title>openFrameworks.kr - ofThread</title>

<!-- syntax highlighting for the documentation -->
<script src="http://icq4ever.iptime.org/js/shCore.js" type="text/javascript"></script>
<script src="http://icq4ever.iptime.org/js/shAutoloader.js" type="text/javascript"></script>
<script src="http://icq4ever.iptime.org/js/shBrushCpp.js" type="text/javascript"></script>
<script src="http://icq4ever.iptime.org/js/shBrushJava.js" type="text/javascript"></script>
<script src="http://icq4ever.iptime.org/js/shBrushXml.js" type="text/javascript"></script>
<link href="http://icq4ever.iptime.org/css/shCore.css" rel="stylesheet" type="text/css" />
<link href="http://icq4ever.iptime.org/css/shThemeDefault.css" rel="stylesheet" type="text/css" />

<link rel="stylesheet" type="text/css" href="http://icq4ever.iptime.org/css/style.css" media="all" />
<link rel="stylesheet" type="text/css" href="http://icq4ever.iptime.org/css/print.css" media="print" />
<link href='http://fonts.googleapis.com/css?family=Questrial' rel='stylesheet' type='text/css'>
<link rel="search" type="application/opensearchdescription+xml" href="http://icq4ever.iptime.org/opensearch.xml" title="openFrameworks.kr"/>

<link rel="shortcut icon" href="http://icq4ever.iptime.org/favicon.ico" />
<link rel="icon" href="http://icq4ever.iptime.org/favicon.ico" type="image/x-icon" />

<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.6.4/jquery.min.js" type="text/javascript"></script>
<script type="text/javascript" src="http://icq4ever.iptime.org/js/jquery.timeago.js" type="text/javascript"></script>

<meta name="google-site-verification" content="RiGtl9pFuFnUeEQ4MU1miiutTR5mmCPUi38YLCn-M-g" />


    <script src="http://icq4ever.iptime.org/js/jquery.columnizer.min.js"></script>
    <script src="http://icq4ever.iptime.org/js/documentation.js"></script>
  </head>
  <body>
    <div id="content">
      
  

<div id="head">

		<div id="head-left">
			<a href="http://icq4ever.iptime.org" class="nohover"><img src="http://icq4ever.iptime.org/images/of-logo.svg" border="0" alt="openFrameworks" /></a>
		</div>

		<div id="head-right">
		<ul>
	        <li><a href="http://icq4ever.iptime.org/about" class="" >소개</a></li>
	        <li><a href="http://icq4ever.iptime.org/download" class="" >다운로드</a></li>
	        <li><a href="http://icq4ever.iptime.org/documentation" class="">도큐먼트</a></li>
	        <li><a href="http://icq4ever.iptime.org/tutorials" class="">튜토리얼</a></li>
	        <li><a href="http://icq4ever.iptime.org/gallery" class="">갤러리</a></li>
	        <li><a href="http://icq4ever.iptime.org/community" class="">커뮤니티</a></li> 
	        <li><a href="http://icq4ever.iptime.org/development" class="" >개발</a></li>
		</ul>
		
		<ul class="menu-externals">
			<li><span class="external-dot"> ></span>&nbsp;<a href="http://forum.openframeworks.cc" target="_blank">포럼(EN)</a></li>
			<li><span class="external-dot"> ></span>&nbsp;<a href="https://openframeworks-kr.slack.com/" target="_blank">포럼(KR)</a></li>
			<li><span class="external-dot"> ></span>&nbsp;<a href="http://ofxaddons.com" target="_blank">애드온</a></li>
			<li><span class="external-dot"> ></span>&nbsp;<a href="http://github.com/openframeworks/openFrameworks" target="_blank">github</a></li>
			<li><span class="external-dot"> ></span>&nbsp;<a href="http://openframeworks.cc/list-info" target="_blank">메일링 리스트</a></li>
			<li><span class="external-dot"> ></span>&nbsp;<a href="http://webchat.freenode.net?channels=openframeworks&uio=MT1mYWxzZSY5PXRydWUmMTE9Mjk39" target="_blank">IRC</a></li>
			<li><span class="external-dot"> ></span>&nbsp;<a href="http://blog.openframeworks.cc/" target="_blank">블로그</a></li>
		</ul>
		
			<!--form method="get" id="searchform" action="/index.php">
			<input type="text" value="" name="s" id="s" class="search_input" /> <input type="submit" value="Search" class="search_button"/>
			</form-->
			<!--form method="post" action="http://scripts.dreamhost.com/add_list.cgi">
                <input type="hidden" name="list" value="list@openframeworks.cc" />
                <input type="hidden" name="domain" value="openframeworks.cc" />
                <input type="hidden" name="url" value="http://openframeworks.cc/list-info/subscribe.html"  />
                <input type="hidden" name="unsuburl" value="http://openframeworks.cc/list-info/unsubscribe.html" />
                <input type="hidden" name="alreadyonurl" value="http://openframeworks.cc/list-info/already.html" />
                <input type="hidden" name="notonurl" value="http://openframeworks.cc/list-info/not.html" />
                <input type="hidden" name="invalidurl" value="http://openframeworks.cc/list-info/invalid.html" />
                <input type="hidden" name="emailconfirmurl" value="http://openframeworks.cc/list-info/confirm.html" />
                <input type="hidden" name="emailit" value="1" />
                name: <input name="name" /> <br />
                email: <input name="email" /><br />
                <span class='but'><input type="submit" name="submit" value="subscribe" /></span> <br/ >
                <span class='but'><input type="submit" name="unsub" value="unsubscribe" /></span>
            </form-->
        <ul class="submenu">
            <li><a href="http://openframeworks.cc">english</a></li>
            <li>/</li>
            <li><a href="http://openframeworks.jp">japanese</a></li>
			<li>/</li>
			<li>korean</li>
        </ul>
		</div>
</div><!-- head -->



      <div id="body-wrap">
          <div class="page-wide">
          
              <div id="docstitle"><h1>ofThread</h1></div>
              <div id="editdocs">
                    <a href="https://github.com/openframeworks/ofSite/edit/master/_documentation/utils/ofThread.markdown" class="nohover"><img title="edit class on GitHub" src="/images/editclass.png?a=5"/></a>
              </div>
              
          </div>
          
          
        <div class="page-wide">
		    <div class="submenucol-left">
		     <!-- list of methods -->
		     <p class="top_list_header">class methods</p>
             <ul class="functionslist">
                 
                     
                     
                         <li>
                         <a href="#show_getCurrentPocoThread" class="getCurrentPocoThread" data-lookup="getCurrentPocoThread">getCurrentPocoThread()</a></li>
                     
                         <li>
                         <a href="#show_getPocoThread" class="getPocoThread" data-lookup="getPocoThread">getPocoThread()</a></li>
                     
                     
                         <li>
                         <a href="#show_getThreadId" class="getThreadId" data-lookup="getThreadId">getThreadId()</a></li>
                     
                         <li>
                         <a href="#show_getThreadName" class="getThreadName" data-lookup="getThreadName">getThreadName()</a></li>
                     
                         <li>
                         <a href="#show_isCurrentThread" class="isCurrentThread" data-lookup="isCurrentThread">isCurrentThread()</a></li>
                     
                         <li>
                         <a href="#show_isMainThread" class="isMainThread" data-lookup="isMainThread">isMainThread()</a></li>
                     
                         <li>
                         <a href="#show_isThreadRunning" class="isThreadRunning" data-lookup="isThreadRunning">isThreadRunning()</a></li>
                     
                         <li>
                         <a href="#show_lock" class="lock" data-lookup="lock">lock()</a></li>
                     
                     
                         <li>
                         <a href="#show_sleep" class="sleep" data-lookup="sleep">sleep()</a></li>
                     
                         <li>
                         <a href="#show_startThread" class="startThread" data-lookup="startThread">startThread()</a></li>
                     
                         <li>
                         <a href="#show_stopThread" class="stopThread" data-lookup="stopThread">stopThread()</a></li>
                     
                     
                         <li>
                         <a href="#show_unlock" class="unlock" data-lookup="unlock">unlock()</a></li>
                     
                         <li>
                         <a href="#show_waitForThread" class="waitForThread" data-lookup="waitForThread">waitForThread()</a></li>
                     
                         <li>
                         <a href="#show_yield" class="yield" data-lookup="yield">yield()</a></li>
                     
             </ul>
            
             
             
             <!-- list of variables -->              
            
             
            
             <!-- list of functions -->              
		    </div>
	    <div class="submenucol-right">
            <div class="documentation_detail class_documentation">
              
  <p><a href="../utils/ofThread.html" class="docs_class" >ofThread</a> is a thread base class with a built in mutex. A <a href="http://en.wikipedia.org/wiki/Thread_(computing)">thread</a> is essentially a mini processing object you can run in parallel to your main application loop and is useful for running time intensive operations without slowing down your app.</p>
<h4 id="implementing-a-thread">Implementing a Thread</h4>
<p>For instance, you have to grab from a camera and waiting for an image slows down your app. You can offload this wait to a thread which tells the main app when an image is ready. To do this, you create a class that inherits from the <a href="../utils/ofThread.html" class="docs_class" >ofThread</a> class and implement the threadedFunction() function.</p>
<p>Declaration in a .h file:</p>
<pre><code class="cpp">
class MyThread : public &lt;a href=&quot;../utils/ofThread.html&quot; class=&quot;docs_class&quot; &gt;ofThread&lt;/a&gt; {

    ...

    // the thread function
    void MyThread::threadedFunction() {

        // start

        while(isThreadRunning()) {

            cam.update();
            if(cam.isFrameNew()) {

                // load the image
                image.setFromPixels(cam.getPixels());
            }
        }

        // done
    }

    &lt;a href=&quot;../video/ofVideoGrabber.html&quot; class=&quot;docs_class&quot; &gt;ofVideoGrabber&lt;/a&gt; cam;  // the cam
    &lt;a href=&quot;../graphics/ofImage.html&quot; class=&quot;docs_class&quot; &gt;ofImage&lt;/a&gt; image;
};

</code></pre>

<p>In the application .h inside the ofApp class declare an object of type MyThread like:</p>
<pre><code class="cpp">// create object
MyThread thread;
</code></pre>

<p>then in the .cpp file:</p>
<pre><code class="cpp">
void ofApp::setup() {

    // start the thread
    thread.startThread(true, false);    // blocking, non verbose
}

void ofApp::update() {

    // do something with the thread is running
}

void ofApp::exit() {

    // stop the thread
    thread.stopThread();
}

</code></pre>

<h4 id="shared-resources">Shared Resources</h4>
<p>With this great power, however, comes great responsibility. If both the thread and your main app loop try to access the image at the same time, bad things happen inside your computer and the app will crash. The image is a considered a "shared resource" and you need to make sure to lock access to it so that only 1 thread can access it a time. You can do this using a <a href="http://en.wikipedia.org/wiki/Mutex">"mutal exclusion" object</a> by called lock() when you want to access the resource, then unlock() when you are done.</p>
<p>Declaration in a .h file:</p>
<pre><code class="cpp">
class MyThread : public &lt;a href=&quot;../utils/ofThread.html&quot; class=&quot;docs_class&quot; &gt;ofThread&lt;/a&gt; {

    ...

    // the thread function
    void MyThread::threadedFunction() {

        // start

        while(isThreadRunning()) {

            cam.update();
            if(cam.isFrameNew()) {

                // lock access to the resource
                lock();

                // load the image
                image.setFromPixels(cam.getPixels());   
                // done with the resource
                unlock();
            }   
        }

        // done
    }

    &lt;a href=&quot;../video/ofVideoGrabber.html&quot; class=&quot;docs_class&quot; &gt;ofVideoGrabber&lt;/a&gt; cam;  // the cam
    &lt;a href=&quot;../graphics/ofImage.html&quot; class=&quot;docs_class&quot; &gt;ofImage&lt;/a&gt; image;       // the shared resource
};

</code></pre>

<p>In the .cpp file:</p>
<pre><code class="cpp">
void ofApp::setup() {

    // start the thread
    thread.startThread(true, false);    // blocking, non verbose
}

void ofApp::update() {

    // lock access to the resource
    thread.lock();

    // copy image
    myImage = thread.image;

    // done with the resource
    thread.unlock();
}

void ofApp::exit() {

    // stop the thread
    thread.stopThread();
}

</code></pre>

<h4 id="exiting-nicely">Exiting Nicely</h4>
<p>As a thread is running in parallel with your application main loop, it's important to remember to tell it to stop before exiting the app. If you don't, you'll get weird errors or hangs because you aren't being nice to your threads. Depending on how you started your thread (blocking or non-blocking mode), you will either stop it for wait for it to finish. See the stopThread() &amp; waitForThread() functions.</p>
<h4 id="debugging">Debugging</h4>
<p>Thread errors are <em>notoriously</em> difficult to debug sometimes. You will probably see a "Bad Access" runtime error or something similar if multiple threads are trying to access a shared resource simultaneously. Other times, nothing will happen as the thread may be stuck in an infinite loop and you can't stop it. Wee! We assume if you've read this far, you probably accept the difficulties in order to reap the thread speed rewards. </p>
<p>A useful tool in debugging thread timing and access is the <a href="../utils/ofThread.html" class="docs_class" >ofThread</a> verbose mode which prints thread events such as starting, stopping, and mutex locking/unlocking. Simply set verbose=true when calling startThread(). Another trick is to use an ofSleepMillis() inside the thread to slow it down so you can see the timing better while debugging it.</p>
<h4 id="hoo-rah">HOO RAH</h4>
<p>Ok soldier, lock and load ... good luck!</p>


                    <div class="inlined_docs">
                        <h2><strong><em>Documentation from code comments</em></strong></h2><br/>
                        
  <p>A threaded base class with a built in mutex for convenience.</p>
<p>Users can extend this base class by public inheritance like this:</p>
<pre><code>class MyThreadedClass: public &lt;a href="../utils/ofThread.html" class="docs_class" &gt;ofThread&lt;/a&gt;     {
    public:
    ...
    void threadedFunction()
    {
        while(isThreadRunning())
        {
            Threaded function here.
        }
    }
};
</code></pre>
<p><a href="../utils/ofThread.html" class="docs_class" >ofThread</a> is a convenient wrapper for Poco::Thread, Poco::Runnable and
Poco::Mutex.  It represents a simplified (sometimes overly simplified -
or simplified in ways that might not make sense for your project)
pathway for quickly writing threaded classes.  Poco::Runnable represents
a class that can be "run" via its void run() method.  Poco::Thread is
able to spawn a thread and "run" the contents of a class that extends
the Poco::Runnable interface (which <a href="../utils/ofThread.html" class="docs_class" >ofThread</a> does).  Poco::FastMutex,
(aka ofMutex) is a "mutual exclusion" object that prevents two threads
from accessing the same data at the same time.  It is important to know
that Poco::FastMutex (aka ofMutex) is not "recursive" while Poco::Mutex
is. This means that if the same thread attempts to lock a thread while
it ALREADY has a lock on the mutex, the program will lock up and go
nowhere.  Thus, it is important that <a href="../utils/ofThread.html" class="docs_class" >ofThread</a> subclasses carefully
their use of the mutex.  Currently <a href="../utils/ofThread.html" class="docs_class" >ofThread</a> does not lock its own mutex
at any point (e.g. ofThread's internal variables are not thread safe).
This is a somewhat dangerous convenience that is (theoretically)
supposed to make it easier for subclasses to avoid the recursive mutex
"problem". The situation that arises from two threads simultanously
reading or writing from the same shared data (shared data
occupies the same physical location in memory) leads to something
called a "race condition", which can lead to deadlocks.
A deadlock is as bad as it sounds.  It means your program
just stops.  ofMutex prevents race conditions, deadlocks and crashes by
permitting only one thread access to shared data at a time.  When using
mutexes to protect data, the trick is to always be sure to unlock the
mutex when finished.  This problem can often be avoided by using
an Poco::FastMutex::ScopedLock (aka ofScopedLock).  See the
the documentation for more information.  Finally, there are many cases
where it might make more sense to use Poco::Thread, Poco::Runnable and
Poco::FastMutex directly rather than using ofThread.  Further, cross
platform thread management will be alleviated with the std::thread
support library included with C++11.</p>
<p>Uncaught Exceptions throw from within <a href="../utils/ofThread.html" class="docs_class" >ofThread</a> will cause the thread to stop
and the Exception will be delivered to the default ofBaseThreadErrorHandler.
The ofBaseThreadErrorHandler will print the exception details, if available.
The ofBaseThreadErrorHandler offers no opportunity to take corrective action
and only allows the user to receive more valuable debugging information
about the uncaught exception.  Users should design <a href="../utils/ofThread.html" class="docs_class" >ofThread</a> subclasses to
catch and respond to all anticipated exceptions.</p>

                    </div>   
              
              
  

           </div>
                  
            <!-- methods detail -->
              <!--h2><a name="methods"></a>ofThread methods</h2-->
                        
<div class="documentation_detail getCurrentPocoThread" data-lookup="getCurrentPocoThread" data-item-type="method">
  	 
	<h1><a name="show_getCurrentPocoThread">getCurrentPocoThread()</a></h1>
	<h2>
  <p>Poco::Thread * ofThread::getCurrentPocoThread()</p>
</h2>
	<div class="documentation_detail_description">
		
		
  


                <h2><strong><em>Documentation from code comments</em></strong></h2><br/>

		        
  <p>Get the current Poco thread.</p>
<p>In most cases, it is more appropriate to query the current
thread by calling isCurrentThread() on an active thread or
by calling ofThread::isMainThread().  See the method
documentation for more information on those methods.</p>
<p>Returns: A pointer to the current active thread OR 0 iff the main
    application thread is active.</p>

    
	</div>
	<!--div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div-->
</div>


    
                        
<div class="documentation_detail getPocoThread" data-lookup="getPocoThread" data-item-type="method">
  	 
	<h1><a name="show_getPocoThread">getPocoThread()</a></h1>
	<h2>
  <p>Poco::Thread &amp; ofThread::getPocoThread()</p>
</h2>
	<div class="documentation_detail_description">
		
		
  


                <h2><strong><em>Documentation from code comments</em></strong></h2><br/>

		        
  <p>Get a reference to the underlying Poco thread.</p>
<p>Poco::Thread provides a clean cross-platform wrapper for
threads.  On occasion, it may be useful to interact with the
underlying Poco::Thread directly.</p>
<p>Returns: A reference to the backing Poco thread.</p>

    
	</div>
	<!--div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div-->
</div>


    
                        
<div class="documentation_detail getPocoThread" data-lookup="getPocoThread" data-item-type="method">
  	 
	<h1><a name="show_getPocoThread">getPocoThread()</a></h1>
	<h2>
  <p>const Poco::Thread &amp; ofThread::getPocoThread()</p>
</h2>
	<div class="documentation_detail_description">
		
		
  


                <h2><strong><em>Documentation from code comments</em></strong></h2><br/>

		        
  <p>Get a const reference to the underlying Poco thread.</p>
<p>Poco::Thread provides a clean cross-platform wrapper for
threads.  On occasion, it may be useful to interact with the
underlying Poco::Thread directly.</p>
<p>Returns: A reference to the backing Poco thread.</p>

    
	</div>
	<!--div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div-->
</div>


    
                        
<div class="documentation_detail getThreadId" data-lookup="getThreadId" data-item-type="method">
  	 
	<h1><a name="show_getThreadId">getThreadId()</a></h1>
	<h2>
  <p>int ofThread::getThreadId()</p>
</h2>
	<div class="documentation_detail_description">
		
		
  


                <h2><strong><em>Documentation from code comments</em></strong></h2><br/>

		        
  <p>Get the unique thread id.
\note This is NOT the the same as the operating thread id!</p>

    
	</div>
	<!--div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div-->
</div>


    
                        
<div class="documentation_detail getThreadName" data-lookup="getThreadName" data-item-type="method">
  	 
	<h1><a name="show_getThreadName">getThreadName()</a></h1>
	<h2>
  <p>string ofThread::getThreadName()</p>
</h2>
	<div class="documentation_detail_description">
		
		
  


                <h2><strong><em>Documentation from code comments</em></strong></h2><br/>

		        
  <p>Get the unique thread name, in the form of "Thread id#"</p>
<p>Returns: the Thread ID string.</p>

    
	</div>
	<!--div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div-->
</div>


    
                        
<div class="documentation_detail isCurrentThread" data-lookup="isCurrentThread" data-item-type="method">
  	 
	<h1><a name="show_isCurrentThread">isCurrentThread()</a></h1>
	<h2>
  <p>bool ofThread::isCurrentThread()</p>
</h2>
	<div class="documentation_detail_description">
		
		
  


                <h2><strong><em>Documentation from code comments</em></strong></h2><br/>

		        
  <p>Query whether the current thread is active.</p>
<p>In multithreaded situations, it can be useful to know which
thread is currently running some code in order to make sure
only certain threads can do certain things.  For example,
OpenGL can only run in the main execution thread.  Thus,
situations where a thread is responsible for interacting
with graphics resources may need to prevent graphics updates
unless the main thread is accessing or updating resources
shared with this ofThread (or its subclass).</p>
<pre><code>if(myThread.isCurrentThread())
{
    // do some myThread things,
    // but keep your hands off my resources!
}
else if(ofThread::isMainThread())
{
    // pheew! ok, update those graphics resources
}
</code></pre>
<p>By way of another example, a subclass of ofThread may have
an update() method that is called from ofBaseApp during the
execution of the main application thread.  In these cases,
the ofThread subclass might want to ask itself whether it
can, for instance, call update() on an ofImage, in order to
send copy some ofPixels to an ofTexture on the graphics
card.</p>
<p>Returns: True iff this ofThread the currently active thread.</p>

    
	</div>
	<!--div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div-->
</div>


    
                        
<div class="documentation_detail isMainThread" data-lookup="isMainThread" data-item-type="method">
  	 
	<h1><a name="show_isMainThread">isMainThread()</a></h1>
	<h2>
  <p>bool ofThread::isMainThread()</p>
</h2>
	<div class="documentation_detail_description">
		
		
  


                <h2><strong><em>Documentation from code comments</em></strong></h2><br/>

		        
  <p>A query to see if the current thread is the main thread.</p>
<p>Some functions (e.g. OpenGL calls) can only be executed
the main thread.  This static function will tell the user
what thread is currently active at the moment the method
is called.</p>
<pre><code>if (ofThread::isMainThread())
{
    ofLogNotice() &lt;&lt; "This is the main thread!";
}
else
{
    ofLogNotice() &lt;&lt; "This is NOT the main thread.";
}
</code></pre>
<p>Returns: true iff the current thread is the main thread.</p>

    
	</div>
	<!--div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div-->
</div>


    
                        
<div class="documentation_detail isThreadRunning" data-lookup="isThreadRunning" data-item-type="method">
  	 
	<h1><a name="show_isThreadRunning">isThreadRunning()</a></h1>
	<h2>
  <p>bool ofThread::isThreadRunning()</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>Returns true if the thread is currently running. This is especially useful inside the thread's threadedFunction() when you want it to loop continuously until it's told to exit:</p>
<pre><code class="cpp">
class MyThread : public ofThread {

    ...

    // the thread function
    void MyThread::threadedFunction() {

        // start

        while(isThreadRunning()) {

            // do stuff
        }

        // done
    }

};

</code></pre>


            <div class="inlined_docs">
                <h2><strong><em>Documentation from code comments</em></strong></h2><br/>

		        
  <p>Check the running status of the thread.</p>
<p>Returns: true iff the thread is currently running.</p>

            </div>
    
	</div>
	<!--div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div-->
</div>


    
                        
<div class="documentation_detail lock" data-lookup="lock" data-item-type="method">
  	 
	<h1><a name="show_lock">lock()</a></h1>
	<h2>
  <p>bool ofThread::lock()</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>Try to lock the mutex.</p>
<p>If the thread was started in blocking mode in startThread(), any thread (including your app main loop) will wait until the mutex is unlocked.</p>
<p>If the thread is non-blocking, this call will immediately return a true or false if the mutex is available. It is up to you to make sure the resource is not being used when accessing it. See the <a href="http://en.wikipedia.org/wiki/Non-blocking_algorithm">Wikipedia article on Non-blocking</a> for reasons as to why using a non-blocking thread might be more advantageous.</p>


            <div class="inlined_docs">
                <h2><strong><em>Documentation from code comments</em></strong></h2><br/>

		        
  <p>Try to lock the mutex.</p>
<p>If the thread was started startThread(true), then this call will wait
until the mutex is available and return true.  If the thread was started
startThread(false), this call will return true iff the mutex is
was successfully acquired.</p>
<p>Returns: true iff the lock was successfully acquired.</p>

            </div>
    
	</div>
	<!--div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div-->
</div>


    
                        
<div class="documentation_detail sleep" data-lookup="sleep" data-item-type="method">
  	 
	<h1><a name="show_sleep">sleep(...)</a></h1>
	<h2>
  <p>void ofThread::sleep(long milliseconds)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  


                <h2><strong><em>Documentation from code comments</em></strong></h2><br/>

		        
  <p>Tell the thread to sleep for a certain amount of milliseconds.</p>
<p>This is useful inside the threadedFunction() when a thread is waiting
for input to process:</p>
<pre><code>void MyThreadedClass::threadedFunction()
{
        // start
        while(isThreadRunning())
    {
        // bReadyToProcess can be set from outside the threadedFuntion.
        // perhaps by another thread that downloads data, or loads
        // some media, etc.

            if(bReadyToProcess == true)
        {
                // do some time intensive processing
                bReadyToProcess = false;
            }
        else
        {
                // sleep the thread to give up some cpu
                sleep(20);
            }
        }
        // done
}
</code></pre>
<p>If the user does not give the thread a chance to sleep, the
thread may take 100% of the CPU core while it's looping as it
waits for something to do.  This may lead to poor application
performance.</p>
<p>Parameters:
milliseconds The number of milliseconds to sleep.</p>

    
	</div>
	<!--div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div-->
</div>


    
                        
<div class="documentation_detail startThread" data-lookup="startThread" data-item-type="method">
  	 
	<h1><a name="show_startThread">startThread(...)</a></h1>
	<h2>
  <p>void ofThread::startThread(bool mutexBlocks=true)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  


                <h2><strong><em>Documentation from code comments</em></strong></h2><br/>

		        
  <p>Start the thread with options.</p>
<p>Parameters:
mutexBlocks Set blocking to true if you want the mutex to
       block when lock() is called.
\note Subclasses can directly access the mutex and employ thier
      own locking strategy.</p>

    
	</div>
	<!--div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div-->
</div>


    
                        
<div class="documentation_detail stopThread" data-lookup="stopThread" data-item-type="method">
  	 
	<h1><a name="show_stopThread">stopThread()</a></h1>
	<h2>
  <p>void ofThread::stopThread()</p>
</h2>
	<div class="documentation_detail_description">
		
		
  


                <h2><strong><em>Documentation from code comments</em></strong></h2><br/>

		        
  <p>Stop the thread.</p>
<p>This does immediately stop the thread from processing, but
will only set a flag that must be checked from within your
threadedFunction() by calling isThreadRunning().  If the user wants
to both stop the thread AND wait for the thread to finish
processing, the user should call waitForThread(true, ...).</p>

    
	</div>
	<!--div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div-->
</div>


    
                        
<div class="documentation_detail unlock" data-lookup="unlock" data-item-type="method">
  	 
	<h1><a name="show_unlock">unlock()</a></h1>
	<h2>
  <p>void ofThread::unlock()</p>
</h2>
	<div class="documentation_detail_description">
		
		
  <p>Unlock the mutex.</p>
<p>This only unlocks the mutex if the calling thread had previously locked it, otherwise the functions does nothing and does not block.</p>


            <div class="inlined_docs">
                <h2><strong><em>Documentation from code comments</em></strong></h2><br/>

		        
  <p>Unlock the mutex.</p>
<p>This will only unlocks the mutex if it was previously by the same
calling thread.</p>

            </div>
    
	</div>
	<!--div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div-->
</div>


    
                        
<div class="documentation_detail waitForThread" data-lookup="waitForThread" data-item-type="method">
  	 
	<h1><a name="show_waitForThread">waitForThread(...)</a></h1>
	<h2>
  <p>void ofThread::waitForThread(bool callStopThread=true, long milliseconds)</p>
</h2>
	<div class="documentation_detail_description">
		
		
  


                <h2><strong><em>Documentation from code comments</em></strong></h2><br/>

		        
  <p>Wait for the thread to exit (aka "joining" the thread).</p>
<p>This method waits for a thread will "block" and wait for the
thread (aka "join" the thread) before it returns.  This allows the
user to be sure that the thread is properly cleaned up.  An example
of when this might be particularly important is if the
threadedFunction() is opening a set of network sockets, or
downloading data from the web.  Destroying an ofThread subclass
without releasing those sockets (or other resources), may result in
segmentation faults, error signals or other undefined behaviors.</p>
<p>Parameters:
callStopThread Set stop to true if you want to signal the thread
    to exit before waiting.  This is the equivalent to calling
    stopThread(). If you your threadedFunction uses a while-loop that
    depends on isThreadRunning() and you do not call stopThread() or set
    stop == true, waitForThread will hang indefinitely.  Set stop ==
    false ONLY if you have already called stopThread() and you simply
    need to be sure your thread has finished its tasks.</p>
<p>milliseconds If millseconds is set to INFINITE_JOIN_TIMEOUT, the
    waitForThread will wait indefinitely for the thread to complete.  If
    milliseconds is set to a lower number (e.g. 10000 for 10 seconds),
    waitForThread will wait for 10000 milliseconds and if the thread has
    not yet stopped it will return and log an error message.  Users are
    encouraged to use the default INFINITE_JOIN_TIMEOUT.  If the user is
    unhappy with the amount of time it takes to join a thread, the user
    is encouraged to seek more expedient ways of signalling their desire
    for a thread to complete via other signalling methods such as
    Poco::Event, Poco::Condition, or Poco::Semaphore.</p>
<p>See also: http://pocoproject.org/slides/090-NotificationsEvents.pdf</p>
<p>See also: http://pocoproject.org/docs/Poco.Condition.html</p>
<p>See also: http://pocoproject.org/docs/Poco.Event.html</p>
<p>See also: http://pocoproject.org/docs/Poco.Semaphore.html</p>

    
	</div>
	<!--div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div-->
</div>


    
                        
<div class="documentation_detail yield" data-lookup="yield" data-item-type="method">
  	 
	<h1><a name="show_yield">yield()</a></h1>
	<h2>
  <p>void ofThread::yield()</p>
</h2>
	<div class="documentation_detail_description">
		
		
  


                <h2><strong><em>Documentation from code comments</em></strong></h2><br/>

		        
  <p>Tell the thread to give up its CPU time other threads.</p>
<p>This method is similar to sleep() and can often be used in
the same way.  The main difference is that 1 millisecond
(the minimum sleep time available with sleep()) is a very
long time on modern processors and yield() simply gives up
processing time to the next thread, instead of waiting for
number of milliseconds. In some cases, this behavior will
be preferred.</p>

    
	</div>
	<!--div class="documentation_detail_wide_col_nav"><a href="#top">&uarr;</a></div-->
</div>


    

            <!-- vars detail -->

            <!-- functions detail -->
            <hr/>
                
            <!--diqus comments for class/functions module description-->
            <div id="comments_header">
            <h2>comments</h2>
            <p>You can add comments with usage examples or other information for each class, method or variable, for adding documentation to an empty section or reporting errors is better to send a fix or open an issue through <a href="https://github.com/openframeworks/ofSite">github</a>.</p>
            <p>When posting code enclose it in:</p>
            <pre><code class="html">&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;&nbsp;&lt;/code&gt;&lt;/pre&gt;</code></pre>
            <br/>
            </div>
            <div id="disqus_thread"></div>
            <script type="text/javascript">

            // DISQUS
            /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */

            var disqus_shortname = 'openframeworks'; // required: replace example with your forum shortname
            //var disqus_developer = 1;

            location_elements = window.location.pathname.split("/");
            module_name = location_elements[location_elements.length-1].split(".")[0];
            section_name = location.hash.split("_")[1];
            console.log(module_name + " " + section_name);
            if(section_name!=undefined && section_name!=''){
            var disqus_identifier = window.location.pathname + "#!show_" + section_name;  
            var disqus_url = window.location.protocol + "//" + window.location.host + window.location.pathname + "#!show_" + section_name;
            var discus_title = document.title + " - " + section_name;
            }else{
            var disqus_identifier = window.location.pathname;
            var disqus_url = window.location.protocol + "//" + window.location.host + window.location.pathname;
            var discus_title = document.title;
            }


            /* * * DON'T EDIT BELOW THIS LINE * * */   
            (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
            </script>
            <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
            <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
		
        </div><!-- End Submenu right -->
      </div><!-- End page wide -->
      </div><!-- End body wrap -->
      
      <div id="footer">
        
  <p id="credits">


  
Monday, 04 January 2016 21:15:44 UTC
에 마지막으로 업데이트됨&nbsp;&nbsp;&nbsp;-&nbsp;&nbsp;&nbsp;<a href="https://github.com/icq4ever/ofSiteKR/commit/

3734228d83e3fbb6a599e2e551bfb68beceaefbd
">

3734228d83e3fbb6a599e2e551bfb68beceaefbd
</a>

<!--br/>RSS feeds for <a href="/feed">Entries</a-->

<br/>
<!--Hosting for openFrameworks is generously provided by Rackspace-->
hosting for openFrameworks.kr is provided by github.com
</p>


<!--tracking -->
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
var pageTracker = _gat._getTracker("UA-71930909-1");
pageTracker._trackPageview();
} catch(err) {}</script>






      </div> <!-- End Footer -->
    </div> <!-- End Content -->
  </body>
</html>





