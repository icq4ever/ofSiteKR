








<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    
	
  <title>openFrameworks.kr</title>

<!-- syntax highlighting for the documentation -->
<script src="http://openframeworks.kr/js/shCore.js" type="text/javascript"></script>
<script src="http://openframeworks.kr/js/shAutoloader.js" type="text/javascript"></script>
<script src="http://openframeworks.kr/js/shBrushCpp.js" type="text/javascript"></script>
<script src="http://openframeworks.kr/js/shBrushJava.js" type="text/javascript"></script>
<script src="http://openframeworks.kr/js/shBrushXml.js" type="text/javascript"></script>
<link href="http://openframeworks.kr/css/shCore.css" rel="stylesheet" type="text/css" />
<link href="http://openframeworks.kr/css/shThemeDefault.css" rel="stylesheet" type="text/css" />

<link rel="stylesheet" type="text/css" href="http://openframeworks.kr/css/style.css" media="all" />
<link rel="stylesheet" type="text/css" href="http://openframeworks.kr/css/print.css" media="print" />
<link href='http://fonts.googleapis.com/css?family=Questrial' rel='stylesheet' type='text/css'>
<link rel="search" type="application/opensearchdescription+xml" href="http://openframeworks.kr/opensearch.xml" title="openFrameworks.kr"/>

<link rel="shortcut icon" href="http://openframeworks.kr/favicon.ico" />
<link rel="icon" href="http://openframeworks.kr/favicon.ico" type="image/x-icon" />

<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.6.4/jquery.min.js" type="text/javascript"></script>
<script type="text/javascript" src="http://openframeworks.kr/js/jquery.timeago.js" type="text/javascript"></script>

<meta name="google-site-verification" content="RiGtl9pFuFnUeEQ4MU1miiutTR5mmCPUi38YLCn-M-g" />


    <script src="http://openframeworks.kr/js/jquery.columnizer.min.js"></script>
    <script src="http://openframeworks.kr/js/documentation.js"></script>
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-71930909-1', 'auto');
      ga('send', 'pageview');

    </script>
  </head>
  <body>
    <div id="content">
      
  

<div id="head">

		<div id="head-left">
			<a href="http://openframeworks.kr" class="nohover"><img src="http://openframeworks.kr/images/of-logo.svg" border="0" alt="openFrameworks" /></a>
		</div>

		<div id="head-right">
		<ul>
	        <li><a href="http://openframeworks.kr/about" class="" >소개</a></li>
	        <li><a href="http://openframeworks.kr/download" class="" >다운로드</a></li>
	        <li><a href="http://openframeworks.kr/documentation" class="">도큐먼트</a></li>
	        <li><a href="http://openframeworks.kr/tutorials" class="">튜토리얼</a></li>
	        <li><a href="http://openframeworks.kr/gallery" class="">갤러리</a></li>
	        <li><a href="http://openframeworks.kr/community" class="">커뮤니티</a></li> 
	        <li><a href="http://openframeworks.kr/development" class="" >개발</a></li>
		</ul>
		
		<ul class="menu-externals">
			<li><span class="external-dot"> ></span>&nbsp;<a href="http://forum.openframeworks.cc" target="_blank">포럼(EN)</a></li>
			<li><span class="external-dot"> ></span>&nbsp;<a href="http://forum.openframeworks.kr" target="_blank">포럼(KR)</a></li>
			<li><span class="external-dot"> ></span>&nbsp;<a href="http://ofxaddons.com" target="_blank">애드온</a></li>
			<li><span class="external-dot"> ></span>&nbsp;<a href="http://github.com/openframeworks/openFrameworks" target="_blank">github</a></li>
			<li><span class="external-dot"> ></span>&nbsp;<a href="http://openframeworks.cc/list-info" target="_blank">메일링 리스트</a></li>
			<li><span class="external-dot"> ></span>&nbsp;<a href="http://forum.openframeworks.kr/t/slack/32" target="_blank">slack</a></li>
			<li><span class="external-dot"> ></span>&nbsp;<a href="http://blog.openframeworks.cc/" target="_blank">블로그</a></li>
		</ul>
		
			<!--form method="get" id="searchform" action="/index.php">
			<input type="text" value="" name="s" id="s" class="search_input" /> <input type="submit" value="Search" class="search_button"/>
			</form-->
			<!--form method="post" action="http://scripts.dreamhost.com/add_list.cgi">
                <input type="hidden" name="list" value="list@openframeworks.cc" />
                <input type="hidden" name="domain" value="openframeworks.cc" />
                <input type="hidden" name="url" value="http://openframeworks.cc/list-info/subscribe.html"  />
                <input type="hidden" name="unsuburl" value="http://openframeworks.cc/list-info/unsubscribe.html" />
                <input type="hidden" name="alreadyonurl" value="http://openframeworks.cc/list-info/already.html" />
                <input type="hidden" name="notonurl" value="http://openframeworks.cc/list-info/not.html" />
                <input type="hidden" name="invalidurl" value="http://openframeworks.cc/list-info/invalid.html" />
                <input type="hidden" name="emailconfirmurl" value="http://openframeworks.cc/list-info/confirm.html" />
                <input type="hidden" name="emailit" value="1" />
                name: <input name="name" /> <br />
                email: <input name="email" /><br />
                <span class='but'><input type="submit" name="submit" value="subscribe" /></span> <br/ >
                <span class='but'><input type="submit" name="unsub" value="unsubscribe" /></span>
            </form-->
        <ul class="submenu">
            <li><a href="http://openframeworks.cc">english</a></li>
            <li>/</li>
            <li><a href="http://openframeworks.jp">japanese</a></li>
			<li>/</li>
			<li>korean</li>
        </ul>
		</div>
</div><!-- head -->



      <div id="body-wrap">	
	    <div class="page-wide-tutorial">
            <!--ul class="submenu">
                <li><a href="/documentation">레퍼런스</a></li>
                <li><a href="/tutorials">튜토리얼</a></li>
            </ul-->
    	    <h1>ofTutorials - Chapter 1 - Getting Started</h1>
    	    <span class="article_meta">February 2012&nbsp;&nbsp;&nbsp;-&nbsp;&nbsp;&nbsp;<a href="http://jeffcrouse.info">Jeff Crouse</a></span><br/>
    	    <div class="article">
        		<a name="preamble"></a>
<blockquote>
<p><strong>업데이트! 새로운 프로젝트 생성기</strong>: <em>As of openFrameworks 0072 we have a <a href="http://openframeworks.cc/tutorials/introduction/002_projectGenerator.html">new tool called projectGenerator</a> to create new openFrameworks projects, including addons. In previous versions, creating a new openFrameworks project involved duplicating an existing example app and adding the addons by hand as described in the tutorial below. With the project generator project creation is faster and less error-prone. We highly recommend it. <a href="http://openframeworks.cc/tutorials/introduction/002_projectGenerator.html">Check it out now!</a></em></p>
<p align="right">
</p>
</blockquote>
<p>이 챕터에서는 프로젝트를 생성 및 실행윈도우 크기를 지정, 기본 도형을 그리는 등의 오픈프레임웍스를 처음 시작하는 기초적인 단계들을 다룹니다. 하지만 먼저 &#8230;</p>
<hr>
<h2><a name="_your_first_look_inside_of"></a>1. Your First look inside oF</h2>
<p>여기서는, 여러분이 <a href="http://www.openframeworks.cc/download/">오픈프레임웍스를 다운및 셋업가이드</a>를 따라했다고 가정합니다. 우선 여러분이 해야할 일은 압축된 오픈프레임웍스를 여러분이 접근하기 쉬운 폴더에 압축을 푸는 것입니다. 개인적으로, 저는 폴더를 내문서에 위치시키고 사이드바에 바로가기를 만들어둡니다. 이렇게 말이죠 :</p>
<p><img src="images/shortcut.png" style="border-width: 0;" alt="Shortcut" width="600"></p>
<p>어디에 위치해두건, 폴더를 열어보면, 아래 같은 폴더가 보일 것입니다:</p>
<div>
<img src="images/structure1.png" style="border-width: 0;" alt="addons">
</div>
<p>그렇다면, 이 폴더들은 무엇일까요?</p>
<dl>
<dt>
addons
</dt>
<dd>
<p>
        오픈프레임웍스 "core"는 가장 핵심적인 기능들만 담겨있습니다. addon 폴더내의 것들은 어플리케이션 조각들로 추가될 수 있습니다. 이렇게 포함 되는 것들은 XML파일을 읽는다던가, 3D 모델을 불러오거나, 또는 컴퓨터 비전 라이브러리인 openCV같은것들입니다.
</p>
</dd>
<dt>
apps
</dt>
<dd>
<p>
        이 폴더는 여러분이 만든 어플리케이션이 저장될 곳입니다. 또한 여러분이 주로 작업하는 곳이죠. "apps"폴더내에 "myApps"라는 폴더가 있는걸 보실수 있습니다.
</p>
</dd>
<dt>
examples
</dt>
<dd>
<p>
        이 폴더는 예제 어플리케이션들이 담겨있으며, 오픈프레임웍스로 무엇을 할수 있는지 살펴볼 수 있습니다.
</p>
</dd>
<dt>
libs
</dt>
<dd>
<p>
    이 폴더는 오픈프레임웍스가 ofCore로 사용하는 라이프러리들이 담겨있습니다.
</p>
</dd>
</dl>
<hr>
<h2><a name="_take_a_tour_of_the_examples"></a>2. Take a Tour of the Examples</h2>
<p>"examples"폴더는 오픈프레임웍스로 할수 있는 것들을 보여주는 프로젝트들이 담겨있습니다. 여러분이 직접 앱을 만들기 전에 이 예제들을 살펴보는것은 좋은 생각입니다. 이 과정은 여러분이 사용하는 IDE에 따라 약간 다릅니다.</p>
<h3><a name="_xcode"></a>2.1. XCode</h3>
<p>examples/graphicsExample폴더로 이동하여 "graphicsExample.xcodeproj"파일을 더블릭합니다.</p>
<div>
<img src="images/graphicsExample01.png" style="border-width: 0;" alt="navigate to graphicsExample" width="800">
</div>
<p>아마 아래와 같은 윈도우가 보일것입니다:</p>
<div>
<img src="images/graphicsExample02.png" style="border-width: 0;" alt="graphicsExample 02" width="800">
</div>
<table frame="void" cellpadding="8">
<tr valign="top"><td><p><b><u>Important</u></b></p></td>
<td style="border-left: 1px solid silver;">메뉴 바에서 어떤 버전을 사용하고 있는지 살펴보세요: Xcode &gt; About Xcode에서 보실수 있습니다. 사용하고 있는 Xcode가 4.0 이하 버전이라면,  윈도우는 상당히 다를것이지만, 혼란스러워하지 마세요&#8201;&#8212;&#8201;대응되는 인터페이스 기능들은 충분히 쉽게 찾을 수 있습니다.</td></tr></table>
<p>화면의 좌측 상단에 커다란 "Run" 버튼이 있을것입니다. Xcode 3에서는, "Build &amp; Run"이라고 불렸었습니다. 이 버튼을 눌러  현재 활성화된 타겟으로 실행할 수 있습니다. 하지만 여러분도 곧 알아차리시겠지만, 기본적으로, 활성화된 타겟은 openFrameworks라이브러리입니다. 이럴 경우 말그대로, 아무일도 발생하지 않습니다. 우리가 원하는것은 "graphicsExample"프로그램을 실행하는 것이죠. 따라서 아래와 같이 보인다면:</p>
<div>
<img src="images/target-bad.png" style="border-width: 0;" alt="openFrameworks library chosen" width="400">
</div>
<p>클릭하여 아래로 그래그하면 이와같이 보입니다:</p>
<div>
<img src="images/target-good.png" style="border-width: 0;" alt="graphicsExample target chosen" width="400">
</div>
<p>이제 "Run"버튼을 클릭하면, 이 화면이 보일겁니다:</p>
<div>
<img src="images/graphicsExample03.png" style="border-width: 0;" alt="graphicsExample, running" width="800">
</div>
<p>원과 오렌지색 원은 분명히 크기가 일정하게 변할것이고, 사각형들은 랜덤하게 그려질것입니다. 위에 위치한 빨간색 바는 페이드아웃되고, 선들은 부드럽게 변합니다. ESC나 Apple+Q를 눌러 프로그램을 종료합니다.</p>
<table frame="void" cellpadding="8">
<tr valign="top"><td><p><b><u>Warning</u></b></p></td>
<td style="border-left: 1px solid silver;">
<p><b>컴파일 문제해결</b></p>
<p>If you are getting errors, try switching the "Base SDK" setting to 10.6
만약 에러가 발생하면, "Base SDK"세팅을 10.6으로 바꿔보십시오</p>
<ol type="1">
<li>
<p>
좌측끝 섹션에서 "graphicsExample"을 클릭합니다
</p>
</li>
<li>
<p>
아레에 보이는 "Build Settings"를 클릭합니다.
</p>
</li>
<li>
<p>
아래에 보이는것처럼 "All"과 "Combinded"가 선택되었는지 확인합니다.
</p>
</li>
<li>
<p>
*Base SDK"를 찾아, 클릭하여 "10.6"을 선택합니다.
</p>
</li>
</ol>
<p><img src="images/tenpointsix.png" style="border-width: 0;" alt="10.6 Fix" width="600"></p>
<p>모든 프로젝트마다 이런 과정을 거쳐야 할것 이므로, 익숙해지셔야 할겁니다 :)</p>
</td></tr></table>
<p>이제 다른 예제들을 열어서 실행해보세요.</p>
<h3><a name="_code_blocks"></a>2.2. Code::Blocks</h3>
<p>Code::Blocks를 여세요. 기본 화면은 아래와 같습니다:</p>
<div>
<img src="images/oF_codeblocks_1.png" style="border-width: 0;" alt="default empty workspace of Code::Blocks" width="800">
</div>
<p>"Open an existing project"클릭하거나 또는 Ctrl+O를 사용하여 파일브라우저를 엽니다. 이제 오픈프레임웍스 예제 디렉토리로 이동하여 graphics/graphicsExample폴더로 들어갑니다. 화면 뷰에서 "All files <strong>.</strong>"가 선택되었는지 꼭 확인하세요. Code::Blocks프로젝트인 "graphicsExample.workspace" (graphicsExample.cbp가 <strong>아닙니다</strong>)를 여세요.</p>
<div>
<img src="images/oF_codeblocks_2.png" style="border-width: 0;" alt="file browser for graphicsExample Code::Blocks workspace" width="400">
</div>
<p>workspace가 있어야 컴파일러가 관련된 라이브러리를 찾을 수 있습니다. 만약 workspace가 불려지지 않으면, 개발환경은 최종 실행파일을 생성하기 위한 중요한 정보가 부족하게 됩니다. workspace가 성공적으로 볼러와지면,</p>
<div>
<img src="images/oF_codeblocks_3.png" style="border-width: 0;" alt="graphicsExample Code::Blocks workspace" width="800">
</div>
<p>상단의 작은 기어 버튼을 클릭하거나 Ctrl+F9를 눌러 프로젝트를 빌드(컴파일)할 수 있습니다. 작은 녹색 삼각형버튼을 누르거나 Ctrl+F10을 눌러 프로젝트를 실행할 수 있습니다. F9를 눌러 이 두가지 과정을 조합할 수 있습니다. 결과는 아래와 같이 보일것입니다:</p>
<div>
<img src="images/graphicsExample03.png" style="border-width: 0;" alt="graphicsExample, running" width="800">
</div>
<p>원과 오렌지색 원은 분명히 크기가 일정하게 변할것이고, 사각형들은 랜덤하게 그려질것입니다. 위에 위치한 빨간색 바는 페이드아웃되고, 선들은 부드럽게 변합니다. ESC나 Apple+Q를 눌러 프로그램을 종료합니다.</p>
<h3><a name="_command_line"></a>2.3. command-line</h3>
<p>사실 오픈프레임웍스 예제를 빌드하기 위해 꼭 IDE가 필요한것은 아닙니다. 모든 도구는 커맨드라인 모드에서도 실행할 수 있기 때문이죠. 예제를 빌드하기 위해 터미널 윈도우를 열고, 오픈프레임웍스가 있는 폴더로 이동합니다. 그곳에서 examples 디렉토리로 들어갑니다. 예를 들어 "graphics Example":</p>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="10"><tr><td>
<pre><code class="cpp">cd examples/graphics/graphicsExample</code></pre>
</td></tr></table>
<p>코드를 빌드하고 실행하기 위해 아래의 명령을 사용합니다.</p>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="10"><tr><td>
<pre><code class="cpp">$ make
$ make run</code></pre>
</td></tr></table>
<p>명령이 실행되면 마침내 위에서 보았던 똑같은 화면이 보여질 것입니다.</p>
<div>
<img src="images/graphicsExample03.png" style="border-width: 0;" alt="graphicsExample, running" width="800">
</div>
<p>원과 오렌지색 원은 분명히 크기가 일정하게 변할것이고, 사각형들은 랜덤하게 그려질것입니다. 위에 위치한 빨간색 바는 페이드아웃되고, 선들은 부드럽게 변합니다. ESC나 Apple+Q를 눌러 프로그램을 종료합니다.</p>
<p>만약 아래 명령을 사용하면, 모든 빌드는 제거되고 디렉토리가 깔끔하게 비워질 것입니다.</p>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="10"><tr><td>
<pre><code class="cpp">$ make clean</code></pre>
</td></tr></table>
<p>이는 코드를 변경하고, 새로 빌드하는 것이 예전에 컴파일됐던 파트들을 다시 사용하지 않게 할 때에 유용합니다.</p>
<hr>
<h2><a name="_creating_your_first_project"></a>3. Creating Your First Project</h2>
<table frame="void" cellpadding="8">
<tr valign="top"><td><p><b><u>Note</u></b></p></td>
<td style="border-left: 1px solid silver;">
<p><b>Code::Blocks note</b></p>
<p>이 섹션은 예시로 드는 IDE로 XCode에 촛점이 맞춰져있습니다. 여기에서 제공되는 일반적인 정보들은 Code::Blocks에도 동일하게 적용됩니다. Code::Blocks프로젝트 파일은 ".xcodeproj"대신 .workspace"확장자를 사용합니다. IDE 에 관한 질문이 있으시다면 <a href="http://www.codeblocks.org/user-manual">Code::Blocks 매뉴얼</a>을 살펴봐주시기 바랍니다.</p>
</td></tr></table>
<p>소개부분에서 언급했듯이, 오픈프레임웍스는 여러분이 선택한 IDE의 지루한 C++ project 세팅을 담당합니다. 하지만 Flash나 Processing 프로그램과는 다르게, 프로젝트를 생성하는 "파일 &gt; 새 파일"은 없습니다. 대신에 새 프로젝트를 생성하기 위해 <a href="http://openframeworks.cc/tutorials/introduction/002_projectGenerator.html">projectGenerator</a>를 사용하실 수 있습니다. 예전(openFrameworks 0072 이전)에는 추천되는 방법은 예제프로젝트중 하나를 복제하는 것이었습니다.</p>
<table frame="void" cellpadding="8">
<tr valign="top"><td><p><b><u>Important</u></b></p></td>
<td style="border-left: 1px solid silver;">
<p>좀더 설명하자면, 예제파일을 복제한다는 말은 어떠한 예제 프로젝트라 하더라도 절대 편집하면 안되고, 여러분의 앱을 예제 폴더에 두지 말라는 의미입니다. 이것들은 여러분의 앱을 위해 시작지점으로 제공되도록 위치하고 있으므로, 원시적으로 유지하시는것이 좋습니다. 앞으로 이것의 중요성을 알게 될것입니다..  <a href="http://openframeworks.cc/tutorials/introduction/002_projectGenerator.html">projectGenerator</a>를 사용하시는게 좋습니다.</p>
</td></tr></table>
<p>단순하게 보시는것과 같이, 초보자들에게는 엄청 어지러울수 있습니다. 따라서 우선 용어부터 정리해보죠.</p>
<p>apps폴더를 열어보면, _myApps_폴더를 볼 수 있습니다. 이 폴더를 *작업공간*이라고 부릅시다.</p>
<p>이제 <em>myApps</em> 작업공간을 열어보면, <em>emptyExample</em> 폴더가 보입니다. 이것을 *프로젝트*라고 부르겠습니다. 각 프로젝트에는 다른 파일들과 함께 (사용하고 있는 IDE에 따라)".xcodeproj" 또는 ".workspace"파일과, "src"폴더가 있습니다. *프로젝트*는 <em>반드시</em> *작업공간*내에 위치해야 하며, 하나의 어플리케이션으로 컴파일 될 수 있습니다.</p>
<p><img src="images/workspace04.png" style="border-width: 0;" alt="Workspace terminology"></p>
<p>자 우리는 <strong>프로젝트*를 만들려고 합니다만, 모든 프로젝트는 *작업공간</strong> 내에서 살아갑니다. 따라서 편리하가게 <strong>myApps</strong> 작업공간을 사용해봅시다. 물론 원한다면 여러분이 원하는 작업공간을 사용할 수 있습니다. 하지만 중요한것은 "apps"내에 바로 위치해야 한다는 점입니다. 예를들어 : 하나의 작업공간 내에 다른 작업공간을 가질 수 없습니다.</p>
<table frame="void" cellpadding="8">
<tr valign="top"><td><p><b><u>Note</u></b></p></td>
<td style="border-left: 1px solid silver;">
<p><b>deprecated instructions on the old project creation way</b></p>
<p>First we will <span class="underline">duplicate</span> (NOT rename) the entire "emptyExample"
folder. On a Mac, you can literally right-click on the emptyExample folder,
and click <em>Duplicate</em>. So the result should look like this:</p>
<p><img src="images/workspace02.png" style="border-width: 0;" alt="emptyExample Copy"></p>
<p>Next, we can rename the duplicate project folder from "emptyExample Copy" to "myFirstProject".</p>
<p><img src="images/workspace03.png" style="border-width: 0;" alt="My First Project"></p>
</td></tr></table>
<p>The super important thing here is that your XCode or Code::Blocks project file is <strong>exactly</strong> 3 folders "below" the root folder (refer to colorful diagram above). So, whenever you make a new project, or if you are suddenly getting thousands of errors for no apparent reason, you should always double check that your XCode or Code::Blocks project file is in the correct place.
여기서 매우 중요한 사실은 여러분 Xcode나 Code::Blocks 프로젝트 파일은 root폴더로부터 <strong>정확히</strong> 3단계를 유지하고 있다는 점입니다 (위의 컬러 다이어그램을 참고하세요).</p>
<p>이러한 이유는 'lib'폴더와 관계가 있습니다. 앞에서 언급했지만 오픈프레임웍스는 다양한 다른 라이브러리들을 묶는 "접착제" 역할을 합니다. 이러한 라이브러리들은 'lib'디렉토리에 위치해 있습니다.  또한 우리는 이러한 라이브러리가 어디에 있는지를 찾아서, 그것들을 함께 묶는작업이 IDE의 주 역할이라는것도 알았죠. 따라서 IDE가 여러분의 프로그램을 컴파일하려고 할때, IDE는 라이브러리를 찾기 위해 "../../../lib"를 살펴봅니다. 다르게 말하면: ".xcodeproj파일로부터 <a href="http://support.dtsearch.com/webhelp/dtsearch/relative_paths.htm">상대적인</a> 경로로 3번 상위로 올라가서 lib폴더를 살펴보라" 라는 의미입니다.  에를들어 아무 오픈프레임웍스 프로젝트의 세팅부분을 살펴보면, "../../../libs/Freeimage/include" 와 "../../../libs/poco/include" 경로를 찾을 수 있을것입니다. 따라서, 여러분의 .xcodeproj 파일이 of_v0.9.0_osx_release/apps/[작업공간]/[프로젝트] 에만 위치하고 있다면, 문제없이 컴파일할 수 있습니다. 그렇지 않다면, 문제가 발생합니다.</p>
<p>좋습니다! 이제 여러분의 최조의 오픈프레임웍스 프로젝트를 생성했네요. 여러분의 새 Xcode 프로젝트 파일을 더블클릭하고 "emptyExample"이 다겟으로 선택되었는지 확인한다음 "Run"을 클릭하면(또는 Code::Blocks에서 F9를 눌러보면), 아래와 같은 화면이 보일것입니다:</p>
<p><img src="images/PlainGray.png" style="border-width: 0;" alt="Plain Gray Window" width="600"></p>
<p>아무것도 없네요! 하지만 이것이 정확히 여러분이 보게 될 화면입니다. 뭐, 아직 아주 흥미롭진 않네요, 그래도 잘하고 있는겁니다.</p>
<p>ESC나 App+Q를 눌러 프로그램을 종료하세요</p>
<table frame="void" cellpadding="8">
<tr valign="top"><td><p><b><u>Warning</u></b></p></td>
<td style="border-left: 1px solid silver;">
<p><b>Renaming your Project in XCode</b></p>
<p>파일명을 "emptyExample.xcodeproj"를 "myFirstProject.xcodeproj"로 변경하려고 시도할수도 있습니다. 만약 Xcode 4 이전의 버젼이라면 가능하지만, Xcode 4에서는 문제가 발생합니다. 따라서 대신에, 프로젝트를 XCode에서 열고, 아래에 보이는 것처럼 좌층 상단의 "emptyExample" 제목을 누르십시오:</p>
<p><img src="images/rename01.png" style="border-width: 0;" alt="Renaming your Project" width="400"></p>
<p>이름을 변경하면, 다이얼로그 박스로 많은것들 역시 이름을 변경할것이냐고 물어볼것입니다. "Rename"을 누르세요.</p>
<p><img src="images/rename02.png" style="border-width: 0;" alt="Renaming your Project" width="700"></p>
<p>쨔잔!</p>
</td></tr></table>
<p>XCode의 "Run"버튼을 클릭할 때, 실제로 뒤에서 벌어지는 일을 설명하자면, 여러분의 코드는 실행가능한 파일로 컴파일되어 "bin"디렉토리에 위치하게 됩니다. 그리고 나서 실행파일을 더블클릭하여 실행한것처럼 해당 어플리케이션이 실행됩니다.자, "myApps/MyFirstApplication/bin"폴더를 살펴보면, 어플리케이션 아이콘이 보일것입니다. 이것이 여러분의 어플리케이션입니다! 더블클릭해보면, 똑같은 회색 윈도우가 보일 것입니다. 이제 이 어플리케이션을 (맥을 사용하는) 다른 친구에게 보낼 수 있습니다. 그리고 이 멋진 회색 윈도우 프로그램을 실행 할수도 있죠!</p>
<p><img src="images/workspace05.png" style="border-width: 0;" alt="Your Executable" width="760"></p>
<hr>
<h2><a name="_writing_code"></a>4. Writing Code</h2>
<p>좋습니다, 이제 프로젝트를 어떻게 생성하는지 알았으니, 프로젝트에서 코드를 작성할 시간입니다. 앞으로의 몇 섹션에서는 오픈프레임웍스 어플리케이션의 구조와 간단한 draw, setup 팜수를 소개할 것입니다.</p>
<h3><a name="_testapp_cpp"></a>4.1. testApp.cpp</h3>
<p>자 마침내 코드를 살펴보기 시작할 시간입니다. 우선 해야할 일은 Xcode에서 프로젝트를 여는것입니다. 여러분이 앞 섹션에의 "myApps" 작업공간에 있는 "myFirstProject"로 작업한다고 가정하고 진행하겠습니다. 열어서, <strong>네비게이터 뷰</strong>(XCode의 좌측 끝 패널)의 작은 삼각형을 클릭해보세요. 아래와 같이요:</p>
<p><img src="images/expand01.gif" style="border-width: 0;" alt="Open up the project"></p>
<ol type="1">
<li>
<p>
Click the disclosure triangle next to "MyFirstProject"
</p>
</li>
<li>
<p>
Click the disclosure triangle next to "src"
</p>
</li>
<li>
<p>
Click on testApp.cpp
</p>
</li>
</ol>
<p>testApp.cpp는 앞으로 볼 몇 튜토리얼에서 여러분이 친해져야할 녀석입니다. *편집기 윈도우*에는, 이렇게 시작하는 뭔가가 보일겁니다:</p>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="10"><tr><td>
<pre><code class="cpp">#include "testApp.h"

//--------------------------------------------------------------
void testApp::setup(){

}

//--------------------------------------------------------------
void testApp::update(){

}

//--------------------------------------------------------------
void testApp::draw(){

}

//--------------------------------------------------------------
void testApp::keyPressed(int key){

}</code></pre>
</td></tr></table>
<p>자, 뭐가 어떻게 되고 있는거죠?</p>
<p>다양한 측면에서, testApp.cpp는 소개란에서 작성했던 hello.cpp와 같습니다. 이 파일은 `C++`소스코드를 담는 평문 텍스트 파일입니다. 다른점이 있다면 우리는 이것을 IDE를 통해 편집하고 있으므로, 보시다시피 아주 훌륭하게 문법 강조(syntax highlighting)가 적용되어 있어 코드를 쉽게 이해할 수 있습니다. 또한 역시 컴파일 및 실행을 쉽게 할 수 있죠.</p>
<p>아주 기초적인 레벨에서, 여러분이 보고 계시는것은 많은 빈 함수들입니다. <a href="https://en.wikipedia.org/wiki/Function_(computer_science)">함수</a>는 보다 큰 프로그램을 만들어가는 명령의 집합입니다. 위의 작은 코드조각들을 보면, 4개의 함수가 있습니다: setup, update, darw 그리고 keyPressed입니다. 각 함수는 중괄호(curly brackets {})로 감싸져 있습니다. 중괄호 내에 주로 작성되는 내용들은 명령들(변수에 값을 할당하거나, 반복(loop)들, 그리고 다른 함수의 호출 등등)이며, 이것들이 함수를 완성합니다.</p>
<p>If you refer back to the Q&amp;A "What is a software framework?" in the introduction, the film production company analogy is particularly useful at this point. What you are looking at in testApp.cpp is how openFrameworks has provided all of the infrastructure and logistical details. Now it&#8217;s your job to define what happens. You do this by putting code into the functions in testApp.cpp</p>
<p>이러한 함수들은 프로그램이 실행되는동안 다른 지점에서 오픈프레임웍스에 의해 호출됩니다. 이중 몇개를 좀더 살펴봅시다.</p>
<dl>
<dt>
setup
</dt>
<dd>
<p>
        이 함수는 프로그램 윈도우가 열리기 전에 가장 처음에 호출(중괄호 내에 작성된 모든 코드들이) 됩니다. 예를 들어 윈도우의 크기를 지정하고 싶다고 해봅시다. 아마도 여러분은 윈도우가 실제로 열리기전에 이러한 작업이 수행되길 원하기 때문에, setup이 바로 적절한 곳입니다.
</p>
</dd>
<dt>
update, draw
</dt>
<dd>
<p>
        setup함수가 실행된 이후, update와 draw함수가 시작되어 프로그램이 종료될때까지 반복됩니다. 즉 setup()이 동작한 이후, update()가 돌고, draw()가 돌고, update()가 돌고, draw()가 돌고.. 이런식입니다. 그리고 기본적으로, 이러한 과정들은 여러분의 컴퓨터가 다룰 수
    After the setup function runs, the update and draw functions begin a loop that continues until your program ends. So, after setup() runs, update() runs, then draw(), then update(), then draw(), etc. and by default, this happens as fast as your computer can handle. update() is typically used for updating the state of your program (i.e.: changing the value of variables), while draw() is used to actually draw things into your window.
</p>
</dd>
<dt>
keyPressed, keyReleased, mouseMoved, mouseDragged, mousePressed, mouseReleased, windowResized, gotMessage, dragEvent
</dt>
<dd>
<p>
    Unlike the previous three functions, these functions are called only when a user does something. Can you guess what?
</p>
</dd>
</dl>
<p>But enough with the reading. Let&#8217;s see these things in action.</p>
<h3><a name="_making_a_mark"></a>4.2. Making a Mark</h3>
<p>We will start by drawing a simple circle in our gray window using the ofCircle function. Type <tt>ofCircle(200, 200, 60);</tt> on the blank line inside the draw() function so that your draw function look like this:</p>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="10"><tr><td>
<pre><code class="cpp">void testApp::draw(){
    ofCircle(200, 300, 60);
}</code></pre>
</td></tr></table>
<table frame="void" cellpadding="8">
<tr valign="top"><td><p><b><u>Note</u></b></p></td>
<td style="border-left: 1px solid silver;">
<p>Notice the semicolon at the end of the line. All function calls must end with a semicolon. In addition, function names are always case sensitive, so OfSetColor will not work, nor OFsetcolor, etc. only ofSetColor.</p>
</td></tr></table>
<p>Now run your program. You should see something like:</p>
<p><img src="images/MyFirstProject01.png" style="border-width: 0;" alt="A Plain White Circle" width="500"></p>
<p>Congratulations!  You just made something appear on the screen! It&#8217;s all downhill from here.</p>
<p>But what did we just do?</p>
<p><a href="/documentation/graphics/ofGraphics.html#show_ofCircle">ofCircle</a> is a function that comes with openFrameworks (hence the <em>of</em> prefix). You can invoke the ofCircle function inside your draw function as many times as you&#8217;d like. The numbers inside of the parenthesis after <em>ofCircle</em> are called <a href="https://en.wikipedia.org/wiki/Parameter_(computer_programming)">arguments</a>. They determine exactly what the function does. They answer the questions: "okay, you want to draw a circle, but where? and how big?" Functions can take any number of arguments, always separated by commas, but ofCircle takes 3: an x coordinate, a y coordinate, and a radius. There are a few things you need to know to make sense of these arguments:</p>
<ol type="1">
<li>
<p>
All measurements in openFrameworks are in pixels. By saying that our circle has a radius of 60, that means that it will take up PI*60<sup>2</sup> pixels total.
</p>
</li>
<li>
<p>
This may seem obvious, but the coordinates refer to the center of the circle. Other shapes (such as rectangles) use the upper left corner.
</p>
</li>
<li>
<p>
The "origin" of the coordinate system is in the upper left of the window. So, our circle appears 200 pixels from the left side of the screen, and 300 pixels from the top.
</p>
</li>
</ol>
<table frame="void" cellpadding="8">
<tr valign="top"><td><p><b><u>Note</u></b></p></td>
<td style="border-left: 1px solid silver;">
<p>The order of the arguments is important. The first argument to ofCircle will always mean "x coordinate" and the third will always mean "radius".</p>
</td></tr></table>
<table frame="void" cellpadding="8">
<tr valign="top"><td><p><b><u>Note</u></b></p></td>
<td style="border-left: 1px solid silver;">
<p>There are some functions (such as <a href="/documentation/graphics/ofGraphics.html#show_ofFill">ofFill</a>, which simply tells oF to fill shapes that are drawn) that have 0 arguments, but you still have to put parenthesis after them.</p>
</td></tr></table>
<p>If you hadn&#8217;t just read about it here, you could have found information about ofCircle on the <a href="/documentation/">openFrameworks documentation page</a>, which you will be using more as we move on.</p>
<h3><a name="_adding_some_color"></a>4.3. Adding some Color</h3>
<p>Your circle is great, but kind of boring. What if we want to introduce some color to our application? To do that, we need the the <a href="/documentation/graphics/ofGraphics.html#show_ofSetColor">ofSetColor</a> function. Try adding <tt>ofSetColor(255, 0, 255);</tt> right above the ofCircle line, so that your draw function looks like this:</p>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="10"><tr><td>
<pre><code class="cpp">void testApp::draw(){
    ofSetColor(255, 0, 255);
    ofCircle(200, 300, 60);
}</code></pre>
</td></tr></table>
<p>Now try running your application.</p>
<p><img src="images/MyFirstProject02.png" style="border-width: 0;" alt="A purple circle" width="500"></p>
<p>Similar to ofCircle, the ofSetColor function takes 3 arguments, but the numbers have very different meanings. If you look at the documentation for <a href="/documentation/graphics/ofGraphics.html#show_ofSetColor">ofSetColor</a>, you&#8217;ll notice that they arguments actually represent the red, green, and blue values for the color that you want to use, on a scale of 0-255. The red, green and blue make up the <a href="https://en.wikipedia.org/w/index.php?title=RGB_color_model">RGB color model or color space</a>. So when we typed <tt>ofSetColor(255, 0, 255);</tt>, we were saying "until further notice, draw everything with 100% red, 0 green, and 100% blue."</p>
<table frame="void" cellpadding="8">
<tr valign="top"><td><p><b><u>Tip</u></b></p></td>
<td style="border-left: 1px solid silver;">
<p>Try changing the values to get different color variations.</p>
</td></tr></table>
<p>This last point is important: when we call "ofSetColor", it&#8217;s like picking a crayon out of a box. Everything that gets drawn after that (below that line of code) will be drawn in that color until we call ofSetColor again. So if we want to draw another circle on the screen, we could simply call the ofCircle function again:</p>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="10"><tr><td>
<pre><code class="cpp">void testApp::draw(){
    ofSetColor(255, 0, 255);
    ofCircle(200, 300, 60);

    ofCircle(500, 500, 100);
}</code></pre>
</td></tr></table>
<p>But if we wanted that circle to be a different color, we would have to call ofSetColor again:</p>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="10"><tr><td>
<pre><code class="cpp">void testApp::draw(){
    ofSetColor(255, 0, 255);
    ofCircle(200, 300, 60);

    ofSetColor(0, 255, 255);
    ofCircle(500, 500, 100);
}</code></pre>
</td></tr></table>
<p><img src="images/MyFirstProject03.png" style="border-width: 0;" alt="Two Colorful Circles" width="500"></p>
<h3><a name="_all_the_shapes_you_can_handle"></a>4.4. All The Shapes You Can Handle</h3>
<p>Of course, oF can draw more than circles.</p>
<ol type="1">
<li>
<p>
<a href="/documentation/graphics/ofGraphics.html#show_ofRect">ofRect</a> draws a rectangle. arguments are (x, y, width, height)
</p>
</li>
<li>
<p>
<a href="/documentation/graphics/ofGraphics.html#show_ofTriangle">ofTriangle</a> draws a triangle. arguments are the coordinates of the three points: (x1, y1, x2, y2, x3, y3)
</p>
</li>
<li>
<p>
<a href="/documentation/graphics/ofGraphics.html#show_ofLine">ofLine</a> draws a line. arguments are the start coordinate and the end coordinate (x1, y1, x2, y2)
</p>
</li>
<li>
<p>
<a href="/documentation/graphics/ofGraphics.html#show_ofEllipse">ofEllipse</a> arguments are: (x, y, width, height)
</p>
</li>
<li>
<p>
<a href="/documentation/graphics/ofGraphics.html#show_ofCurve">ofCurve</a> Draws a curve from point (x1, y1) to point (x2, y2). The curve is shaped by the two control points (x0,y0) and (x3,y3).
</p>
</li>
</ol>
<table frame="void" cellpadding="8">
<tr valign="top"><td><p><b><u>Note</u></b></p></td>
<td style="border-left: 1px solid silver;">
<p>Control points can be tricky. If you&#8217;ve used the pen tool in photoshop or illustrator, you probably understand them. If not, check out <a href="http://www.actionscript.org/resources/articles/172/1/Understanding-curves-and-control-point-placement/Page1.html">this tutorial</a>. It&#8217;s about ActionScript, but it gives a great overview of the concept of curves and control points.</p>
</td></tr></table>
<table frame="void" cellpadding="8">
<tr valign="top"><td><p><b><u>Tip</u></b></p></td>
<td style="border-left: 1px solid silver;">
<p>Try making 3 different projects in your "MyFirstWorkspace" workspace. In each one, draw a different shape in a different location using a different color.</p>
</td></tr></table>
<h3><a name="_adding_movement"></a>4.5. Adding Movement</h3>
<p>Drawing static shapes is great, but what if we want our shapes to move around the screen?</p>
<p>We mentioned earlier that the draw() function is called repeatedly after the program is started. This is very important because it is how we achieve animation in openFrameworks. It might be a little unintuitive if you are used to Flash or even something like stop-frame animation, where you can add something to a "stage" and then re-position it as needed. This is <strong>not</strong> how openFrameworks (or most computer animation) works. Actually, openFrameworks is more like traditional (we&#8217;re talking old-school Disney/Bambi) animation, where we must redraw the frame completely every single "frame". In the parlance of openFrameworks, every time the draw() function is called is one "frame". So, in actuality, when you run the program above and see your purple circle, what you are actually looking at is the circle being drawn, then cleared (a single frame), and then drawn, then cleared, repeatedly. It&#8217;s just happening so fast that it appears to stay where it is.</p>
<p>In the example above, when we draw our circle, we use two numbers to tell the ofCircle function where to draw the circle within the window. So it follows that, if we want the circle to appear to move, we need to change these numbers over time. Perhaps the first time draw() happens, the circle is drawn at (200, 300), but in the next time, we want it to be one pixel to the right (201, 300), and then another pixel to the right (202, 300), and so on.</p>
<p>In <tt>C++</tt>, and in programming in general, whenever you have a value that you want to change, you create a "variable". Variables come in different shapes and sizes depending on what they represent, such as decimal numbers, whole numbers, a letter, or a bunch of letters. In this case, we want to create variables that can stand in for coordinates in our ofCircle function, so we will use 2 <strong>int</strong>s.</p>
<p>Put this at the top of your testApp.cpp, right under the <tt>#include</tt> line, so that your file starts like this:</p>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="10"><tr><td>
<pre><code class="cpp">#include "testApp.h"

int myCircleX;
int myCircleY;</code></pre>
</td></tr></table>
<p>In those 2 new lines of code, we "declared" 2 new variables: one called <em>myCircleX</em> and one called <em>myCircleY</em>. You could actually name them whatever you want (within reason), but it&#8217;s a good idea to name them something that is related to how they will be used. We also said that these variables will be used to hold whole-number integer values, or <strong>int</strong>s. Declaring a variable is an important and necessary step. It&#8217;s like telling your application "okay, I&#8217;m going to need to store a number that might change."</p>
<p>The next thing we need to do is give those variables a starting value. We know that the endgame here is to have these variables change over time. But before we can change them, we need to give them an initial value. In other words, before our circle starts moving, where will it appear?</p>
<p>In a previous section, we learned that the setup() function gets called once when the application launches, and then never called again. This sounds like it could be useful for giving our variables some initial values. So in your setup() function, add the following lines.</p>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="10"><tr><td>
<pre><code class="cpp">void testApp::setup(){
    myCircleX = 300;
    myCircleY = 200;
}</code></pre>
</td></tr></table>
<p>Perfect!  So, to recap, we now have 2 variables, <em>myCircleX</em>, and <em>myCircleY</em>, and we have just "initialized" them, or populated with an "initial" value. Notice that, just like any mathematical equation, we use the equals sign (=) to assign the number 300 to <em>myCircleX</em>. In <tt>C++</tt> parlance, the equals sign is known as the "assignment operator", because it&#8217;s used to assign a value to a variable. The "assignment" always flows from right to left; that is, the value that is being assigned is on the right and thing that is receiving the assignment is on the left.</p>
<p>Now we can edit our ofCircle call a bit :</p>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="10"><tr><td>
<pre><code class="cpp">void testApp::draw(){
    ofSetColor(255, 0, 255);
    ofCircle(myCircleX, myCircleY, 60);
}</code></pre>
</td></tr></table>
<p>Notice that we are still passing 3 arguments to the ofCircle function. But now, instead of the old "hard-coded" (200, 300) values that we can&#8217;t change, we are letting the variables that we made stand in.</p>
<p>If you run your app now, you shouldn&#8217;t notice any change. That&#8217;s because we haven&#8217;t gotten around to changing the variables yet. So let&#8217;s do it.</p>
<p>Let&#8217;s edit our draw function a little so that it looks like this:</p>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="10"><tr><td>
<pre><code class="cpp">void testApp::draw(){
    myCircleX = myCircleX + 1;

    ofSetColor(255, 0, 255);
    ofCircle(myCircleX, myCircleY, 60);
}</code></pre>
</td></tr></table>
<p>In this new line, we are using the "assignment operator" again, just like in the setup function. In English, that line would say "take the value of myCircleX plus one, and assign that to myCircleX". In other words, we are incrementing myCircleX by 1. <tt>C++</tt> provides a shortcut for the common task of incrementing a variable: <tt>myCircleX++;</tt>  This is extremely common, so let&#8217;s actually change our code to use this handy shortcut:</p>
<pre><code class="cpp">myCircleX = myCircleX + 1;</code></pre>
<p>becomes</p>
<pre><code class="cpp">myCircleX++;</code></pre>
<p>If you run your program now, you should see your circle move off the screen to the right!  Animation!</p>
<p>There is just one thing we need to fix before moving on to more pressing aesthetic concerns. If you read back through the descriptions of what the update() and draw() functions are supposed to be used for, you&#8217;ll notice that the draw function is for drawing (so far, so good), but the update() function is where we are supposed to take care of updating variables. There are some very good reasons for this that we will get into later, but for now, let&#8217;s move the line we just wrote to the update function. So, your update and draw functions should look like this:</p>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="10"><tr><td>
<pre><code class="cpp">void testApp::update(){
    myCircleX++;
}

void testApp::draw(){
    ofSetColor(255, 0, 255);
    ofCircle(myCircleX, myCircleY, 60);
}</code></pre>
</td></tr></table>
<p>You shouldn&#8217;t notice any difference in terms of functionality, but it&#8217;s a good habit to get into.</p>
<h3><a name="_framerate"></a>4.6. Framerate</h3>
<p>One thing you may notice about your awesome moving circle is that it starts off kind of slow and then speeds away. This is actually caused by the framerate of your application, which is slow at first while the application fires up, but then gets super fast. As mentioned before, framerate refers to the rate at which the draw/update loop executes. Add this little line of code to the bottom of your draw() function to be able to see your framerate in the upper left corner of your window:</p>
<pre><code class="cpp">ofDrawBitmapString(ofToString(ofGetFrameRate())+"fps", 10, 15);</code></pre>
<p>Most likely, it says something very close to 1000fps. That means that your circle is being drawn close to one thousand times per second. If you were to fire up tons of other applications on your computer and start rendering a huge video, you&#8217;d notice this framerate drops. The fact is that your application is simply trying to run as fast as it possibly can.</p>
<p>In the interest of having a smoother, more predictable kind of animation, we will lower the framerate to something more reasonable, like 60. In order to do this, we will put a new line into our setup() function.</p>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="10"><tr><td>
<pre><code class="cpp">void testApp::setup(){
    ofSetFrameRate(60);

    myCircleX = 300;
    myCircleY = 200;
}</code></pre>
</td></tr></table>
<p>Add that and then run your program. You will notice that the circle moves considerably slower. Using this function is <strong>not</strong> a guarantee of 60 frames per second, but it is a guarantee that your framerate won&#8217;t be any higher than that. And unless you have a really old computer, or your processor is already extremely taxed by some other program, it should have no problem running consistently at 60fps while doing something a simple as drawing a moving circle.</p>
<table frame="void" cellpadding="8">
<tr valign="top"><td><p><b><u>Tip</u></b></p></td>
<td style="border-left: 1px solid silver;">
<p>SAT word problem #1: If we know that the update loop is happening (at most) 60 times/second, and we are incrementing the x coordinate of the circle by 1 pixel every time update is called, how long will it take for the circle to move 240px?</p>
</td></tr></table>
<table frame="void" cellpadding="8">
<tr valign="top"><td><p><b><u>Tip</u></b></p></td>
<td style="border-left: 1px solid silver;">
<p><b>Too bloody slow</b></p>
<p>It&#8217;s true that we now have a good handle on the framerate, but 60px/second turns out to be really slow. To fix this problem, we <strong>could</strong> increase the framerate, but 60fps is a pretty good framerate. so instead, let&#8217;s change the speed of the circle itself:  instead of just incrementing the x coordinate by 1 pixel every time, let&#8217;s increment it by 4. Using the same "incrementing" shortcut, we can change our update() function like this:</p>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="10"><tr><td>
<pre><code class="cpp">void testApp::update(){
    myCircleX+=4;
}</code></pre>
</td></tr></table>
</td></tr></table>
<h3><a name="_the_pacman_effect"></a>4.7. The Pacman Effect</h3>
<p>Let&#8217;s have one final adventure with our purple circle before saying goodbye. Our application is still a little disappointing because once our circle leaves the screen on the right, it&#8217;s gone forever. Let&#8217;s fix that problem by making the circle re-appear on the left side after leaving on the right: the Pacman Effect.</p>
<p>Before we write any code, let&#8217;s think about what this is going to mean in terms of the variables that we have. In the current state, we have myCircleX acting as the x coordinate for our circle, and it is being incrementing by 1 (or 4, if you followed the tip above) every frame. By default, an openFrameworks window is 1024x768. So, one way we could achieve the Pacman Effect is to reset myCircleX back to 300 once it goes beyond 1024.</p>
<p>How can we do this? We know that we are supposed to do any variable updating in the update() function, so let&#8217;s start there. We also know that we <strong>only</strong> want to reset myCircleX <strong>if</strong> it has gone above 1024. So for that, we use the <em>if</em> statement.</p>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="10"><tr><td>
<pre><code class="cpp">void testApp::update(){
    myCircleX++;
    if(myCircleX &gt; 1024)
    {
        myCircleX = 300;
    }
}</code></pre>
</td></tr></table>
<p>This code says:</p>
<ul>
<li>
<p>
increment myCircleX by one.
</p>
</li>
<li>
<p>
test if myCircleX is greater than 1024
</p>
</li>
<li>
<p>
<strong>only</strong> if that test turns out to be true, set myCircleX back to 300;
</p>
</li>
</ul>
<hr>
<h2><a name="_adding_interaction"></a>5. Adding Interaction</h2>
<p>Now that you are a master of animation, it&#8217;s time to get the user involved. For this section, we will be focusing on keyboard and mouse interaction.</p>
<p>So far, we&#8217;ve been focusing on 3 functions: setup(), update(), and draw(). For interaction, we will start with 2 of the other functions in your testApp.cpp file:</p>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="10"><tr><td>
<pre><code class="cpp">void testApp::keyPressed(int key){

}

void testApp::keyReleased(int key){

}</code></pre>
</td></tr></table>
<p>Going back to the producer metaphor can help us understand how these functions work. openFrameworks has done the hard work of setting up your app to know when the user has done some keyboard business. Now, all you have to do is put code into these functions that you want to execute when a particular event occurs:</p>
<ul>
<li>
<p>
user physically presses down on a key
</p>
</li>
<li>
<p>
user physically releases the key
</p>
</li>
</ul>
<p>This might be a little unintuitive if you are accustomed to thinking about typing a letter as a single action: "I just typed the letter <em>o</em>". But in fact, they are 2 distinct actions, or "events", and eventually you might find it handy to be able to distinguish between them.</p>
<p>Create a new project in "myApps" called "keyboardInteraction". If you need to, go back to "Creating your First Project" to see how.</p>
<p><img src="images/KeyboardInteraction01.png" style="border-width: 0;" alt="Keyboard Interaction Project" width="750"></p>
<h3><a name="_introducing_cout"></a>5.1. Introducing, cout!</h3>
<p>The easiest way to quickly see how these functions work is to print a message to the console. Remember when we printed "Hello, World!" to the console in the introduction? We did that using a <tt>C++</tt> thing called <a href="http://www.cplusplus.com/reference/iostream/cout/">"cout"</a> (pronounced <em>c out</em>). The syntax for using it is a bit weird because it&#8217;s not technically a function (it&#8217;s actually an object, which we will talk more about in later chapters), but if you can get beyond the syntax, it&#8217;s actually very useful for debugging.</p>
<p>But first: you may be asking yourself: how will we see text output? We are dealing with a GUI interface now. Luckily, XCode/Code::Blocks provides a window where we can see anything text that your program outputs (also known as <a href="http://www.cplusplus.com/reference/clibrary/cstdio/stdout/">stdout</a>).</p>
<p>So start by going to View&#8594;Debug Area&#8594;Activate Console, or press apple+shift+C when using XCode. Code::Blocks automatically opens a console window when you press F9 (to build and run your program).</p>
<p><img src="images/activate-console.png" style="border-width: 0;" alt="Activate Console"></p>
<table frame="void" cellpadding="8">
<tr valign="top"><td><p><b><u>Note</u></b></p></td>
<td style="border-left: 1px solid silver;">
<p>For XCode 3 users, use the key command Shift-Cmd-R. There&#8217;s also a preference in XCode to bring up the console after each launch - Xcode&#8594;Preferences&#8594;Debugging&#8594;On Start Show Console.</p>
</td></tr></table>
<p>You should see a panel like this appear at the bottom of your XCode window</p>
<p><img src="images/debug-area.png" style="border-width: 0;" alt="Debug Area"></p>
<p>Excellent! Your output will appear in the pane on the right. Now we will add some code to our key functions that will print stuff to the console:</p>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="10"><tr><td>
<pre><code class="cpp">void testApp::keyPressed(int key){
    cout &lt;&lt; "keyPressed " &lt;&lt; key &lt;&lt; endl;
}

void testApp::keyReleased(int key){
    cout &lt;&lt; "keyReleased " &lt;&lt; key &lt;&lt; endl;
}</code></pre>
</td></tr></table>
<p>As I mentioned before, the syntax for cout is a little strange and, frankly, way beyond the scope of this chapter. In <tt>C++</tt> parlance, cout represents the "standard output stream", and without worrying too much about what that means, "stream" is a nice way to think about it. If you look at the line of code within <em>keyPressed</em>, it appears that there is a "stream" of data flowing into the "cout". First we send in the string "keyPressed " down the stream, then we send in a variable: key. Finally, we send <a href="http://www.cplusplus.com/reference/iostream/manipulators/endl/">endl</a> down the stream. endl simply tells the console to go to the next line.</p>
<p>The <em>key</em> variable represents the key that was pressed or released. More about this in a bit.</p>
<p>Let&#8217;s give it a try. Launch your program and type some keys. I will type "qwerty". You should see something like this in the console:</p>
<pre><code class="cpp">GNU gdb 6.3.50-20050815 (Apple version gdb-1708) (Thu Nov  3 21:59:02 UTC 2011)
Copyright 2004 Free Software Foundation, Inc.
GDB is free software, covered by the GNU General Public License, and you are
welcome to change it and/or distribute copies of it under certain conditions.
Type "show copying" to see the conditions.
There is absolutely no warranty for GDB. Type "show warranty" for details.
This GDB was configured as "x86_64-apple-darwin".tty /dev/ttys002
[Switching to process 92317 thread 0x0]
keyPressed 113
keyReleased 113
keyPressed 119
keyReleased 119
keyPressed 101
keyReleased 101
keyPressed 114
keyReleased 114
keyPressed 116
keyReleased 116
keyPressed 121
keyReleased 121</code></pre>
<p>Don&#8217;t worry about the crap at the beginning&#8201;&#8212;&#8201;that&#8217;s added by the debugger.</p>
<p>The fact that the <em>key</em> is supplied as an <em>int</em> may seem a bit strange. Perhaps you were expecting a string or a char? In fact, what this number represents is the <a href="http://www.asciitable.com/">ASCII code</a> for the key pressed. Check out this table:</p>
<p><img src="images/ascii_table.jpg" style="border-width: 0;" alt="ASCII Table"></p>
<p>On the right of each column in red, you will see a key on your keyboard. Under the corresponding "Dec" (decimal=base 10) column, you will see the number that you will receive in the key functions.</p>
<table frame="void" cellpadding="8">
<tr valign="top"><td><p><b><u>Tip</u></b></p></td>
<td style="border-left: 1px solid silver;">
<p>You can actually use something called <a href="http://www.cplusplus.com/doc/tutorial/typecasting/">type casting</a> to turn the int into a <em>char</em>, or letter. Simply put "(char)" before the "key" variable so that your cout statement looks like this:</p>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="10"><tr><td>
<pre><code class="cpp">cout &lt;&lt; "keyPressed " &lt;&lt; (char)key &lt;&lt; endl;</code></pre>
</td></tr></table>
<p>More about type casting later in this chapter!</p>
</td></tr></table>
<p>Fantastic. But presumably we want to do more with the key presses than print to the console. Let&#8217;s use the keys to move a ball around on the screen.</p>
<p>Start by adding two variables to your testApp and using them to draw a circle, just like we did in the Adding Movement section:</p>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="10"><tr><td>
<pre><code class="cpp">#include "testApp.h"

int myCircleX;
int myCircleY;

void testApp::setup(){
    myCircleX = 300;
    myCircleY = 200;
}

void testApp::update(){

}

void testApp::draw(){
    ofSetColor(255, 0, 255);
    ofCircle(myCircleX, myCircleY, 60);
}</code></pre>
</td></tr></table>
<p>In the Adding Movement section, we used variables so that we could have the circle move by itself. The difference this time is that we want the ball to move in response to our keyboard input. This means that we need to modify the values of the variables depending on which keys are pressed rather than incrementing it automatically every frame. So it follows that we need to change the value of myCircleX and myCircleY in keyPressed() (or keyReleased()&#8201;&#8212;&#8201;it&#8217;s up to you!) instead of update().</p>
<p>Let&#8217;s use a typical computer game keyboard scheme: say we want the ball to move up when we press <em>w</em>, to the left when we press <em>a</em>, down when we press <em>s</em>, and right when we press <em>d</em>. We could start by looking up the ASCII values and finding that the values are 119, 97, 115, and 100, respectively. Next, we think about what "up", "down", "left" and "right" mean in terms of our variables: myCircleX and myCircleY. What we end up with is:</p>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="10"><tr><td>
<pre><code class="cpp">void testApp::keyPressed(int key){
    if(key==119) // 'w' key
    {
        myCircleY--;
    }
    if(key==97) // 'a' key
    {
        myCircleX--;
    }
}</code></pre>
</td></tr></table>
<p>As we discovered, any time any key is pressed, the keyPressed() function is called. However, we want to be more selective than that. We want to be able to make certain things happen when the <em>w</em> key is pressed, and other things happen when the <em>a</em> key is pressed, etc. So, we need to add some <a href="http://www.cprogramming.com/tutorial/lesson2.html">if statements</a>. When the keyPressed function is called, the first thing that happens is we test if <em>key</em> is equal to 119.</p>
<p>Notice the double equals sign. This signifies that we are performing a comparison rather than an assignment. In other words, we don&#8217;t want to assign the value 119 to the variable <em>key</em>, we want to test whether key is equal to 119. If this turns out to be true, then the code inside the curly brackets immediately following the if() is executed.</p>
<p>Your challenge is to complete the function to respond to the <em>s</em> and <em>d</em> keys.</p>
<table frame="void" cellpadding="8">
<tr valign="top"><td><p><b><u>Tip</u></b></p></td>
<td style="border-left: 1px solid silver;">
<p>This also works!</p>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="10"><tr><td>
<pre><code class="cpp">if(key=='w')
{
    myCircleY--;
}
if(key=='a')
{
    myCircleX--;
}</code></pre>
</td></tr></table>
</td></tr></table>
<hr>
<h2><a name="_mighty_mouse"></a>6. Mighty Mouse</h2>
<p>Keyboard interaction is great, but what about the mouse? You might have noticed the following functions hanging out in testApp also:</p>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="10"><tr><td>
<pre><code class="cpp">void testApp::mouseMoved(int x, int y ){

}

void testApp::mouseDragged(int x, int y, int button){

}

void testApp::mousePressed(int x, int y, int button){

}

void testApp::mouseReleased(int x, int y, int button){

}</code></pre>
</td></tr></table>
<p>Create a new project called MouseInteraction so we can play with them.</p>
<p><img src="images/MouseInteraction01.png" style="border-width: 0;" alt="Mouse Interaction Project"></p>
<p>Let&#8217;s do the same thing with the mouse functions that we did with the key functions. Add the following to your project:</p>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="10"><tr><td>
<pre><code class="cpp">void testApp::mouseMoved(int x, int y){
    cout &lt;&lt; "mouseMoved: " &lt;&lt; x &lt;&lt; ", " &lt;&lt; y &lt;&lt; endl;
}

void testApp::mouseDragged(int x, int y, int button){
    cout &lt;&lt; "mouseDragged: " &lt;&lt; x &lt;&lt; ", " &lt;&lt; y &lt;&lt; " button: " &lt;&lt; button &lt;&lt; endl;
}

void testApp::mousePressed(int x, int y, int button){
    cout &lt;&lt; "mousePressed: " &lt;&lt; x &lt;&lt; ", " &lt;&lt; y &lt;&lt; " button: " &lt;&lt; button &lt;&lt; endl;
}

void testApp::mouseReleased(int x, int y, int button){
     cout &lt;&lt; "mouseReleased: " &lt;&lt; x &lt;&lt; ", " &lt;&lt; y &lt;&lt; " button: " &lt;&lt; button &lt;&lt; endl;
}</code></pre>
</td></tr></table>
<p>The <em>x</em> and <em>y</em> variables in the cout statement represent the location of the mouse click&#8201;&#8212;&#8201;very handy information to have.</p>
<p>Run the program and you should see something like this:</p>
<pre><code class="cpp">mouseMoved: 627, 500
mouseMoved: 619, 500
mouseMoved: 610, 500

...

mouseMoved: 426, 473
mouseMoved: 426, 476
mouseMoved: 427, 478
mousePressed: 426, 478 button: 0
mouseDragged: 427, 477 button: 0

...

mouseDragged: 548, 411 button: 0
mouseDragged: 547, 411 button: 0
mouseDragged: 546, 411 button: 0
mouseReleased: 546, 411 button: 0
mouseMoved: 544, 411
mouseMoved: 543, 411
mousePressed: 543, 411 button: 0
mouseDragged: 542, 411 button: 0

...

mouseDragged: 433, 396 button: 0
mouseDragged: 433, 377 button: 0
mouseReleased: 433, 377 button: 0
mouseMoved: 434, 370
mouseMoved: 433, 367</code></pre>
<p>There are a few important things to notice about this output. First, you will probably see a ton of "mouseMoved" messages. Indeed, this function is called whenever the mouse is moved so much as a single pixel, so be aware of this when adding code to mouseMoved. Next, notice that you see a "mousePressed" before every "mouseDragged" event, and then a bunch of "mouseDragged" messages, and then "mouseReleased" before it switches back to "mouseMoved".</p>
<h3><a name="_interacting_with_graphics"></a>6.1. Interacting With Graphics</h3>
<p>So now we know how to make something happen when the user does any mouse business. But printing to the console is hardly the kind of interaction we want. When it comes to interacting with GUI applications, the mouse is used in a variety of ways: simple clicking, double-clicking, dragging, hovering, gestures, etc. One very basic interaction is "user clicks on something, something happens." Let&#8217;s see how we might accomplish this.</p>
<p>Suppose, for instance, that we wanted our trusty circle to expand whenever the user clicks on it. Let&#8217;s start by setting up a new project called MouseInteraction2. It will start out very similar to our <em>MouseInteraction</em> project:</p>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="10"><tr><td>
<pre><code class="cpp">int myCircleX=200;
int myCircleY=300;
int myCircleRadius=100;

void testApp::setup(){
}

void testApp::update(){
}

void testApp::draw(){
    ofSetColor(255, 0, 255);
    ofCircle(myCircleX, myCircleY, myCircleRadius);
}</code></pre>
</td></tr></table>
<p>As you can see, we have added a new variable called <em>myCircleRadius</em>. It should be clear that, if we want the circle to grow, all we have to do is increase myCircleRadius. The trick will be to determine when this should happen.</p>
<p>It&#8217;s clear that it has something to do with the mousePressed function that we just discovered above. We know that mousePressed is called every time the user clicks the mouse, so if we simply drop <em>myCircleRadius++;</em> into the mousePressed function, we would be half way there. Try this out.</p>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="10"><tr><td>
<pre><code class="cpp">void testApp::mousePressed(int x, int y, int button){
    myCircleRadius++;
}</code></pre>
</td></tr></table>
<p>You should find that the circle grows every time you click the mouse, regardless of whether or not your clicked inside the circle. But our challenge is to only grow the circle when the use clicks <strong>inside</strong> of it. So how might we go about this?</p>
<p>Well, luckily we are dealing with a circle, which will make it significantly easier. Because if we can determine the distance between the center of the circle and the location of the mouse click, we can compare this distance to the radius, and if it is less than the radius, then the click was inside the circle. Take a look at the diagrams:</p>
<p><img src="images/hit-test-01.png" style="border-width: 0;" alt="Hit Test 1"></p>
<p>We know that the radius of the circle = 300, and we know that the mouse click is 230 pixels away from the center of the circle. So, was the mouse click inside the circle?</p>
<p><img src="images/hit-test-02.png" style="border-width: 0;" alt="Hit Test 2"></p>
<p>In this case, we know that the mouse click was 90 pixels from the center of the circle, so the click was clearly inside the circle.</p>
<p>So how do we measure this distance? openFrameworks provides a function called
ofDist([x1], [y1], [x2], [y2]) that will save us from doing any basic trigonometry. All we have to do is give it our two coordinates.</p>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="10"><tr><td>
<pre><code class="cpp">void testApp::mousePressed(int x, int y, int button){
    float distance = ofDist(myCircleX, myCircleY, x, y);
    cout &lt;&lt; distance &lt;&lt; endl;

    myCircleRadius++;
}</code></pre>
</td></tr></table>
<p>The <em>cout</em> will allow us to check what kind of values we are getting from ofDist. Run your program now. Click around the screen and see what kind of values get printed in your console.</p>
<p>So the only thing left to do is compare <em>myCircleRadius</em> to <em>distance</em>, and we can do this using a simple if statement.</p>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="10"><tr><td>
<pre><code class="cpp">void testApp::mousePressed(int x, int y, int button){
    float distance = ofDist(myCircleX, myCircleY, x, y);
    if(distance &lt; myCircleRadius)
    {
        myCircleRadius++;
    }
}</code></pre>
</td></tr></table>
<p>This code says "first calculate the distance between the center of the circle and the mouse click. Then compare <em>distance</em> to <em>myCircleRadius</em>. If (and only if) distance is LESS THAN myCircleRadius, increment myCircleRadius by 1."</p>
<p>Et voila!  You are interacting with graphics!</p>
<hr>
<h2><a name="_technical_topics"></a>7. Technical Topics</h2>
<p>In the example above, we looked at one of the most basic control structures: the <a href="http://www.cprogramming.com/tutorial/lesson2.html">if statement</a>. Control structures like the if statement allow you to alter the flow of your program based on criteria that you define. Control structures are not an openFrameworks "thing", but rather a feature of the <tt>C++</tt> language. Let&#8217;s take a moment to review a few basics of the <tt>C++</tt> language.</p>
<h3><a name="_variables"></a>7.1. Variables</h3>
<p>In the "Adding Movement" section, we introduced the idea of using variables to represent values that change over the course of your program. We used 2 integers, or *int*s - <em>int myCircleX</em> and <em>int myCircleY</em> - to represent the location of a circle. When you declare a variable as an <em>int</em>, you are telling the computer "I only intend to put whole numbers into this variable."  This made sense in our example because we were moving a circle by a single pixel, so we didn&#8217;t need to worry about fractions.</p>
<p>But there will be times when you do need to have a variable that can hold a fraction, or something completely different, such as letters, words, even a location in memory. There are variable types for each of these situations. Here is a short list of some of them from <a href="http://www.cplusplus.com/doc/tutorial/variables/">cplusplus.com</a></p>
<p><img src="images/variable-types.png" style="border-width: 0;" alt="Variable Types"></p>
<p>So, as you can see, our basic integer takes up 4 bytes in memory. This is a finite amount of memory, and therefore there is limited (but pretty huge!) range of values that it can hold: namely, -2,147,483,648 to 2,147,483,647. If you need to store higher (or lower) numbers, you&#8217;d have to use a <em>long int</em>, which (contrary to the diagram) can go up to 9,223,372,036,854,775,807 and down to -9,223,372,036,854,775,808.</p>
<p>It may be unintuitive to make such distinctions when dealing with variables. A number is a number, right? Why differentiate between a decimal number and a whole number? The reason has to do with how values are stored in your computer&#8217;s memory. Ultimately, by giving the programmer the responsibility of declaring what range and precision their variables need, the program can run that much more efficiently.</p>
<table frame="void" cellpadding="8">
<tr valign="top"><td><p><b><u>Tip</u></b></p></td>
<td style="border-left: 1px solid silver;">
<p>Compile and run this program to see information about how your computer treats different kinds of variables.</p>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="10"><tr><td>
<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;limits.h&gt;
#include &lt;float.h&gt;
using namespace std;

int main ()
{
    cout &lt;&lt; "type \t\tsize \tmin \t\t\tmax" &lt;&lt; endl;
    cout &lt;&lt; "---------------------------------------------------------------" &lt;&lt; endl;
    cout &lt;&lt; "bool\t\t" &lt;&lt; sizeof(bool) &lt;&lt; endl;
    cout &lt;&lt; "char\t\t" &lt;&lt; sizeof(char) &lt;&lt; "\t" &lt;&lt; CHAR_MIN &lt;&lt; "\t\t\t" &lt;&lt; CHAR_MAX &lt;&lt; endl;
    cout &lt;&lt; "unsigned char\t" &lt;&lt; sizeof(unsigned char) &lt;&lt; "\t\t\t\t" &lt;&lt; UCHAR_MAX &lt;&lt; endl;
    cout &lt;&lt; "short\t\t" &lt;&lt; sizeof(short) &lt;&lt; "\t" &lt;&lt; INT_MIN &lt;&lt; "\t\t" &lt;&lt; INT_MAX &lt;&lt; endl;
    cout &lt;&lt; "int\t\t" &lt;&lt; sizeof(int) &lt;&lt; "\t" &lt;&lt; INT_MIN &lt;&lt; "\t\t" &lt;&lt; INT_MAX &lt;&lt; endl;
    cout &lt;&lt; "unsigned int\t" &lt;&lt; sizeof(unsigned int) &lt;&lt; "\t\t\t\t" &lt;&lt; UINT_MAX &lt;&lt; endl;
    cout &lt;&lt; "float\t\t" &lt;&lt; sizeof(float) &lt;&lt; "\t" &lt;&lt; FLT_MIN &lt;&lt; "\t\t" &lt;&lt; FLT_MAX &lt;&lt; endl;
    cout &lt;&lt; "long\t\t" &lt;&lt; sizeof(long) &lt;&lt; "\t" &lt;&lt; LONG_MIN &lt;&lt; "\t" &lt;&lt; LONG_MAX &lt;&lt; endl;
    cout &lt;&lt; "double\t\t" &lt;&lt; sizeof(double) &lt;&lt; "\t" &lt;&lt; DBL_MIN &lt;&lt; "\t\t" &lt;&lt; DBL_MAX &lt;&lt; endl;
    return 0;
}</code></pre>
</td></tr></table>
</td></tr></table>
<p>There is one important kind of variable that is not covered in this chart: <em>string</em>. A string can hold a sequence of characters. &#8230; more to come &#8230;</p>
<h3><a name="_loops"></a>7.2. Loops</h3>
<p>Loops are perhaps one of the most important things to be comfortable with as a programmer. They are, arguably, the main advantage of using a computer: doing something over and over again very rapidly is the definition of what a computer is good at. There are a few different kinds of loops, and it is important to be familiar with all of them.</p>
<p>Suppose you want to a circle every 20 pixels across your window. One option would be to copy and paste ofCircle commands like this:</p>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="10"><tr><td>
<pre><code class="cpp">void testApp::draw(){
    ofCircle(20, 300, 10);
    ofCircle(40, 300, 10);
    ofCircle(60, 300, 10);
    ofCircle(80, 300, 10);
    ofCircle(100, 300, 10);
    ofCircle(120, 300, 10);
    // repeat
    ofCircle(1020, 300, 10);
}</code></pre>
</td></tr></table>
<p>That would be over 50 lines of code - ugh. And what if you decided you wanted them every 30 pixels instead of every 20 pixels?  You&#8217;d have to go back and edit each line of code. And what if the size of your window changed?  This is clearly unacceptable. Consider this code:</p>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="10"><tr><td>
<pre><code class="cpp">void testApp::draw(){
    int x = 10;

    ofCircle(x, 300, 10);
    x += 20;
    ofCircle(x, 300, 10);
    x += 20;
    ofCircle(x, 300, 10);
    x += 20;
    ofCircle(x, 300, 10);
    x += 20;
    // copy and paste 47 more times
}</code></pre>
</td></tr></table>
<p>In some ways, this is even worse. We&#8217;ve turned one line of code per circle into 2 lines of code per circle. However, there is one very important difference: in this case, the 2 lines are identical every time. We have "abstracted" the task&#8201;&#8212;&#8201;that is, we have taken out the specifics and made it into a more general form.</p>
<p>So now, all that&#8217;s left to do is to tell the computer to do those 2 lines of code a bunch of times instead of us pasting it in ourselves. This is where loops come in.</p>
<h4><a name="_do_8230_while_loop"></a>7.2.1. do&#8230;while loop</h4>
<p>All loops basically take the same form:</p>
<ol type="1">
<li>
<p>
Set up some initial values (initialization)
</p>
</li>
<li>
<p>
Execute the body of the loop
</p>
</li>
<li>
<p>
Decide whether to go back to step 2 or exit the loop
</p>
</li>
</ol>
<p>The simplest loop is the do/while loop. As the name suggests, this loop allows you to ask the computer to "do" something "while" a condition is met. Using a do/while loop, we can easily draw 51 circles</p>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="10"><tr><td>
<pre><code class="cpp">void testApp::draw(){
    int i = 0;
    int x = 20;
    do {
        ofCircle(x, 300, 10);
        x+=20;
        i++;
    } while( i &lt; 51 );
}</code></pre>
</td></tr></table>
<p>So what just happened?  Let&#8217;s go through the code step by step as if we were the computer. I apologize that this is the most tedious thing you will ever read, but hopefully it will illustrate what is going on in the loop.</p>
<ol type="1">
<li>
<p>
Initialize a variable called i and set it equal to 0
</p>
</li>
<li>
<p>
Initialize a variable called x and set it equal to 20
</p>
</li>
<li>
<p>
Draw a circle at (20, 30) with a radius of 10
</p>
</li>
<li>
<p>
Increment x by 20 (it now equals 40)
</p>
</li>
<li>
<p>
Increment i by 1 (it now equals 1)
</p>
</li>
<li>
<p>
Is 1 less than 51?
</p>
<ol type="a">
<li>
<p>
Yes!  Go back to the beginning of the loop
</p>
</li>
</ol>
</li>
<li>
<p>
Draw a circle at (40, 30) with a radius of 10
</p>
</li>
<li>
<p>
Increment x by 20 (it now equals 60)
</p>
</li>
<li>
<p>
Increment i by 1 (it now equals 2)
</p>
</li>
<li>
<p>
Is 2 less than 51?
</p>
<ol type="a">
<li>
<p>
Yes!  Go back to the beginning of the loop
</p>
</li>
</ol>
</li>
<li>
<p>
Draw a circle at (60, 30) with a radius of 10
</p>
</li>
<li>
<p>
Increment x by 20 (it now equals 80)
</p>
</li>
<li>
<p>
Increment i by 1 (it now equals 3)
</p>
</li>
<li>
<p>
Is 3 less than 51?
</p>
<ol type="a">
<li>
<p>
Yes!  Go back to the beginning of the loop
</p>
</li>
</ol>
</li>
<li>
<p>
[REPEAT 46 TIMES UNTIL i=50 and x=1000]
</p>
</li>
<li>
<p>
Draw a circle at (1000, 30) with a radius of 10
</p>
</li>
<li>
<p>
Increment x by 20 (it now equals 1020)
</p>
</li>
<li>
<p>
Increment i by 1 (it now equals 51)
</p>
</li>
<li>
<p>
Is 51 less than 51?
</p>
<ol type="a">
<li>
<p>
NO!  Exit out of loop and continue on to whatever comes next
</p>
</li>
</ol>
</li>
</ol>
<table frame="void" cellpadding="8">
<tr valign="top"><td><p><b><u>Tip</u></b></p></td>
<td style="border-left: 1px solid silver;">
<p>We could actually make this even a bit more efficient and make the <em>x</em> variable to double duty like this:</p>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="10"><tr><td>
<pre><code class="cpp">int x = 20;
do {
    ofCircle(x, 300, 10);
    x+=20;
} while(x &lt; ofGetWidth());</code></pre>
</td></tr></table>
<p>This has the added advantage of being immune to changes in window size. Try making the window bigger and smaller&#8201;&#8212;&#8201;the circles will always be drawn to the end of the window.</p>
</td></tr></table>
<h4><a name="_while_loop"></a>7.2.2. while loop</h4>
<p>In a while loop, the <em>while</em> part is simply moved up to the top of the loop. So if we want to draw a string of circles with a while loop, it would look like this:</p>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="10"><tr><td>
<pre><code class="cpp">int i = 0;
int x = 20;
while(i &lt; 51)
{
    ofCircle(x, 300, 10);
    x+=20;
    i++;
}</code></pre>
</td></tr></table>
<p>The only difference between a do&#8230;while loop and a while loop is that the the condition happens first, before the loop body runs. For example, suppose we edited our do&#8230;while loop like this:</p>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="10"><tr><td>
<pre><code class="cpp">int x = 10;
do {
    ofCircle(x, 300, 10);
    x += 20;
} while( x &lt; mouseX );</code></pre>
</td></tr></table>
<p>Notice how we&#8217;ve changed the condition so that the circles will be drawn until <em>x</em> is less than the x position of the mouse. Run this code and see what happens. Notice, in particular, that there is always 1 circle on the screen regardless of how far to the left the mouse goes. Now transform that into a while loop:</p>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="10"><tr><td>
<pre><code class="cpp">int x = 10;
while( x &lt; mouseX )
{
    ofCircle(x, 300, 10);
    x += 20;
}</code></pre>
</td></tr></table>
<p>Now, if you move your mouse beyond the left side of the window, nothing at all is drawn. This is because before the body of the loop is executed (namely the ofCircle draw command), the test is done. So if mouseX is less than x, no circles are drawn at all.</p>
<h4><a name="_for_loop"></a>7.2.3. for loop</h4>
<p>We&#8217;ve saved the best for last. The for loop is probably the one that you will use the most. This might be because it combines all 3 parts of a loop (initialization, condition, and incrementing) into one compact syntax. Let&#8217;s draw the same circles using a for loop:</p>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="10"><tr><td>
<pre><code class="cpp">int x = 20;
for(int i=0; i&lt;51; i++)
{
    ofCircle(x, 300, 10);
    x+=20;
}</code></pre>
</td></tr></table>
<p>The syntax of the for loop can be a little daunting at first, but let&#8217;s take it apart piece by piece. The first part is initialization: "int i=0;"  Pretty straightforward: we now have an integer called i that we have set to 0. The next part is the condition: "i&lt;51". In other words, we want the loop to continue so long as i is less than 51. And lastly,  the increment: "i++". After every iteration of the loop, we will increment i by 1.</p>
<p>We saw each of these things in the other kind of loops. The only difference here is that they are all smashed into one line.</p>
<h3><a name="_arrays"></a>7.3. Arrays</h3>
<p>Another strength of computers is that they are encyclopedic: that is, they can keep track of a huge number of things at a time. Suppose we want to draw six thousand moving particles?  We know from the loop section that it is trivial to do something over and over again, but so far, we have only used loops to achieve a relatively consistent pattern. If we want do draw tons of particles, each with their own position, things get a little more complicated.</p>
<div>
<img src="images/Arrays01.png" style="border-width: 0;" alt="Arrays!" width="500">
<p><b>Figure 1. </b>50000 particles!</p>
</div>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="10"><tr><td>
<pre><code class="cpp">float circle1x;
float circle1y;
float circle1r;
float circle2x;
float circle2y;
float circle2r;
float circle3x;
float circle3y;
float circle3r;

void testApp::setup(){
    ofSetFrameRate(24);

    circle1x = ofRandom(0, ofGetWidth());
    circle1y = ofRandom(0, ofGetHeight());
    circle1r = ofRandom(10, 40);

    circle2x = ofRandom(0, ofGetWidth());
    circle2y = ofRandom(0, ofGetHeight());
    circle2r = ofRandom(10, 40);

    circle3x = ofRandom(0, ofGetWidth());
    circle3y = ofRandom(0, ofGetHeight());
    circle3r = ofRandom(10, 40);

}

void testApp::update(){
    circle1x += ofRandom(-1,1);
    circle1y += ofRandom(-1,1);

    circle2x += ofRandom(-1,1);
    circle2y += ofRandom(-1,1);

    circle3x += ofRandom(-1,1);
    circle3y += ofRandom(-1,1);
}

void testApp::draw(){
    ofCircle(circle1x, circle1y, circle1r);

    ofCircle(circle2x, circle2y, circle2r);

    ofCircle(circle3x, circle3y, circle3r);
}</code></pre>
</td></tr></table>
<table frame="void" cellpadding="8">
<tr valign="top"><td><p><b><u>Tip</u></b></p></td>
<td style="border-left: 1px solid silver;">
<p>Notice the use of ofRandom(). This function will return a random number. It takes 2 arguments: the minimum possible value and the maximum possible value. What I am saying in this code is "give me a number between 0 and the width of the screen."</p>
</td></tr></table>
<p>Technically this works, but we have only drawn 3 circles, and already the code is getting unwieldy. We want to draw 1000! We clearly have a bunch of variables that are used in very similar ways. Why not group, say, all of the x coordinates into a single set, and all of the y coordinates, etc.?</p>
<p>These sets are called arrays. Check out the following code:</p>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="10"><tr><td>
<pre><code class="cpp">float circleX[3];
float circleY[3];
float circleRad[3];

void testApp::setup(){
    ofSetFrameRate(24);

    circleX[0] = ofRandom(0, ofGetWidth());
    circleY[0] = ofRandom(0, ofGetHeight());
    circleRad[0] = ofRandom(10, 40);

    circleX[1] = ofRandom(0, ofGetWidth());
    circleY[1] = ofRandom(0, ofGetHeight());
    circleRad[1] = ofRandom(10, 40);

    circleX[2] = ofRandom(0, ofGetWidth());
    circleY[2] = ofRandom(0, ofGetHeight());
    circleRad[2] = ofRandom(10, 40);
}

void testApp::update(){

    circleX[0] += ofRandom(-1,1);
    circleY[0] += ofRandom(-1,1);

    circleX[1] += ofRandom(-1,1);
    circleY[1] += ofRandom(-1,1);

    circleX[2] += ofRandom(-1,1);
    circleY[2] += ofRandom(-1,1);
}

void testApp::draw(){

    ofCircle(circleX[0], circleY[0], circleRad[0]);
    ofCircle(circleX[1], circleY[1], circleRad[1]);
    ofCircle(circleX[2], circleY[2], circleRad[2]);
}</code></pre>
</td></tr></table>
<p>As you can see, we&#8217;ve replaced int circle1x, int circle2x, and int circle3x with simply int circleX[3]. Now circleX is an "array" that can hold up to 3 integers, rather than just 1. Read a little further, and you will see that, in order to assign a value to one of the ints in the array, you use the square brackets, like this: circleX[0] = 50;</p>
<p>Down in the draw function, you can see that we use the same syntax to use the values that we have previously assigned to a particular slot in the array.</p>
<p>But this is still kind of a mess. One sign that you might not be utilizing loops as much as possible is if you see patterns in your code&#8201;&#8212;&#8201;that is, similar sequences of code over and over again. So let&#8217;s try to clean this up even more using some <em>for</em> loops.</p>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="10"><tr><td>
<pre><code class="cpp">float circleX[3];
float circleY[3];
float circleRad[3];

void testApp::setup(){
    ofSetFrameRate(24);

    for(int i=0; i&lt;3; i++)
    {
        circleX[i] = ofRandom(0, ofGetWidth());
        circleY[i] = ofRandom(0, ofGetHeight());
        circleRad[i] = ofRandom(10, 40);
    }
}

void testApp::update(){

    for(int i=0; i&lt;3; i++)
    {
        circleX[i] += ofRandom(-1,1);
        circleY[i] += ofRandom(-1,1);
    }
}

void testApp::draw(){

    for(int i=0; i&lt;3; i++)
    {
        ofCircle(circleX[i], circleY[i], circleRad[i]);
    }
}</code></pre>
</td></tr></table>
<p>Now, instead of putting hard-coded numbers between the square brackets, we use the <em>i</em> variable of our for loop.</p>
<h4><a name="_define"></a>7.3.1. #define</h4>
<p>A wise person once said: the primary virtue of a programmer is laziness. Suppose you wanted to change the number of circles that appear on the screen from 3 to 500. Obviously, the first step would be to change circleX[3] to circleX[500], and likewise circleY and circleRad. Oh, but that&#8217;s not all. You&#8217;d still have to go through every "for" loop and change i&lt;3 to i&lt;50. That&#8217;s a lot of work!</p>
<p>It would be great if we could use a variable to keep track of how many items we have in our array! It might look something like this:</p>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="10"><tr><td>
<pre><code class="cpp">int num = 500;
float circleX[num];
float circleY[num];
float circleRad[num];</code></pre>
</td></tr></table>
<p>Unfortunately, this isn&#8217;t possible. You can&#8217;t use a variable to declare a variable.</p>
<p>Instead, we will use a new thing called a #define (pronounced: "pound define"). Take a look at this:</p>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="10"><tr><td>
<pre><code class="cpp">#define NUM_CIRCLES 500

float circleX[NUM_CIRCLES];
float circleY[NUM_CIRCLES];
float circleRad[NUM_CIRCLES];
int circleR[NUM_CIRCLES];
int circleG[NUM_CIRCLES];
int circleB[NUM_CIRCLES];

void testApp::setup(){
    ofSetFrameRate(24);

    for(int i=0; i&lt;NUM_CIRCLES; i++)
    {
        circleX[i] = ofRandom(0, ofGetWidth());
        circleY[i] = ofRandom(0, ofGetHeight());
        circleRad[i] = ofRandom(10, 40);

        circleR[i] = ofRandom(0, 255);
        circleG[i] = ofRandom(0, 255);
        circleB[i] = ofRandom(0, 255);
    }
}

void testApp::update(){

    for(int i=0; i&lt;NUM_CIRCLES; i++)
    {
        circleX[i] += ofRandom(-1,1);
        circleY[i] += ofRandom(-1,1);
    }
}

void testApp::draw(){

    for(int i=0; i&lt;NUM_CIRCLES; i++)
    {
        ofSetColor(circleR[i], circleG[i], circleB[i]);
        ofCircle(circleX[i], circleY[i], circleRad[i]);
    }
}</code></pre>
</td></tr></table>
<p>At the very top, notice the line "#define NUM_CIRCLES 500". This isn&#8217;t technically a line of <tt>C++</tt> code, but rather a message to your compiler. It tells the compiler "before you start compiling code, anywhere you see NUM_CIRCLES, replace it with 500". That&#8217;s it! A #define is one of a couple messages that you can send to the compiler (or, more accurately, the preprocessor), known more broadly as <a href="http://www.cplusplus.com/doc/tutorial/preprocessor/">preprocessor directives</a>. We will talk more about them at a later date., but for now, all you need to know is that #define is a very simple find/replace procedure.</p>
<h3><a name="_functions"></a>7.4. Functions</h3>
<p>In the examples above you had blocks of code enclosed in curly braces. To compose some more abstract functionality you also group instructions and call this group my a name. Look at the following example:</p>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="10"><tr><td>
<pre><code class="cpp">void drawStar(float xpos, float ypos, float radius, int npts)
{
    bool useInner=false;
    ofBeginShape();
    for(int i=0; i&lt;360; i+=360/npts)
    {
        int r = useInner ? radius*.6 : radius;
        int x = xpos + cos( ofDegToRad(i) ) * r;
        int y = ypos + sin( ofDegToRad(i) ) * r;
        ofVertex(x, y);
        useInner = !useInner;
    }
    ofEndShape();
}</code></pre>
</td></tr></table>
<p>Here you see the definition of a <a href="http://www.cplusplus.com/doc/tutorial/functions/">function</a>. A function is a named group of instruction which might take some input in the form of variables and might return some output. It might also be called a <a href="https://en.wikipedia.org/wiki/Subroutine">subroutine</a>, depending on the context. Line 1 shows what is called the signature of a function. It first names the type of the data returned. Void means no data will be returned, int means a whole number gets returned, and so on. The return data type is followed by the name of the function ("drawStar") and finally a list of arguments. The list of arguments first states the data type (e.g. "int") and then a variable name (e.g. "xpos"). The argument variables are visible by their name inside the function body (aka. the curly braces), but not outside. The following code should make these concepts more clear.</p>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="10"><tr><td>
<pre><code class="cpp">int add2(int number)
{
        return number + 2;
}

...

void other(float arg)
{
        int ivalue = 4;
        ivalue = add2(ivalue);
}</code></pre>
</td></tr></table>
<p>The function "add2" takes an integer as an argument ("number") and adds two to it. This value gets returned by the "return" statement. A "void" function (usually) does not have a return statement. The variable "number" can be seen and accessed inside the "add2" function, but not the inside the "other" function. When calling the "add2" function, the value of "ivalue" (4) gets copied over into "number". Then "add2" is executed and the return value (4 + 2 = 6) calculated. This is then passed back add assigned to "ivalue".</p>
<p>There are other noteworthy things about the "drawStar" function. As you can see in the source, a function can have its own variables (like "useInner"), which only exist inside the function body. A function can call other functions, as demonstrated with "ofBeginShape()", "ofDegToRad()" and so on. The line 7 is an abbreviated if statement. A more recognizable way to write it is:</p>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="10"><tr><td>
<pre><code class="cpp">int r;
if (useInner) {
   r = radius*.6;
} else {
  r = radius;
}</code></pre>
</td></tr></table>
<p>This abbreviated syntax might be useful if each alternative consists of only one statement to be executed, but is also easy to overlook when trying to find bugs (programming errors) in a program. The more verbose version is easier to spot and understand. It also is easier to extend if needed.</p>
<p>All the concepts introduced should give you the basic tools to study and understand the example code provided. We covered a lot of ground, so go and poke at the other examples!</p>

    		</div>
            
        </div><!-- End Page Wide -->      
      </div><!-- End Body Wrap -->
      
      <div id="footer">
        
  <p id="credits">


  
Wednesday, 20 January 2016 08:11:24 UTC
에 마지막으로 업데이트됨&nbsp;&nbsp;&nbsp;-&nbsp;&nbsp;&nbsp;<a href="https://github.com/icq4ever/ofSiteKR/commit/

a3bc56d1679a37103d24b7511dc0fbd9e9bba47f
">

a3bc56d1679a37103d24b7511dc0fbd9e9bba47f
</a>

<!--br/>RSS feeds for <a href="/feed">Entries</a-->

<br/>
<!--Hosting for openFrameworks is generously provided by Rackspace-->
hosting for openFrameworks.kr is provided by github.com
</p>


<!--tracking -->
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
var pageTracker = _gat._getTracker("UA-71930909-1");
pageTracker._trackPageview();
} catch(err) {}</script>






      </div> <!-- End Footer -->
    </div> <!-- End Content -->
  </body>
</html>







